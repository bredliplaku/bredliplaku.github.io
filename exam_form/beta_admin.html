.code-snippet {
    background-color: #1f2937 !important;
    color: #e5e7eb !important;
    padding: 10px !important;
    border-radius: 6px !important;
    font-family: monospace !important;
    overflow: auto !important;
    max-height: 200px !important;
    white-space: pre-wrap !important;
    padding-top: 30px !important; /* Make room for the copy button */
}<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Admin Portal - Exam Management</title>
    <link rel="icon" type="image/png" href="https://bredliplaku.github.io/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        /* --- Modern CSS Reset --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; }
        html, body { height: 100%; scroll-behavior: smooth; }
        img, picture, video, canvas, svg { display: block; max-width: 100%; }
        input, button, textarea, select { font: inherit; }
        
        /* --- Enhanced Color Variables --- */
        :root {
            /* Primary colors */
            --primary-50: #e8f0fe;
            --primary-100: #c2d9f9;
            --primary-200: #9ac1f4;
            --primary-300: #72a9ee;
            --primary-400: #4e95e9;
            --primary-500: #3366FF; /* Main primary */
            --primary-600: #2c5fe6;
            --primary-700: #2554d9;
            --primary-800: #1e4acc;
            --primary-900: #1537b3;
            
            /* Secondary colors */
            --secondary-500: #FF9500; /* Main secondary */
            --secondary-600: #F08200;
            --secondary-700: #DD7500;
            
            /* Neutrals */
            --neutral-50: #f9fafb;
            --neutral-100: #f3f4f6;
            --neutral-200: #e5e7eb;
            --neutral-300: #d1d5db;
            --neutral-400: #9ca3af;
            --neutral-500: #6b7280;
            --neutral-600: #4b5563;
            --neutral-700: #374151;
            --neutral-800: #1f2937;
            --neutral-900: #111827;
            
            /* Feedback colors */
            --success-light: #d1fae5;
            --success: #10b981;
            --success-dark: #065f46;
            
            --warning-light: #fef3c7;
            --warning: #f59e0b;
            --warning-dark: #92400e;
            
            --error-light: #fee2e2;
            --error: #ef4444;
            --error-dark: #b91c1c;
            
            --info-light: #dbeafe;
            --info: #3b82f6;
            --info-dark: #1e40af;
            
            /* Background & text */
            --bg-body: #f9fafb;
            --bg-card: #ffffff;
            --bg-hover: #f3f4f6;
            --text-primary: #111827;
            --text-secondary: #4b5563;
            --text-tertiary: #6b7280;
            --text-light: #ffffff;
            
            /* Other UI elements */
            --border: #e5e7eb;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --shadow-inner: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            
            /* Sizing & spacing */
            --header-height: 64px;
            --sidebar-width: 260px;
            --border-radius-sm: 0.25rem;
            --border-radius: 0.5rem;
            --border-radius-md: 0.75rem;
            --border-radius-lg: 1rem;
            --border-radius-full: 9999px;
            
            /* Animation */
            --transition-fast: 150ms;
            --transition: 200ms;
            --transition-slow: 300ms;
        }
        
        /* --- Base Styles --- */
        body, html { 
            margin: 0; 
            padding: 0; 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 
            background: var(--bg-body); 
            color: var(--text-primary); 
            line-height: 1.6;
            letter-spacing: -0.01em;
        }
        
        .container { 
            max-width: 1440px; 
            margin: 0 auto; 
            padding: 24px;
            padding-bottom: 60px;
        }
        
        /* --- Content Visibility --- */
        .content-hidden { 
            visibility: hidden; 
            opacity: 0; 
        }
        
        .content-visible { 
            visibility: visible; 
            opacity: 1; 
            transition: opacity 0.5s ease-in; 
        }
        
        /* --- App Header --- */
        .app-header { 
            background: linear-gradient(100deg, var(--primary-600), var(--primary-800));
            color: var(--text-light); 
            padding: 24px 32px; 
            border-radius: var(--border-radius-md); 
            margin-bottom: 30px; 
            box-shadow: var(--shadow-md);
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        
        .app-header::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 30%;
            background: linear-gradient(120deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
            transform: skewX(-20deg) translateX(50%);
            z-index: 1;
        }
        
        /* --- Typography --- */
        h1 { 
            margin: 0; 
            font-size: 1.75rem; 
            display: flex; 
            align-items: center; 
            font-weight: 600;
            letter-spacing: -0.02em;
        }
        
        h1 i { 
            margin-right: 14px; 
            font-size: 1.2em; 
            opacity: 0.9; 
        }
        
        h2 { 
            margin: 0 0 16px 0; 
            font-weight: 600; 
            font-size: 1.35rem;
            color: var(--text-primary); 
            padding-bottom: 12px;
            display: flex; 
            align-items: center;
            position: relative;
            letter-spacing: -0.01em;
        }
        
        h2::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: 0;
            width: 40px;
            height: 3px;
            background: var(--primary-500);
            border-radius: var(--border-radius-full);
        }
        
        h2 i { 
            margin-right: 12px; 
            color: var(--primary-500);
            font-size: 1.1em;
        }
        
        /* --- Card Modules --- */
        .module { 
            background-color: var(--bg-card); 
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow);
            margin-bottom: 32px; 
            overflow: hidden; 
            transition: transform var(--transition), box-shadow var(--transition);
            border: 1px solid var(--border);
        }
        
        .module:hover {
            box-shadow: var(--shadow-md);
        }
        
        .module-content { 
            padding: 24px 28px;
        }
        
        /* --- Prompt Messages --- */
        .prompt-message { 
            text-align: center; 
            padding: 48px 24px; 
            margin-top: 20px; 
            border-radius: var(--border-radius-md);
            background-color: var(--bg-card); 
            box-shadow: var(--shadow);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }
        
        .prompt-message h3 { 
            margin-top: 16px; 
            margin-bottom: 12px; 
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .prompt-message i { 
            font-size: 2.5rem;
            color: var(--primary-500); 
            margin-bottom: 16px; 
            display: block;
        }
        
        .prompt-message.access-denied i { 
            color: var(--error);
        }
        
        /* --- Buttons --- */
        button { 
            display: inline-flex; 
            align-items: center; 
            justify-content: center; 
            gap: 8px; 
            background-color: var(--primary-500);
            color: var(--text-light); 
            padding: 10px 20px; 
            border-radius: var(--border-radius-full);
            font-size: 0.9rem;
            font-weight: 500; 
            transition: all var(--transition);
            box-shadow: var(--shadow-sm);
            border: none; 
            cursor: pointer; 
            margin: 5px 2px;
            min-height: 40px;
            letter-spacing: 0.01em;
        }
        
        button:hover:not(:disabled) { 
            background-color: var(--primary-600);
            transform: translateY(-1px); 
            box-shadow: var(--shadow); 
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }
        
        button:focus {
            outline: 2px solid var(--primary-200);
            outline-offset: 2px;
        }
        
        button:disabled { 
            background-color: var(--neutral-300);
            color: var(--neutral-500);
            cursor: not-allowed; 
            transform: none; 
            box-shadow: none;
        }
        
        button.btn-secondary { 
            background-color: var(--neutral-700);
            color: var(--text-light);
        }
        
        button.btn-secondary:hover:not(:disabled) { 
            background-color: var(--neutral-800);
        }
        
        button.btn-success { 
            background-color: var(--success);
            color: white; 
        }
        
        button.btn-success:hover:not(:disabled) { 
            background-color: var(--success-dark);
        }
        
        button.btn-danger { 
            background-color: var(--error);
            color: white; 
        }
        
        button.btn-danger:hover:not(:disabled) { 
            background-color: var(--error-dark);
        }
        
        button.btn-warning { 
            background-color: var(--warning);
            color: white; 
        }
        
        button.btn-warning:hover:not(:disabled) { 
            background-color: var(--warning-dark);
        }
        
        button.btn-info { 
            background-color: var(--info);
            color: white; 
        }
        
        button.btn-info:hover:not(:disabled) { 
            background-color: var(--info-dark);
        }
        
        button.btn-sm { 
            padding: 6px 14px; 
            font-size: 0.85rem;
            min-height: 32px;
        }
        
        /* --- Notifications --- */
        .in-page-notifications { 
            position: fixed; 
            bottom: 20px; 
            right: 20px; 
            z-index: 10000; 
            width: 350px; 
            max-width: 90%; 
            pointer-events: none; 
        }
        
        .in-page-notification { 
            background-color: white; 
            border-radius: var(--border-radius);
            padding: 16px;
            margin-bottom: 12px; 
            box-shadow: var(--shadow-md);
            animation: slide-in 0.3s ease-out forwards; 
            overflow: hidden; 
            display: flex; 
            align-items: center; 
            opacity: 1; 
            transition: transform var(--transition-slow), opacity var(--transition-slow);
            pointer-events: auto; 
            border-left: 5px solid;
        }
        
        .in-page-notification.removing { 
            opacity: 0; 
            transform: translateX(100%); 
        }
        
        @keyframes slide-in { 
            from { transform: translateX(100%); opacity: 0; } 
            to { transform: translateX(0); opacity: 1; } 
        }
        
        .in-page-notification i.fa-icon { 
            margin-right: 15px; 
            font-size: 1.4em; 
            flex-shrink: 0; 
        }
        
        .notification-content { 
            flex-grow: 1; 
        }
        
        .notification-close { 
            background: none; 
            border: none; 
            font-size: 20px; 
            line-height: 1; 
            color: inherit; 
            opacity: 0.7; 
            padding: 0 5px; 
            margin-left: 10px; 
            cursor: pointer;
            min-height: auto;
        }
        
        .notification-close:hover { 
            opacity: 1; 
        }
        
        .in-page-notification-info { 
            border-left-color: var(--info);
            color: var(--info-dark);
            background-color: var(--info-light);
        }
        
        .in-page-notification-warning { 
            border-left-color: var(--warning);
            color: var(--warning-dark);
            background-color: var(--warning-light);
        }
        
        .in-page-notification-error { 
            border-left-color: var(--error);
            color: var(--error-dark);
            background-color: var(--error-light);
        }
        
        .in-page-notification-success { 
            border-left-color: var(--success);
            color: var(--success-dark);
            background-color: var(--success-light);
        }
        
        /* --- Footer --- */
        .footer { 
            margin-top: 60px;
            text-align: center; 
            padding: 24px 0; 
            color: var(--text-tertiary);
            border-top: 1px solid var(--border);
            font-size: 0.9rem;
        }
        
        /* --- Auth Container --- */
        .sync-auth-container { 
            display: flex; 
            justify-content: flex-end; 
            align-items: center; 
            padding: 0 0 16px 0; 
            margin-bottom: 20px; 
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap; 
            gap: 15px; 
        }
        
        .auth-container { 
            display: flex; 
            justify-content: flex-end; 
            align-items: center; 
            gap: 12px; 
        }
        
        .user-info { 
            display: flex; 
            align-items: center; 
            gap: 12px;
            background-color: var(--neutral-100);
            padding: 6px 12px 6px 6px;
            border-radius: var(--border-radius-full);
        }
        
        .user-avatar { 
            width: 36px; 
            height: 36px; 
            border-radius: 50%; 
            border: 2px solid rgba(255,255,255,0.8);
            box-shadow: var(--shadow-sm);
        }
        
        /* --- Table Styles --- */
        .data-table-container { 
            overflow-x: auto; 
            margin-top: 20px; 
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
        }
        
        table.data-table { 
            width: 100%; 
            border-collapse: collapse; 
            font-size: 0.9rem;
        }
        
        table.data-table th, 
        table.data-table td { 
            border-bottom: 1px solid var(--border);
            padding: 12px 16px; 
            text-align: left; 
            vertical-align: middle; 
        }
        
        table.data-table th { 
            background-color: var(--neutral-50);
            font-weight: 600; 
            color: var(--text-secondary);
            cursor: pointer; 
            position: relative; 
            border-bottom-width: 2px; 
            white-space: nowrap;
            transition: background-color var(--transition-fast);
        }
        
        table.data-table th:hover {
            background-color: var(--neutral-100);
        }
        
        table.data-table th .sort-icon { 
            display: inline-block; 
            margin-left: 5px; 
            font-size: 0.8em; 
            color: var(--primary-400);
        }
        
        table.data-table tbody tr { 
            transition: background-color var(--transition-fast);
        }
        
        table.data-table tbody tr:nth-child(even):not(.group-header) { 
            background-color: var(--neutral-50);
        }
        
        table.data-table tbody tr:hover:not(.group-header) { 
            background-color: var(--primary-50);
        }
        
        table.data-table td { 
            color: var(--text-secondary);
        }
        
        table.data-table td.actions-cell { 
            white-space: nowrap; 
            width: 1%; 
            text-align: right; 
        }
        
        table.data-table td.actions-cell button { 
            margin: 1px 3px; 
        }
        
        .group-header td { 
            background-color: var(--primary-600) !important; 
            color: white; 
            font-weight: 600; 
            font-size: 1.05em; 
            padding: 12px 16px; 
            border-bottom: 2px solid var(--primary-800);
        }
        
        /* --- Question UI Styles --- */
        .question-summary-header {
            font-weight: 600;
            color: var(--primary-700);
            margin-bottom: 10px;
            border-bottom: 1px solid var(--neutral-200);
            padding-bottom: 6px;
        }
        
        .question-list-item {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px dotted var(--neutral-200);
            position: relative;
        }
        
        .question-type-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background-color: var(--neutral-100);
            border-radius: var(--border-radius-sm);
            padding: 3px 8px;
            font-size: 0.8em;
            color: var(--text-secondary);
            margin-right: 6px;
        }
        
        .question-points-badge {
            display: inline-block;
            background-color: var(--primary-500);
            color: white;
            border-radius: var(--border-radius-full);
            padding: 2px 8px;
            font-size: 0.75em;
            margin-left: 6px;
        }
        
        .question-snippet {
            margin-top: 6px;
            font-size: 0.9em;
            color: var(--text-tertiary);
        }
        
        .question-list-more {
            font-style: italic;
            color: var(--text-tertiary);
            font-size: 0.85em;
            text-align: center;
            margin: 6px 0;
        }
        
        .view-all-questions-btn {
            margin-top: 8px;
            width: 100%;
        }
        
        /* --- Filter Styles --- */
        .filter-container { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 16px; 
            margin-bottom: 24px; 
            padding: 20px; 
            background-color: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
        }
        
        .filter-container .form-group { 
            margin-bottom: 0; 
            flex: 1 1 200px;
        }
        
        .filter-container label { 
            font-size: 0.9em; 
            margin-bottom: 6px;
            font-weight: 500;
            color: var(--text-secondary);
            display: block;
        }
        
        .filter-container input { 
            padding: 10px 12px;
            font-size: 0.95em;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            width: 100%;
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }
        
        .filter-container input:focus {
            outline: none;
            border-color: var(--primary-400);
            box-shadow: 0 0 0 3px var(--primary-100);
        }
        
        /* --- Dialog Styles --- */
        .dialog-backdrop { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
            z-index: 1000; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            opacity: 0; 
            visibility: hidden; 
            transition: opacity var(--transition-slow), visibility 0s var(--transition-slow);
            padding: 20px; 
        }
        
        .dialog-backdrop.visible { 
            opacity: 1; 
            visibility: visible; 
            transition: opacity var(--transition-slow), visibility 0s 0s; 
        }
        
        .dialog { 
            background-color: white; 
            border-radius: var(--border-radius-lg);
            padding: 0; 
            width: 100%; 
            max-width: 900px;
            box-shadow: var(--shadow-lg);
            margin: 0; 
            max-height: calc(100vh - 40px); 
            display: flex; 
            flex-direction: column; 
            transform: scale(0.95); 
            transition: transform var(--transition-slow);
            border: 1px solid var(--border);
        }
        
        .dialog-backdrop.visible .dialog { 
            transform: scale(1); 
        }
        
        .dialog-header { 
            padding: 20px 28px; 
            border-bottom: 1px solid var(--border);
            flex-shrink: 0; 
            background-color: var(--neutral-50);
            border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0;
        }
        
        .dialog-title { 
            margin: 0; 
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .dialog-content { 
            padding: 24px 28px; 
            overflow-y: auto; 
            flex-grow: 1; 
        }
        
        .dialog-actions { 
            padding: 16px 28px; 
            display: flex; 
            justify-content: flex-end; 
            gap: 12px; 
            border-top: 1px solid var(--border);
            flex-shrink: 0; 
            background-color: var(--neutral-50);
            border-radius: 0 0 var(--border-radius-lg) var(--border-radius-lg);
        }
        
        /* --- Forms --- */
        .form-group { 
            margin-bottom: 20px; 
        }
        
        .form-group label { 
            display: block; 
            margin-bottom: 8px; 
            font-weight: 500; 
            font-size: 0.95em; 
            color: var(--text-secondary);
        }
        
        .form-control { 
            width: 100%; 
            padding: 10px 14px; 
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            font-size: 1em; 
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }
        
        .form-control:focus { 
            border-color: var(--primary-400);
            outline: none; 
            box-shadow: 0 0 0 3px var(--primary-100);
        }
        
        textarea.form-control { 
            min-height: 80px; 
            resize: vertical; 
        }
        
        /* --- Badges and Status Indicators --- */
        .badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 3px 8px;
            border-radius: var(--border-radius-full);
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .badge-success {
            background-color: var(--success-light);
            color: var(--success-dark);
        }
        
        .badge-info {
            background-color: var(--info-light);
            color: var(--info-dark);
        }
        
        .badge-warning {
            background-color: var(--warning-light);
            color: var(--warning-dark);
        }
        
        .badge-danger {
            background-color: var(--error-light);
            color: var(--error-dark);
        }
        
        .badge-secondary {
            background-color: var(--neutral-200);
            color: var(--neutral-700);
        }
        
        /* --- Responsive Adjustments --- */
        @media (max-width: 768px) {
            .container { 
                padding: 16px; 
            }
            
            .app-header { 
                flex-direction: column; 
                align-items: flex-start; 
                gap: 16px; 
                padding: 20px; 
            }
            
            h1 { 
                font-size: 1.4rem; 
            }
            
            .sync-auth-container { 
                justify-content: center; 
            }
            
            .module-content { 
                padding: 20px; 
            }
            
            table.data-table { 
                font-size: 0.85em; 
            }
            
            table.data-table th, 
            table.data-table td { 
                padding: 10px 12px; 
            }
            
            .dialog { 
                max-width: calc(100% - 20px); 
                max-height: calc(100vh - 20px); 
            }
            
            .dialog-header { 
                padding: 16px 20px; 
            }
            
            .dialog-content { 
                padding: 20px; 
            }
            
            .dialog-actions { 
                padding: 12px 20px; 
            }
            
            button {
                padding: 8px 16px;
            }
        }
        
        /* --- Print Styles --- */
        @media print {
            body * {
                visibility: hidden;
            }
            
            .print-container, .print-container * {
                visibility: visible;
            }
            
            .print-container {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
            }
            
            .no-print {
                display: none !important;
            }
        }
    </style>
</head>
<body class="content-hidden">

    <div class="container" id="main-container">

        <div class="sync-auth-container">
            <div class="auth-container">
                <div id="login-container"><button id="admin-signin-btn" class="btn-secondary"><i class="fab fa-google"></i> Sign In</button></div>
                <div id="user-container" style="display: none">
                    <div class="user-info">
                        <img id="user-avatar" class="user-avatar" src="" alt="Avatar">
                        <span id="user-name" style="font-weight: 500;"></span>
                        <button id="admin-signout-btn" class="btn-sm btn-danger"><i class="fas fa-sign-out-alt"></i> Sign Out</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="app-header" id="admin-header" style="display: none;">
            <h1><i class="fas fa-user-shield"></i> Exam Admin Portal</h1>
        </div>

        <div id="signin-prompt-module" class="module" style="display: none;">
            <div class="module-content prompt-message"><i class="fas fa-lock"></i><h3>Admin Access Required</h3><p>Please sign in with the authorised Google Account.</p></div>
        </div>
        <div id="access-denied-module" class="module" style="display: none;">
            <div class="module-content prompt-message access-denied"><i class="fas fa-ban"></i><h3>Access Denied</h3><p>The signed-in account (<span id="denied-user-email"></span>) is not authorised.</p></div>
        </div>

        <div id="admin-dashboard-module" style="display: none;">

            <div id="exams-module" class="module">
                 <div class="module-content">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px; margin-bottom: 20px;">
                        <h2><i class="fas fa-file-alt"></i> Manage Exams</h2>
                        <div class="button-group">
                            <button id="add-exam-btn" class="btn-success"><i class="fas fa-plus"></i> Add New Exam</button>
                            <button id="refresh-exams-btn"><i class="fas fa-sync-alt"></i> Refresh</button>
                            <button id="export-exam-btn" class="btn-secondary" title="Export Exam to PDF"><i class="fas fa-file-pdf"></i> Export Exam</button>
                        </div>
                    </div>
                     <div id="exams-loading" style="display: none; margin: 16px 0; text-align: center;"><i class="fas fa-spinner fa-spin"></i> Loading exams...</div>
                     <div class="data-table-container">
                        <table class="data-table" id="exams-table">
                            <thead>
                                <tr>
                                    <th data-column="0">PIN <span class="sort-icon"></span></th>
                                    <th data-column="1">Course <span class="sort-icon"></span></th>
                                    <th data-column="2">Name <span class="sort-icon"></span></th>
                                    <th data-column="3">Duration <span class="sort-icon"></span></th>
                                    <th data-column="4">Start Date <span class="sort-icon"></span></th>
                                    <th data-column="5">Start Time <span class="sort-icon"></span></th>
                                    <th data-column="6">Mode <span class="sort-icon"></span></th>
                                    <th data-column="7">Shuffle <span class="sort-icon"></span></th>
                                    <th data-column="8" style="min-width: 250px;">Questions Preview</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="exams-table-body"></tbody>
                        </table>
                     </div>
                 </div>
            </div>

            <div id="attempts-module" class="module">
                 <div class="module-content">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px; margin-bottom: 20px;">
                        <h2><i class="fas fa-tasks"></i> View Submissions</h2>
                        <div class="button-group">
                            <button id="refresh-attempts-btn"><i class="fas fa-sync-alt"></i> Refresh</button>
                            <button id="export-submissions-btn" class="btn-secondary" title="Export Submissions to PDF"><i class="fas fa-file-pdf"></i> Export Submissions</button>
                            <button id="export-grades-btn" class="btn-secondary" title="Export Grades to PDF"><i class="fas fa-file-pdf"></i> Export Grades</button>
                       </div>
                    </div>

                    <div class="filter-container">
                         <div class="form-group">
                            <label for="filter-name"><i class="fas fa-user"></i> Filter by Name:</label>
                            <input type="text" id="filter-name" class="form-control attempt-filter-input" placeholder="Enter name...">
                        </div>
                         <div class="form-group">
                            <label for="filter-studentid"><i class="fas fa-id-card"></i> Filter by Student ID:</label>
                            <input type="text" id="filter-studentid" class="form-control attempt-filter-input" placeholder="Enter ID...">
                        </div>
                        <div class="form-group">
                            <label for="filter-pin"><i class="fas fa-key"></i> Filter by PIN:</label>
                            <input type="text" id="filter-pin" class="form-control attempt-filter-input" placeholder="Enter PIN...">
                        </div>
                         <div class="form-group">
                            <label for="filter-course"><i class="fas fa-graduation-cap"></i> Filter by Course:</label>
                            <input type="text" id="filter-course" class="form-control attempt-filter-input" placeholder="Enter course code...">
                        </div>
                    </div>

                    <div id="attempts-loading" style="display: none; margin: 16px 0; text-align: center;"><i class="fas fa-spinner fa-spin"></i> Loading attempts...</div>
                    <div class="data-table-container">
                        <table class="data-table" id="attempts-table">
                            <thead>
                                <tr>
                                    <th data-column="0">Timestamp</th>
                                    <th data-column="1">Name</th>
                                    <th data-column="2">Email</th>
                                    <th data-column="3">PIN</th>
                                    <th data-column="4">Course</th>
                                    <th data-column="5">Student ID</th>
                                    <th data-column="6">Status</th>
                                    <th>Answers</th>
                                    <th>Fingerprint</th>
                                    <th>Grade</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="attempts-table-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div> 
        
        <div id="exam-dialog-backdrop" class="dialog-backdrop">
            <div id="exam-dialog" class="dialog">
                <div class="dialog-header">
                     <h3 id="exam-dialog-title" class="dialog-title">Add New Exam</h3>
                </div>
                <div class="dialog-content">
                    <form id="exam-form">
                        <input type="hidden" id="exam-row-index" value="">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 24px;">
                            <div class="form-group"> 
                                <label for="exam-pin"><i class="fas fa-key"></i> Exam PIN:</label> 
                                <input type="text" id="exam-pin" class="form-control" required> 
                            </div>
                            <div class="form-group"> 
                                <label for="exam-code"><i class="fas fa-graduation-cap"></i> Course Code:</label> 
                                <input type="text" id="exam-code" class="form-control" required> 
                            </div>
                            <div class="form-group"> 
                                <label for="exam-name"><i class="fas fa-file-alt"></i> Exam Name:</label> 
                                <input type="text" id="exam-name" class="form-control" required> 
                            </div>
                            <div class="form-group"> 
                                <label for="exam-duration"><i class="fas fa-clock"></i> Duration (min):</label> 
                                <input type="number" id="exam-duration" class="form-control" required min="1"> 
                            </div>
                            <div class="form-group"> 
                                <label for="exam-start-date"><i class="fas fa-calendar"></i> Available Date:</label> 
                                <input type="date" id="exam-start-date" class="form-control" required> 
                            </div>
                            <div class="form-group"> 
                                <label for="exam-start-time"><i class="fas fa-clock"></i> Available Time (HH:MM):</label> 
                                <input type="time" id="exam-start-time" class="form-control" required> 
                            </div>
                            <div class="form-group"> 
                                <label for="exam-mode"><i class="fas fa-cog"></i> Mode:</label> 
                                <select id="exam-mode" class="form-control" required> 
                                    <option value="Quiz">Quiz</option> 
                                    <option value="Exam">Exam (Requires Student ID)</option> 
                                </select> 
                            </div>
                            <div class="form-group">
                                <label for="exam-shuffle"><i class="fas fa-random"></i> Shuffle Questions:</label>
                                <select id="exam-shuffle" class="form-control" required>
                                    <option value="yes">Yes - Randomize question order</option>
                                    <option value="no">No - Keep fixed question order</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label style="font-weight: 600; font-size: 1.1em;"><i class="fas fa-question-circle"></i> Questions:</label>
                            <div id="questions-builder" style="border: 1px solid var(--border); border-radius: var(--border-radius); padding: 20px; margin-top: 8px; background-color: var(--neutral-50);">
                                <p style="text-align: center; color: #777;">No questions added yet.</p>
                            </div>
                            <div class="add-question-btn-container" style="margin-top: 12px; text-align: center;">
                                 <button type="button" id="add-question-btn" class="btn-secondary"><i class="fas fa-plus"></i> Add Question</button>
                            </div>
                        </div>
                    </form>
                </div>
                 <div class="dialog-actions">
                    <button type="button" id="cancel-exam-dialog-btn" class="btn-secondary">Cancel</button>
                    <button type="button" id="save-exam-dialog-btn" class="btn-success">Save Exam</button>
                </div>
            </div>
        </div>

        <div id="grading-dialog-backdrop" class="dialog-backdrop">
            <div id="grading-dialog" class="dialog">
                 <div class="dialog-header">
                    <h3 id="grading-dialog-title" class="dialog-title">Grade Submission</h3>
                 </div>
                <div class="dialog-content">
                     <div id="grading-student-info" class="form-group" style="background-color: var(--primary-50); padding: 16px; border-radius: var(--border-radius); margin-bottom: 20px; border-left: 4px solid var(--primary-500);">
                        <p style="margin: 4px 0;"><strong>Student:</strong> <span id="grading-student-name"></span> (<span id="grading-student-email"></span>)</p>
                        <p style="margin: 4px 0;"><strong>Exam:</strong> <span id="grading-exam-name"></span> (PIN: <span id="grading-exam-pin"></span>)</p>
                        <p style="margin: 4px 0;"><strong>Submitted:</strong> <span id="grading-timestamp"></span></p>
                    </div>

                     <div class="form-group" style="background-color: var(--neutral-50); padding: 16px; border-radius: var(--border-radius);">
                        <label><strong>Total Score:</strong></label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="number" id="grading-total-score" class="form-control" style="width: 80px;" min="0" step="0.1"> /
                            <span id="grading-max-score">0</span> points
                            (<span id="grading-percentage">0%</span>)
                        </div>
                    </div>

                    <div id="grading-navigator" style="background-color: var(--neutral-100); padding: 12px; border-radius: var(--border-radius); margin: 16px 0; display: flex; justify-content: center; align-items: center; gap: 10px;">
                         <label for="question-jump" style="font-weight: 500; margin-bottom: 0;">Jump to Question:</label>
                         <select id="question-jump" style="min-width: 200px; padding: 8px; border-radius: var(--border-radius); border: 1px solid var(--border);">
                              <option value="">-- Select Question --</option>
                         </select>
                    </div>

                    <div id="grading-questions-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(450px, 1fr)); gap: 20px; margin-bottom: 20px;">
                        <p style="text-align: center; color: var(--text-tertiary); grid-column: 1/-1; padding: 20px;">Loading questions and answers...</p>
                    </div>

                    <div class="form-group">
                        <label for="grading-feedback"><i class="fas fa-comment"></i> Feedback to Student:</label>
                        <textarea id="grading-feedback" class="form-control" rows="3" placeholder="Add feedback for the student..."></textarea>
                    </div>
                </div>
                <div class="dialog-actions">
                    <button type="button" id="cancel-grading-dialog-btn" class="btn-secondary">Cancel</button>
                    <button type="button" id="run-autograder-btn" class="btn-info">
                        <i class="fas fa-magic"></i> Run Autograder
                    </button>
                    <button type="button" id="save-grading-dialog-btn" class="btn-success">Save Grades</button>
                </div>
            </div>
        </div>

        <div id="content-popup-backdrop" class="dialog-backdrop">
          <div id="content-popup" class="dialog">
             <div class="dialog-header">
                 <h3 id="content-popup-title" class="dialog-title">Content Details</h3>
             </div>
            <div id="content-popup-content" class="dialog-content formatted-content">
                </div>
            <div class="dialog-actions">
              <button type="button" id="close-content-popup-btn" class="btn-secondary">Close</button>
            </div>
          </div>
        </div>

        <div id="in-page-notification-area" class="in-page-notifications"></div>

        <footer class="footer"><p><i class="far fa-copyright"></i> 2023-<span id="currentYear"></span> Exam Admin Portal.</p></footer>

    </div> 
    
    <script>
        // === Configuration ===
        const ADMIN_EMAIL = 'bplaku@epoka.edu.al';
        const CLIENT_ID = '740588046540-npg0crodtcuinveu6bua9rd6c3hb2s1m.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyD295FTtMHvXxZablRf0f-FR-IQ2dQRPQE';
        const EXAM_SPREADSHEET_ID = '14SgW9V3ZLYDqqoAutkvHEuLvcogpJ2hMEj_qj72wmEw';
        const EXAM_DETAILS_SHEET_NAME = 'Exams'; // Column H = Questions JSON
        const EXAM_ATTEMPTS_SHEET_NAME = 'Attempts'; // Column H = Answers JSON, I = Fingerprint JSON, J = Grades JSON
        const DISCOVERY_DOCS = ["https://sheets.googleapis.com/$discovery/rest?version=v4"];
        const SCOPES = "https://www.googleapis.com/auth/spreadsheets https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile";
		const examShuffleInput = document.getElementById('exam-shuffle');

        // === App State ===
        let isAdminAllowed = false; let isSignedIn = false; let currentUser = null;
        let tokenClient = null; let gapiLoaded = false; let gsiLoaded = false;
        let isOnline = navigator.onLine; let isSyncing = false;
        let currentSortColumn = { table: null, index: -1, ascending: true };
        let allExamsData = []; // Cache for exams: { data: rowArray, originalIndex: number }
        let allAttemptsData = []; // Cache for attempts: { data: rowArray, originalIndex: number }

        // Grading State
		let currentExamQuestions = null;
		let currentSubmissionAnswers = null;
		let currentGradeSheetRow = null;

        // === DOM Elements === (Get references)
        const mainContainer = document.getElementById('main-container');
        const loginContainer = document.getElementById('login-container');
        const userContainer = document.getElementById('user-container');
        const userName = document.getElementById('user-name');
        const userAvatar = document.getElementById('user-avatar');
        const adminSigninBtn = document.getElementById('admin-signin-btn');
        const adminSignoutBtn = document.getElementById('admin-signout-btn');
        const notificationArea = document.getElementById('in-page-notification-area');
        const signinPromptModule = document.getElementById('signin-prompt-module');
        const accessDeniedModule = document.getElementById('access-denied-module');
        const deniedUserEmail = document.getElementById('denied-user-email');
        const adminDashboardModule = document.getElementById('admin-dashboard-module');
        const adminHeader = document.getElementById('admin-header');
        // Exams
        const addExamBtn = document.getElementById('add-exam-btn');
        const refreshExamsBtn = document.getElementById('refresh-exams-btn');
        const examsLoading = document.getElementById('exams-loading');
        const examsTable = document.getElementById('exams-table');
        const examsTableBody = document.getElementById('exams-table-body');
        // Attempts
        const refreshAttemptsBtn = document.getElementById('refresh-attempts-btn');
        const attemptsLoading = document.getElementById('attempts-loading');
        const attemptsTable = document.getElementById('attempts-table');
        const attemptsTableBody = document.getElementById('attempts-table-body');
        const filterNameInput = document.getElementById('filter-name');
        const filterStudentIdInput = document.getElementById('filter-studentid');
        const filterPinInput = document.getElementById('filter-pin');
        const filterCourseInput = document.getElementById('filter-course');
        // Exam Dialog
        const examDialogBackdrop = document.getElementById('exam-dialog-backdrop');
        const examDialog = document.getElementById('exam-dialog');
        const examDialogTitle = document.getElementById('exam-dialog-title');
        const examForm = document.getElementById('exam-form');
        const cancelExamDialogBtn = document.getElementById('cancel-exam-dialog-btn');
        const saveExamDialogBtn = document.getElementById('save-exam-dialog-btn');
        const examRowIndexInput = document.getElementById('exam-row-index');
        const examPinInput = document.getElementById('exam-pin');
        const examCodeInput = document.getElementById('exam-code');
        const examNameInput = document.getElementById('exam-name');
        const examDurationInput = document.getElementById('exam-duration');
        const examStartDateInput = document.getElementById('exam-start-date');
        const examStartTimeInput = document.getElementById('exam-start-time');
        const examModeInput = document.getElementById('exam-mode');
        const questionsBuilderDiv = document.getElementById('questions-builder');
        const addQuestionBtn = document.getElementById('add-question-btn');
        // Grading Dialog
        const gradingDialogBackdrop = document.getElementById('grading-dialog-backdrop');
        const gradingDialog = document.getElementById('grading-dialog');
        const gradingDialogTitle = document.getElementById('grading-dialog-title');
        const gradingStudentName = document.getElementById('grading-student-name');
        const gradingStudentEmail = document.getElementById('grading-student-email');
        const gradingExamName = document.getElementById('grading-exam-name');
        const gradingExamPin = document.getElementById('grading-exam-pin');
        const gradingTimestamp = document.getElementById('grading-timestamp');
        const gradingTotalScoreInput = document.getElementById('grading-total-score');
        const gradingMaxScoreSpan = document.getElementById('grading-max-score');
        const gradingPercentageSpan = document.getElementById('grading-percentage');
        const gradingNavigatorSelect = document.getElementById('question-jump'); // Navigator dropdown
        const gradingQuestionsContainer = document.getElementById('grading-questions-container');
        const gradingFeedbackInput = document.getElementById('grading-feedback');
        const cancelGradingDialogBtn = document.getElementById('cancel-grading-dialog-btn');
        const runAutograderBtn = document.getElementById('run-autograder-btn');
        const saveGradingDialogBtn = document.getElementById('save-grading-dialog-btn');
        // Content Popup
        const contentPopupBackdrop = document.getElementById('content-popup-backdrop');
        const contentPopup = document.getElementById('content-popup');
        const contentPopupTitle = document.getElementById('content-popup-title');
        const contentPopupContent = document.getElementById('content-popup-content');
        const closeContentPopupBtn = document.getElementById('close-content-popup-btn');


        // === Initialisation ===
        window.addEventListener('load', initAdmin);

        function initAdmin() {
            console.log("Initialising Admin Portal...");
            document.body.classList.remove('content-hidden');
            mainContainer.classList.add('content-visible');
            updateYear();
            setupEventListeners();
            updateOnlineStatus();
            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);
            checkApiLoads();
        }

        function checkApiLoads() {
             if (typeof gapi !== 'undefined' && !gapiLoaded) {
                 gapiLoaded = true;
                 gapi.load('client', initializeGapiClient);
             }
             if (typeof google !== 'undefined' && !gsiLoaded) {
                 gsiLoaded = true;
                 initializeGsiClient();
             }
             if (!gapiLoaded || !gsiLoaded) {
                 setTimeout(checkApiLoads, 100);
             } else {
                 console.log("Google API client and GSI scripts loaded.");
             }
        }

        function setupEventListeners() {
            // Auth
            adminSigninBtn?.addEventListener('click', handleAuthClick);
            adminSignoutBtn?.addEventListener('click', handleAdminSignoutClick);
            // Exams
            addExamBtn?.addEventListener('click', showAddExamDialog);
            refreshExamsBtn?.addEventListener('click', loadExamsData);
            examsTableBody?.addEventListener('click', handleExamsTableActions);
            // Attempts
            refreshAttemptsBtn?.addEventListener('click', loadAttemptsData);
            attemptsTableBody?.addEventListener('click', handleAttemptsTableActions);
            // Attempt Filters
            document.querySelectorAll('.attempt-filter-input').forEach(input => {
                 input.addEventListener('input', filterAttemptsTable);
            });
            // Exam Dialog
            cancelExamDialogBtn?.addEventListener('click', closeExamDialog);
            saveExamDialogBtn?.addEventListener('click', handleSaveExam);
            addQuestionBtn?.addEventListener('click', addQuestionBlock);
            questionsBuilderDiv?.addEventListener('change', handleQuestionTypeChange);
            questionsBuilderDiv?.addEventListener('click', handleRemoveQuestion);
            // Grading Dialog
            cancelGradingDialogBtn?.addEventListener('click', closeGradingDialog);
            runAutograderBtn?.addEventListener('click', runAutograder);
            saveGradingDialogBtn?.addEventListener('click', saveGrades);
            gradingTotalScoreInput?.addEventListener('input', updateGradePercentage);
            gradingNavigatorSelect?.addEventListener('change', handleGradeNavigate); // Navigator event
            // Content Popup
            closeContentPopupBtn?.addEventListener('click', closeContentPopup);
            // Table sorting
            document.querySelectorAll('.data-table thead th[data-column]').forEach(th => {
                th.addEventListener('click', () => handleSortTable(th));
            });
            
            // NEW: PDF Export functionality
            document.getElementById('export-exam-btn')?.addEventListener('click', exportExamToPDF);
            document.getElementById('export-submissions-btn')?.addEventListener('click', exportSubmissionsToPDF);
            document.getElementById('export-grades-btn')?.addEventListener('click', exportGradesToPDF);
        }

        function updateYear() {
            const el = document.getElementById('currentYear');
            if (el) el.textContent = new Date().getFullYear();
        }

        // === Google API & Auth === (Largely unchanged, ensure correct scopes/keys)
        async function initializeGapiClient() {
             console.log("Initialising GAPI client...");
             try {
                 await gapi.client.init({ apiKey: API_KEY, discoveryDocs: DISCOVERY_DOCS });
                 console.log("GAPI client initialised.");
                 checkAuthStatus();
             } catch (error) { handleApiInitError(error, "GAPI Client Init"); }
         }
        function initializeGsiClient() {
            console.log("Initialising GSI client...");
            try {
                tokenClient = google.accounts.oauth2.initTokenClient({ client_id: CLIENT_ID, scope: SCOPES, callback: handleTokenResponse });
                console.log("GSI client initialised.");
            } catch (error) { handleApiInitError(error, "GSI Client Init"); }
        }
        function handleApiInitError(error, context = "API Init") { console.error(`${context} Error:`, error); showImprovedNotification('error', `${context} Error`, `Failed to initialise Google services: ${error.message || 'Unknown error'}. Please refresh.`); updateAdminAuthUI(); }
        function checkAuthStatus() { const savedToken = localStorage.getItem('gapi_admin_token'); if (savedToken) { try { const token = JSON.parse(savedToken); if (token?.access_token) { console.log("Using stored token."); gapi.client.setToken(token); handleAdminSignIn(token); } else { throw new Error('Invalid token'); } } catch(e) { console.warn("Removing invalid stored token.", e); localStorage.removeItem('gapi_admin_token'); updateAdminAuthUI(); } } else { console.log("No stored token found."); updateAdminAuthUI(); } }
        function handleAuthClick() { if (tokenClient) { tokenClient.requestAccessToken({ prompt: 'select_account' }); } else { console.error('Token client not initialised.'); showImprovedNotification('error', 'Auth Error', 'Auth service not ready.'); } }
        function handleTokenResponse(resp) { if (resp.error) { console.error('Token response error:', resp); let msg = `Failed: ${resp.error}`; if (resp.error === 'popup_closed_by_user') msg = 'Sign-in cancelled.'; if (resp.error === 'access_denied') msg = 'Permission denied.'; showImprovedNotification('error', 'Auth Error', msg); handleAdminSignoutLogic(); return; } console.log('Token received.'); localStorage.setItem('gapi_admin_token', JSON.stringify(resp)); gapi.client.setToken(resp); handleAdminSignIn(resp); }
        async function handleAdminSignIn(token) { if (!gapi.client) { console.error("GAPI client not ready."); return; } await fetchUserInfo(); isAdminAllowed = false; if (currentUser?.email?.toLowerCase() === ADMIN_EMAIL.toLowerCase()) { console.log(`Admin access GRANTED for ${currentUser.email}`); isAdminAllowed = true; isSignedIn = true; console.log("Admin logged in, auto-loading data..."); loadExamsData(); loadAttemptsData(); } else if (currentUser) { console.warn(`Access DENIED for user: ${currentUser.email}`); isAdminAllowed = false; isSignedIn = true; if (deniedUserEmail) deniedUserEmail.textContent = currentUser.email; } else { console.error("Failed to fetch user info."); isAdminAllowed = false; isSignedIn = false; } updateAdminAuthUI(); }
        async function fetchUserInfo() { const accessToken = gapi.client?.getToken()?.access_token; if (!accessToken) { currentUser = null; return; } console.log('Fetching user info...'); try { const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', { headers: { 'Authorization': `Bearer ${accessToken}` } }); if (!response.ok) { if (response.status === 401) { console.warn("User Info fetch failed (401). Signing out."); handleAdminSignoutLogic(); return; } throw new Error(`(${response.status}) ${await response.text()}`); } const ui = await response.json(); currentUser = { id: ui.sub, name: ui.name || 'N/A', email: ui.email || 'N/A', picture: ui.picture || '' }; console.log('User fetched:', currentUser.email); } catch (e) { console.error('Fetch user info error:', e); showImprovedNotification('error', 'User Info Error', `Could not get user details: ${e.message}.`); currentUser = null; } }
        function handleAdminSignoutClick() { handleAdminSignoutLogic(); showImprovedNotification('info', 'Signed Out', 'You have been signed out.'); }
        function handleAdminSignoutLogic() { const token = gapi.client?.getToken(); if (token?.access_token) { try { google.accounts.oauth2.revoke(token.access_token, () => console.log('Admin token revoked.')); } catch (e) { console.warn("Token revoke error:", e); } gapi.client.setToken(''); } localStorage.removeItem('gapi_admin_token'); isSignedIn = false; isAdminAllowed = false; currentUser = null; allExamsData = []; allAttemptsData = []; updateAdminAuthUI(); clearTableData(); }

        // === UI State === (Unchanged)
        function updateAdminAuthUI() { console.log('Updating Admin Auth UI - SignedIn:', isSignedIn, 'IsAdmin:', isAdminAllowed); if (isSignedIn) { userContainer.style.display = 'flex'; loginContainer.style.display = 'none'; if (userName) userName.textContent = currentUser?.name || 'User'; if (userAvatar) userAvatar.src = currentUser?.picture || ''; if (isAdminAllowed) { signinPromptModule.style.display = 'none'; accessDeniedModule.style.display = 'none'; adminDashboardModule.style.display = 'block'; adminHeader.style.display = 'flex'; refreshExamsBtn.disabled = !isOnline; refreshAttemptsBtn.disabled = !isOnline; addExamBtn.disabled = !isOnline; } else { signinPromptModule.style.display = 'none'; adminDashboardModule.style.display = 'none'; adminHeader.style.display = 'none'; accessDeniedModule.style.display = 'block'; if (deniedUserEmail) deniedUserEmail.textContent = currentUser?.email || 'Unknown User'; } } else { userContainer.style.display = 'none'; loginContainer.style.display = 'block'; signinPromptModule.style.display = 'block'; accessDeniedModule.style.display = 'none'; adminDashboardModule.style.display = 'none'; adminHeader.style.display = 'none'; } }
        function clearTableData() { examsTableBody.innerHTML = ''; attemptsTableBody.innerHTML = ''; allExamsData = []; allAttemptsData = []; currentSortColumn = { table: null, index: -1, ascending: true }; document.querySelectorAll('.sort-icon').forEach(icon => icon.textContent = ''); }

        // === Google Sheets Interaction === (Unchanged - get, append, update, clear)
        async function getSheetData(spreadsheetId, range) { if (!isSignedIn || !gapi?.client?.sheets) { if(!isAdminAllowed && isSignedIn) { showImprovedNotification('error', 'Access Denied', 'Your account cannot access Sheets data.'); } else { showImprovedNotification('error', 'API Error', 'Not signed in or Sheets API not ready.'); } return null; } if (!isOnline) { showImprovedNotification('warning', 'Offline', 'Cannot fetch Sheets data offline.'); return null; } console.log(`Admin fetching data from: ${spreadsheetId}, Range: ${range}`); setSyncing(true); try { const response = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId, range }); console.log(`Admin fetched data for ${range}`); return response.result.values || []; } catch (err) { console.error(`Admin error fetching ${range}:`, err); const errorDetails = err.result?.error; let message = `Could not fetch data: ${errorDetails?.message || err.message}`; if (errorDetails?.status === 'PERMISSION_DENIED') message = 'Permission denied. Ensure admin has access.'; else if (errorDetails?.status === 'NOT_FOUND') message = `Sheet or range not found: ${range}`; showImprovedNotification('error', 'Sheet Read Error', message); return null; } finally { setSyncing(false); } }
        async function appendSheetData(spreadsheetId, sheetName, values) { if (!isAdminAllowed || !isSignedIn || !gapi?.client?.sheets) { showImprovedNotification('error', 'API/Auth Error', 'Not authorized or Sheets API not ready for append.'); return false; } if (!SCOPES.includes("https://www.googleapis.com/auth/spreadsheets")) { console.warn("Write scope missing."); showImprovedNotification('warning', 'Permission Issue', 'Write scope missing for append.'); return false; } if (!isOnline) { showImprovedNotification('warning', 'Offline', 'Cannot append data offline.'); return false; } console.log(`Admin appending to Sheet: ${spreadsheetId}, Sheet: ${sheetName}`); setSyncing(true); try { const response = await gapi.client.sheets.spreadsheets.values.append({ spreadsheetId, range: sheetName, valueInputOption: 'USER_ENTERED', insertDataOption: 'INSERT_ROWS', resource: { values } }); console.log('Append success:', response.result); return true; } catch (err) { console.error(`Error appending to ${sheetName}:`, err); const errDetail = err.result?.error; let message = `Could not save data: ${errDetail?.message || err.message}`; if (errDetail?.status === 'PERMISSION_DENIED') message = 'Permission denied. Ensure admin has editor access.'; showImprovedNotification('error', `Sheet Write Error (${errDetail?.status || 'Unknown'})`, message); return false; } finally { setSyncing(false); } }
        async function updateSheetData(spreadsheetId, range, values) { if (!isAdminAllowed || !isSignedIn || !gapi?.client?.sheets) { showImprovedNotification('error', 'API/Auth Error', 'Not authorized or Sheets API not ready for update.'); return false; } if (!SCOPES.includes("https://www.googleapis.com/auth/spreadsheets")) { console.warn("Write scope missing for update."); showImprovedNotification('warning', 'Permission Issue', 'Write scope missing for update operation.'); return false; } if (!isOnline) { showImprovedNotification('warning', 'Offline', 'Cannot update data while offline.'); return false; } console.log(`Admin updating Sheet: ${spreadsheetId}, Range: ${range}`); setSyncing(true); try { const response = await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId, range, valueInputOption: 'USER_ENTERED', resource: { values } }); console.log('Update success:', response.result); return true; } catch (err) { console.error(`Error updating ${range}:`, err); const errDetail = err.result?.error; let message = `Could not update data: ${errDetail?.message || err.message}`; if (errDetail?.status === 'PERMISSION_DENIED') message = 'Permission denied. Ensure admin has editor access.'; showImprovedNotification('error', `Sheet Write Error (${errDetail?.status || 'Unknown'})`, message); return false; } finally { setSyncing(false); } }
        async function clearSheetRows(spreadsheetId, sheetName, rowIndex, count = 1) { if (!isAdminAllowed || !isSignedIn || !gapi?.client?.sheets) { showImprovedNotification('error', 'API/Auth Error', 'Not authorized or Sheets API not ready for clear.'); return false; } if (!SCOPES.includes("https://www.googleapis.com/auth/spreadsheets")) { console.warn("Write scope missing for clear."); showImprovedNotification('warning', 'Permission Issue', 'Write scope missing for clear operation.'); return false; } if (!isOnline) { showImprovedNotification('warning', 'Offline', 'Cannot clear data while offline.'); return false; } const sheetRowNumber = rowIndex + 1; const rangeToClear = `${sheetName}!A${sheetRowNumber}:${sheetRowNumber + count - 1}`; console.log(`Admin clearing Sheet: ${spreadsheetId}, Range: ${rangeToClear}`); setSyncing(true); try { const response = await gapi.client.sheets.spreadsheets.values.clear({ spreadsheetId, range: rangeToClear }); console.log('Clear success:', response.result); return true; } catch (err) { console.error(`Error clearing ${rangeToClear}:`, err); const errDetail = err.result?.error; let message = `Could not clear data: ${errDetail?.message || err.message}`; if (errDetail?.status === 'PERMISSION_DENIED') message = 'Permission denied. Ensure admin has editor access.'; showImprovedNotification('error', `Sheet Write Error (${errDetail?.status || 'Unknown'})`, message); return false; } finally { setSyncing(false); } }

        // === Admin Data Loading & Display ===
        async function loadExamsData() {
            if (!isAdminAllowed) return;
            console.log("Loading exams data...");
            examsLoading.style.display = 'inline-block';
            refreshExamsBtn.disabled = true;
            examsTableBody.innerHTML = '';
            allExamsData = [];

            const data = await getSheetData(EXAM_SPREADSHEET_ID, `${EXAM_DETAILS_SHEET_NAME}!A:H`);

            examsLoading.style.display = 'none';
            refreshExamsBtn.disabled = !isOnline;

            if (data && data.length > 1) {
                allExamsData = data.slice(1).map((row, index) => ({
                    data: row,
                    originalIndex: index
                }));
                // Apply current sort before populating
                if (currentSortColumn.table === examsTable && currentSortColumn.index !== -1) {
                    allExamsData.sort((a, b) => {
                         const cellA = a.data[currentSortColumn.index]?.trim() || '';
                         const cellB = b.data[currentSortColumn.index]?.trim() || '';
                         return compareCells(cellA, cellB, currentSortColumn.ascending);
                    });
                } else {
                    // Default sort: Course Code, then PIN
                     allExamsData.sort((a, b) => {
                         const codeA = a.data[1] || ''; const codeB = b.data[1] || '';
                         const pinA = a.data[0] || ''; const pinB = b.data[0] || '';
                         const codeCompare = codeA.localeCompare(codeB);
                         return codeCompare !== 0 ? codeCompare : pinA.localeCompare(pinB);
                     });
                }
                populateExamsTable(allExamsData);
                 updateSortIcons(examsTable, currentSortColumn.index, currentSortColumn.ascending);
            } else if (data) {
                examsTableBody.innerHTML = `<tr><td colspan="9">No exams found.</td></tr>`;
            } else {
                examsTableBody.innerHTML = `<tr><td colspan="9">Failed to load exam data. Check permissions or connection.</td></tr>`;
            }
        }

         function populateExamsTable(sortedExamData) {
             if (!sortedExamData || sortedExamData.length === 0) {
                 examsTableBody.innerHTML = `<tr><td colspan="9">No exams found.</td></tr>`;
                 return;
             }
             let currentCourseCode = null;
             let rowsHtml = '';

             sortedExamData.forEach(item => {
                 const row = item.data;
                 const originalIndex = item.originalIndex;
                 const sheetRowNumber = originalIndex + 2;
                 const pin = row[0] || '';
                 const courseCode = row[1] || '';
                 const name = row[2] || '';
                 const duration = row[3] || '';
                 const startDate = row[4] || '';
                 const startTime = row[5] || '';
                 const mode = row[6] || '';
                 const questionsRaw = row[7] || '[]';
                 const shuffleSetting = row[8] || 'yes'; // Display shuffle setting

                 // Add group header if course code changes
                 if (courseCode !== currentCourseCode) {
                     currentCourseCode = courseCode;
                     rowsHtml += `<tr class="group-header"><td colspan="9">Course: ${escapeHtml(currentCourseCode || 'Uncategorized')}</td></tr>`;
                 }

                 // Generate question preview HTML
                 const questionsPreviewHtml = formatQuestionsForPreview(questionsRaw);
				 
				 const shuffleDisplay = shuffleSetting.toLowerCase() === 'yes' ? 
                    '<span class="badge badge-info">Shuffled</span>' : 
                    '<span class="badge badge-secondary">Fixed Order</span>';

                rowsHtml += `<tr data-original-index="${originalIndex}" data-sheet-row="${sheetRowNumber}" data-pin="${escapeHtml(pin)}" data-questions='${escapeHtml(questionsRaw)}'>
                    <td>${escapeHtml(pin)}</td>
                    <td>${escapeHtml(courseCode)}</td>
                    <td>${escapeHtml(name)}</td>
                    <td>${escapeHtml(duration)}</td>
                    <td>${escapeHtml(startDate)}</td>
                    <td>${escapeHtml(startTime)}</td>
                    <td>${escapeHtml(mode)} ${shuffleDisplay}</td>
                    <td class="question-list-cell">${questionsPreviewHtml}</td>
                    <td class="actions-cell">
                        <button type="button" class="btn-sm btn-warning duplicate-exam-btn" title="Duplicate Exam">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button type="button" class="btn-sm btn-secondary edit-exam-btn" title="Edit Exam">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button type="button" class="btn-sm btn-danger delete-exam-btn" title="Delete Exam">
                            <i class="fas fa-trash"></i>
                        </button>
                    </td>
                </tr>`;
            });
             examsTableBody.innerHTML = rowsHtml;
         }

function formatQuestionsForPreview(questionsRaw) {
    let previewHtml = 'N/A';
    try {
        const questions = JSON.parse(questionsRaw);
        if (Array.isArray(questions)) {
            if (questions.length === 0) return '<em>No questions defined.</em>';
            
            // Only show first 3 questions plus a count if there are more
            const displayLimit = 3;
            const displayCount = Math.min(questions.length, displayLimit);
            const remainingCount = questions.length - displayLimit;
            
            previewHtml = `<div class="question-summary-header">${questions.length} question${questions.length !== 1 ? 's' : ''}</div>`;
            
            // Add the first few questions
            previewHtml += questions.slice(0, displayLimit).map((q, index) => {
                // Get a very brief prompt snippet (first 30 chars)
                const promptSnippet = q.prompt ? 
                    (q.prompt.substring(0, 30) + (q.prompt.length > 30 ? '...' : '')) : 
                    'No Prompt';
                
                // Display question type with icon
                let typeIcon = '';
                switch(q.type) {
                    case 'short_answer': typeIcon = '<i class="fas fa-comment-alt"></i>'; break;
                    case 'long_answer': typeIcon = '<i class="fas fa-paragraph"></i>'; break;
                    case 'code': typeIcon = '<i class="fas fa-code"></i>'; break;
                    case 'multiple_select': typeIcon = '<i class="fas fa-list-ul"></i>'; break;
                    case 'attachment': typeIcon = '<i class="fas fa-paperclip"></i>'; break;
                    case 'text_only': typeIcon = '<i class="fas fa-info-circle"></i>'; break;
                    default: typeIcon = '<i class="fas fa-question"></i>';
                }
                
                // Show points if available and not text_only
                const pointsText = q.points && q.type !== 'text_only' ? 
                    `<span class="question-points-badge">${q.points} pts</span>` : '';
                
                return `<div class="question-list-item">
                    <span class="question-type-badge">${typeIcon} ${q.type}</span>
                    ${pointsText}
                    <div class="question-snippet">${escapeHtml(promptSnippet)}</div>
                </div>`;
            }).join('');
            
            // Add a note about additional questions
            if (remainingCount > 0) {
                previewHtml += `<div class="question-list-more">+ ${remainingCount} more question${remainingCount !== 1 ? 's' : ''}...</div>`;
            }
            
            // Add button to view all questions
            previewHtml += `<button type="button" class="btn-sm btn-info view-all-questions-btn" 
                onclick="showQuestionsPopup(this.closest('tr'))">
                <i class="fas fa-eye"></i> View All
            </button>`;
        } else {
            throw new Error("Not an array");
        }
    } catch (e) {
        previewHtml = '<span style="color: red;">Error parsing</span>';
    }
    return previewHtml;
}

function showQuestionsPopup(row) {
    if (!row || !row.dataset.questions) return;

    const questionsRaw = row.dataset.questions;
    let contentHtml = '<div class="full-questions-preview">';

    try {
        const questions = JSON.parse(questionsRaw);
        if (Array.isArray(questions) && questions.length > 0) {
            contentHtml += questions.map((q, index) => {
                let details = `<strong>Type:</strong> ${escapeHtml(q.type || 'N/A')}`;
                if (q.language) details += `, <strong>Lang:</strong> ${escapeHtml(q.language)}`;
                if (q.allowed_types) details += `, <strong>Allowed:</strong> ${escapeHtml(q.allowed_types.join(', '))}`;
                if (q.max_size_mb) details += `, <strong>Max MB:</strong> ${escapeHtml(q.max_size_mb)}`;
                if (q.points) details += `, <strong>Points:</strong> ${escapeHtml(q.points)}`;

                let optionsHtml = '';
                if (q.type === 'multiple_select' && Array.isArray(q.options)) {
                    optionsHtml += '<ul>';
                    const correctAnswers = Array.isArray(q.correct_answers) ? q.correct_answers : [];
                    optionsHtml += q.options.map(opt => {
                        const isCorrect = correctAnswers.includes(opt);
                        return `<li ${isCorrect ? 'style="font-weight: bold; color: var(--success);"' : ''}>${escapeHtml(opt)}${isCorrect ? ' <i class="fas fa-check" title="Correct Answer"></i>' : ''}</li>`;
                    }).join('');
                    optionsHtml += '</ul>';
                }

                let questionContentHtml = q.content ? `<div class="question-content"><strong>Content:</strong> ${escapeHtml(q.content)}</div>` : '';
				return `<div class="question-detail-item">
					<h4>Question ${index + 1}</h4>
					<div class="question-prompt">${escapeHtml(q.prompt || 'No prompt')}</div>
					<div class="question-meta">${details}</div>
					${questionContentHtml}
					${optionsHtml
					  ? '<div class="question-options"><strong>Options/Answers:</strong>' 
						+ optionsHtml 
						+ '</div>'
					  : ''}
				</div>`;
            }).join('');
        } else {
            contentHtml += '<p>No questions found or invalid format.</p>';
        }
    } catch (e) {
        contentHtml += `<p>Error parsing questions: ${e.message}</p>`;
    }

    contentHtml += '</div>';
    showContentPopup('Exam Questions', contentHtml);
}


        async function loadAttemptsData() {
            if (!isAdminAllowed) return;
            console.log("Loading attempts data...");
            attemptsLoading.style.display = 'inline-block';
            refreshAttemptsBtn.disabled = true;
            attemptsTableBody.innerHTML = '';
            allAttemptsData = []; // Clear cache

            const data = await getSheetData(EXAM_SPREADSHEET_ID, `${EXAM_ATTEMPTS_SHEET_NAME}!A:J`);

            attemptsLoading.style.display = 'none';
            refreshAttemptsBtn.disabled = !isOnline;

            if (data && data.length > 1) {
                 allAttemptsData = data.slice(1).map((row, index) => ({
                     data: row,
                     originalIndex: index
                 }));
                // Apply filters *after* fetching all data
                filterAttemptsTable(); // This will call populateAttemptsTable with filtered data
                resetSortIcon(attemptsTable);
            } else if (data) {
                 allAttemptsData = []; // Ensure cache is empty
                 populateAttemptsTable([]); // Render empty table
                 attemptsTableBody.innerHTML = `<tr><td colspan="11">No attempts found.</td></tr>`;
            } else {
                 allAttemptsData = []; // Ensure cache is empty
                 populateAttemptsTable([]);
                 attemptsTableBody.innerHTML = `<tr><td colspan="11">Failed to load attempts data. Check permissions or connection.</td></tr>`;
            }
        }

        // NEW: Filter attempts table based on input fields
        function filterAttemptsTable() {
            if (!allAttemptsData) return; // Exit if no data loaded

             const filterName = filterNameInput.value.toLowerCase();
             const filterStudentId = filterStudentIdInput.value.toLowerCase();
             const filterPin = filterPinInput.value.toLowerCase();
             const filterCourse = filterCourseInput.value.toLowerCase();

             const filteredData = allAttemptsData.filter(item => {
                 const row = item.data;
                 const name = (row[1] || '').toLowerCase(); // Column B
                 const email = (row[2] || '').toLowerCase(); // Column C (Implicitly part of name filter)
                 const pin = (row[3] || '').toLowerCase(); // Column D
                 const course = (row[4] || '').toLowerCase(); // Column E
                 const studentId = (row[5] || '').toLowerCase(); // Column F

                 const nameMatch = filterName === '' || name.includes(filterName) || email.includes(filterName);
                 const studentIdMatch = filterStudentId === '' || studentId.includes(filterStudentId);
                 const pinMatch = filterPin === '' || pin.includes(filterPin);
                 const courseMatch = filterCourse === '' || course.includes(filterCourse);

                 return nameMatch && studentIdMatch && pinMatch && courseMatch;
             });

             // Apply current sort to filtered data before populating
             if (currentSortColumn.table === attemptsTable && currentSortColumn.index !== -1) {
                 filteredData.sort((a, b) => {
                      const cellA = a.data[currentSortColumn.index]?.trim() || '';
                      const cellB = b.data[currentSortColumn.index]?.trim() || '';
                      return compareCells(cellA, cellB, currentSortColumn.ascending);
                 });
             } // No default sort needed here as it's based on user interaction

             populateAttemptsTable(filteredData); // Populate table with filtered (and potentially sorted) data
             updateSortIcons(attemptsTable, currentSortColumn.index, currentSortColumn.ascending);
        }


        // MODIFIED: populateAttemptsTable now takes filtered data
        function populateAttemptsTable(filteredAttemptData) {
             if (!filteredAttemptData || filteredAttemptData.length === 0) {
                 attemptsTableBody.innerHTML = `<tr><td colspan="11">No attempts match the current filters.</td></tr>`;
                 return;
             }
             const rowsHtml = filteredAttemptData.map(item => { // Use the passed filtered data
                 const row = item.data;
                 const originalIndex = item.originalIndex; // Keep original index if needed
                 const sheetRowNumber = originalIndex + 2;

                 const timestamp = row[0] || '';
                 const studentName = row[1] || '';
                 const email = row[2] || '';
                 const pin = row[3] || '';
                 const courseCode = row[4] || '';
                 const studentId = row[5] || '';
                 const status = row[6] || '';
                 const answersRaw = row[7] || '{}';
                 const fingerprintRaw = row[8] || '{}';
                 const gradesJson = row[9] || '';

                 let gradeSummary = '';
                 if (gradesJson) { /* ... grade parsing ... */
                    try {
                         const grades = JSON.parse(gradesJson);
                         const score = grades.totalScore ?? '?';
                         const max = grades.maxScore ?? '?';
                         const perc = grades.percentage ?? '?%';
                         gradeSummary = `<strong>${score}/${max}</strong> (${perc})`;
                     } catch (e) { gradeSummary = '<span style="color:red;">Error</span>'; }
                 }

                 let statusBadge = '';
                 const lowerStatus = status.toLowerCase();
                 if (lowerStatus === 'submit') statusBadge = `<span class="badge badge-info">Submitted</span>`;
                 else if (lowerStatus === 'graded') statusBadge = `<span class="badge badge-success">Graded</span>`;

                 const escapedAnswers = escapeHtmlAttribute(answersRaw);
                 const escapedFingerprint = escapeHtmlAttribute(fingerprintRaw);
                 const escapedGrades = escapeHtmlAttribute(gradesJson);

                 return `<tr data-sheet-row="${sheetRowNumber}"
                             data-key="${escapeHtml(timestamp)}-${escapeHtml(email)}-${escapeHtml(pin)}"
                             data-answers='${escapedAnswers}'
                             data-fingerprint='${escapedFingerprint}'
                             data-grades='${escapedGrades}'
                             data-pin='${escapeHtml(pin)}'
                             data-name='${escapeHtml(studentName)}'
                             data-email='${escapeHtml(email)}'
                             data-timestamp='${escapeHtml(timestamp)}'>
                     <td>${escapeHtml(timestamp)}</td>
                     <td>${escapeHtml(studentName)}</td>
                     <td>${escapeHtml(email)}</td>
                     <td>${escapeHtml(pin)}</td>
                     <td>${escapeHtml(courseCode)}</td>
                     <td>${escapeHtml(studentId)}</td>
                     <td>${statusBadge || escapeHtml(status)}</td>
                     <td><button type="button" class="btn-sm btn-info" onclick="showAnswersPopup(this.closest('tr'))"><i class="fas fa-list-alt"></i> View</button></td>
                     <td><button type="button" class="btn-sm btn-info" onclick="showFingerprintPopup(this.closest('tr'))"><i class="fas fa-fingerprint"></i> View</button></td>
                     <td>${gradeSummary || 'Not graded'}</td>
                     <td class="actions-cell">
                         <button type="button" class="btn-sm btn-secondary grade-attempt-btn" title="Grade/View Submission"><i class="${lowerStatus === 'graded' ? 'fas fa-edit' : 'fas fa-check-square'}"></i></button>
                         <button type="button" class="btn-sm btn-danger delete-attempt-btn" title="Delete Attempt"><i class="fas fa-trash"></i></button>
                     </td>
                 </tr>`;
             }).join('');
             attemptsTableBody.innerHTML = rowsHtml;
         }

        // === UI Updates === (Unchanged)
        function updateOnlineStatus() { isOnline = navigator.onLine; console.log('Admin Connection:', isOnline ? 'Online' : 'Offline'); if (!isOnline) { showImprovedNotification('warning', 'Offline', 'Functionality requiring connection is disabled.', 5000); } const buttonsDisabled = !isOnline || !isAdminAllowed; refreshExamsBtn.disabled = buttonsDisabled; refreshAttemptsBtn.disabled = buttonsDisabled; addExamBtn.disabled = buttonsDisabled; saveExamDialogBtn.disabled = buttonsDisabled; saveGradingDialogBtn.disabled = buttonsDisabled; }
        function setSyncing(syncing) { isSyncing = syncing; console.log("Admin Syncing:", isSyncing); const loadingDisplayStyle = syncing ? 'inline-block' : 'none'; examsLoading.style.display = loadingDisplayStyle; attemptsLoading.style.display = loadingDisplayStyle; const buttonsDisabled = syncing || !isOnline || !isAdminAllowed; refreshExamsBtn.disabled = buttonsDisabled; refreshAttemptsBtn.disabled = buttonsDisabled; addExamBtn.disabled = buttonsDisabled; saveExamDialogBtn.disabled = buttonsDisabled; saveGradingDialogBtn.disabled = buttonsDisabled; }
        function showImprovedNotification(type, title, message, duration = 5000) { const container = notificationArea; if (!container) { return; } const notification = document.createElement('div'); notification.className = `in-page-notification in-page-notification-${type}`; let iconClass; switch (type) { case 'success': iconClass = 'fa-check-circle'; break; case 'error': iconClass = 'fa-times-circle'; break; case 'warning': iconClass = 'fa-exclamation-triangle'; break; default: iconClass = 'fa-info-circle'; } notification.innerHTML = `<i class="fas ${iconClass} fa-icon"></i><div class="notification-content"><strong>${escapeHtml(title)}</strong><br>${escapeHtml(message).replace(/\n/g, '<br>')}</div><button type="button" class="notification-close" aria-label="Close">&times;</button>`; container.appendChild(notification); const closeBtn = notification.querySelector('.notification-close'); const removeNotification = () => { notification.classList.add('removing'); setTimeout(() => { try { notification.parentNode?.removeChild(notification); } catch(e){} }, 300); }; closeBtn?.addEventListener('click', (e) => { e.stopPropagation(); removeNotification(); }); if (duration > 0) setTimeout(removeNotification, duration); }

        // === Utility Functions ===
        function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return unsafe; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
        function escapeHtmlAttribute(unsafe) { if (typeof unsafe !== 'string') return unsafe; return unsafe.replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }
        // UPDATED: formatJsonForDisplay to handle potential parsing errors better
        function formatJsonForDisplay(jsonString) {
             if (!jsonString || jsonString.trim() === '{}' || jsonString.trim() === '') return 'N/A';
             try {
                 // Attempt to parse the JSON
                 const data = JSON.parse(jsonString);
                 if (typeof data !== 'object' || data === null || Object.keys(data).length === 0) return 'N/A';

                 let html = '<dl>';
                 for (const key in data) {
                     if (Object.hasOwnProperty.call(data, key)) {
                         const value = data[key];
                         html += `<dt>${escapeHtml(key)}:</dt>`;
                         let valueDisplay = '';
                         if (value === null || typeof value === 'undefined') {
                             valueDisplay = '<em>null/undefined</em>';
                         } else if (typeof value === 'object') {
                             try { valueDisplay = `<pre>${escapeHtml(JSON.stringify(value, null, 2))}</pre>`; }
                             catch (nestedError) { valueDisplay = escapeHtml(String(value)); }
                         } else {
                             valueDisplay = escapeHtml(String(value)).replace(/\n/g, '<br>');
                         }
                         html += `<dd>${valueDisplay || '<em>empty</em>'}</dd>`;
                     }
                 }
                 html += '</dl>';
                 return html;
             } catch (e) {
                 // If parsing fails, display the original string, escaped, inside a <pre> tag
                 console.warn("Failed to parse JSON for display, showing raw data:", jsonString, e);
                 // Add error message for clarity
                 return `<div style="color: red; font-weight: bold; margin-bottom: 5px;">Error parsing data: ${escapeHtml(e.message)}</div><pre>${escapeHtml(jsonString)}</pre>`;
             }
         }
         // NEW: formatQuestionsForDisplay function (ensure it exists)
function formatQuestionsForDisplay(questionsRaw) {
    let qHtml = 'N/A';
    try {
        const qArray = JSON.parse(questionsRaw);
        if (Array.isArray(qArray)) {
            if (qArray.length === 0) {
                return '<em>No questions defined.</em>';
            }
            qHtml = qArray.map((q, index) => {
                let details = `<strong>Type:</strong> ${escapeHtml(q.type || 'N/A')}`;
                if (q.language) {
                    details += `, <strong>Lang:</strong> ${escapeHtml(q.language)}`;
                }
                if (q.allowed_types) {
                    details += `, <strong>Allowed:</strong> ${escapeHtml(q.allowed_types.join(', '))}`;
                }
                if (q.max_size_mb) {
                    details += `, <strong>Max MB:</strong> ${escapeHtml(q.max_size_mb)}`;
                }
                if (q.points) {
                    details += `, <strong>Points:</strong> ${escapeHtml(q.points)}`;
                }

                let optionsHtml = '';
                if (q.type === 'multiple_select' && Array.isArray(q.options)) {
                    optionsHtml += '<ul>';
                    const correctAnswers = Array.isArray(q.correct_answers) ? q.correct_answers : [];
                    optionsHtml += q.options.map(opt => {
                        const isCorrect = correctAnswers.includes(opt);
                        return `<li${isCorrect ? ' style="font-weight: bold; color: var(--success);"' : ''}>` +
                               `${escapeHtml(opt)}` +
                               `${isCorrect ? ' <i class="fas fa-check" title="Correct Answer"></i>' : ''}` +
                               `</li>`;
                    }).join('');
                    optionsHtml += '</ul>';
                }

                let contentHtml = q.content
                    ? `<dd><strong>Content:</strong> ${escapeHtml(q.content)}</dd>`
                    : '';

                return `<div class="question-item">
    <dl>
        <dt>${index + 1}. ${escapeHtml(q.prompt || 'Q')}</dt>
        <dd><i>${details}</i></dd>
        ${contentHtml}
        ${optionsHtml
            ? '<dd><strong>Options/Answers:</strong>' + optionsHtml + '</dd>'
            : ''}
    </dl>
</div>`;
            }).join('');
        } else {
            throw new Error('Not an array');
        }
    } catch (e) {
        console.warn('Error parsing questions JSON for display:', questionsRaw, e);
        qHtml = '<div style="color: red; font-weight: bold;">' +
                'Error parsing questions: ' + escapeHtml(e.message) +
                '</div><pre>' + escapeHtml(questionsRaw) + '</pre>';
    }
    return qHtml || '<em>Error or no content.</em>';
}



        // === Table Sorting === (Unchanged compareCells, updateSortIcons, resetSortIcon)
        function handleSortTable(thElement) {
             const table = thElement.closest('table'); if (!table) return;
             const tbody = table.querySelector('tbody'); if (!tbody) return;
             const columnIndex = parseInt(thElement.dataset.column, 10);
             const isExamsTable = table.id === 'exams-table';
             const isAttemptsTable = table.id === 'attempts-table';

             let isAscending = true;
             if (currentSortColumn.table === table && currentSortColumn.index === columnIndex) isAscending = !currentSortColumn.ascending;
             currentSortColumn = { table, index: columnIndex, ascending: isAscending };

             if (isExamsTable && allExamsData.length > 0) {
                 allExamsData.sort((a, b) => compareCells(a.data[columnIndex], b.data[columnIndex], isAscending));
                 populateExamsTable(allExamsData); // Re-render sorted exams with grouping
             } else if (isAttemptsTable && allAttemptsData.length > 0) {
                 filterAttemptsTable(); // Re-apply filters which will also apply sort based on currentSortColumn
             }
             updateSortIcons(table, columnIndex, isAscending);
         }
        function compareCells(cellA, cellB, isAscending) { const valA = (cellA || '').toString().trim(); const valB = (cellB || '').toString().trim(); const numA = parseFloat(valA); const numB = parseFloat(valB); let comparison = 0; if (!isNaN(numA) && !isNaN(numB)) { comparison = numA - numB; } else { comparison = valA.localeCompare(valB, undefined, { numeric: true, sensitivity: 'base' }); } return isAscending ? comparison : -comparison; }
        function updateSortIcons(table, activeColumnIndex, isAscending) { table.querySelectorAll('thead th .sort-icon').forEach((icon, index) => { icon.textContent = (index === activeColumnIndex) ? (isAscending ? ' ▲' : ' ▼') : ''; }); }
        function resetSortIcon(table) { if (!table) return; table.querySelectorAll('thead th .sort-icon').forEach(icon => icon.textContent = ''); }

        // === Dialog and Question Builder Management ===
        function showAddExamDialog() {
            console.log("Showing Add Exam Dialog");
            examForm.reset();
            questionsBuilderDiv.innerHTML = '<p style="text-align: center; color: #777;">No questions added yet.</p>';
            examRowIndexInput.value = ''; // Ensure it's ADD mode
            examDialogTitle.textContent = "Add New Exam";
            saveExamDialogBtn.textContent = "Add Exam";
            saveExamDialogBtn.disabled = !isOnline || !isAdminAllowed;

            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            examStartDateInput.value = `${year}-${month}-${day}`;
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            examStartTimeInput.value = `${hours}:${minutes}`;

            examDialogBackdrop.classList.add('visible');
        }
        function closeExamDialog() { examDialogBackdrop.classList.remove('visible'); }
        // addQuestionBlock - Modified to accept data for editing (see previous thought/code)
		
	function initTooltips() {
    // Get all tooltip elements
    const tooltips = document.querySelectorAll('.help-tooltip');
    
    // Create a single tooltip element to be reused
    const tooltipEl = document.createElement('div');
    tooltipEl.className = 'custom-tooltip';
    tooltipEl.style.position = 'absolute';
    tooltipEl.style.backgroundColor = '#333';
    tooltipEl.style.color = '#fff';
    tooltipEl.style.padding = '5px 10px';
    tooltipEl.style.borderRadius = '4px';
    tooltipEl.style.fontSize = '12px';
    tooltipEl.style.zIndex = '10000';
    tooltipEl.style.pointerEvents = 'none';
    tooltipEl.style.opacity = '0';
    tooltipEl.style.transition = 'opacity 0.3s';
    document.body.appendChild(tooltipEl);
    
    // Add mouse event listeners to each tooltip trigger
    tooltips.forEach(el => {
        const title = el.getAttribute('title') || el.dataset.title || '';
        if (title) {
            // Remove the title attribute to prevent the native tooltip
            el.dataset.title = title;
            el.removeAttribute('title');
            
            // Show cursor as help icon
            el.style.cursor = 'help';
            
            // Show tooltip on mouseenter
            el.addEventListener('mouseenter', e => {
                tooltipEl.textContent = title;
                tooltipEl.style.opacity = '1';
                
                // Position the tooltip
                const rect = el.getBoundingClientRect();
                tooltipEl.style.top = (rect.bottom + 10) + 'px';
                tooltipEl.style.left = (rect.left + (rect.width / 2) - (tooltipEl.offsetWidth / 2)) + 'px';
            });
            
            // Hide tooltip on mouseleave
            el.addEventListener('mouseleave', () => {
                tooltipEl.style.opacity = '0';
            });
        }
    });
    
    console.log('Custom tooltips initialized');
}
		
function addQuestionBlock(questionData = null) {
    const placeholder = questionsBuilderDiv.querySelector('p');
    if (placeholder) placeholder.remove();

    const questionIndex = questionsBuilderDiv.querySelectorAll('.question-block').length;
    const block = document.createElement('div');
    block.className = 'question-block';
    block.dataset.index = questionIndex;

    // Use provided data or defaults
    const type = questionData?.type || 'short_answer';
    const prompt = questionData?.prompt || '';
    const lang = questionData?.language || '';
    const allowedTypes = (questionData?.allowed_types || []).join(',');
    const maxSize = questionData?.max_size_mb || '';
    const options = (questionData?.options || []).join('\n');
    const correct = (questionData?.correct_answers || []).join('\n');
    const points = questionData?.points ?? '';
    const content = questionData?.content || '';

    // HTML for question block, now with text_only option
    block.innerHTML = `
        <div class="question-block-header">
            <span>Question ${questionIndex + 1}</span>
            <div class="question-actions">
                <button type="button" class="btn-sm btn-secondary move-up-btn" title="Move Up">
                    <i class="fas fa-arrow-up"></i>
                </button>
                <button type="button" class="btn-sm btn-secondary move-down-btn" title="Move Down">
                    <i class="fas fa-arrow-down"></i>
                </button>
                <button type="button" class="btn-sm btn-danger remove-question-btn" title="Remove Question">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        </div>

        <div class="question-config-grid">
            <div class="form-group question-type-group">
                <label for="q-type-${questionIndex}">
                    <i class="fas fa-list-alt"></i> Question Type:
                    <span class="help-tooltip" title="Select the type of question to present to students">
                        <i class="fas fa-question-circle"></i>
                    </span>
                </label>
                <select id="q-type-${questionIndex}" class="form-control question-type-select">
                    <option value="short_answer" ${type === 'short_answer' ? 'selected' : ''}>Short Answer</option>
                    <option value="long_answer" ${type === 'long_answer' ? 'selected' : ''}>Long Answer / Instructions</option>
                    <option value="code" ${type === 'code' ? 'selected' : ''}>Code</option>
                    <option value="attachment" ${type === 'attachment' ? 'selected' : ''}>File Upload</option>
                    <option value="multiple_select" ${type === 'multiple_select' ? 'selected' : ''}>Multiple Choice</option>
                    <option value="text_only" ${type === 'text_only' ? 'selected' : ''}>Text Only (No Answer)</option>
                </select>
            </div>

            <div class="form-group question-points-group ${type === 'text_only' ? 'hidden' : ''}">
                <label for="q-points-${questionIndex}">
                    <i class="fas fa-star"></i> Points:
                    <span class="help-tooltip" title="Assign point value for this question">
                        <i class="fas fa-question-circle"></i>
                    </span>
                </label>
                <input type="number"
                       id="q-points-${questionIndex}"
                       class="form-control question-points"
                       min="0" step="0.1"
                       value="${points}"
                       placeholder="1">
            </div>
        </div>

        <div class="form-group question-prompt-group">
            <label for="q-prompt-${questionIndex}">
                <i class="fas fa-question"></i> ${type === 'text_only' ? 'Text Content:' : 'Question Text:'}
                <span class="help-tooltip" title="${type === 'text_only' ? 'The text to display to students' : 'The main question or prompt shown to students'}">
                    <i class="fas fa-question-circle"></i>
                </span>
                <span class="markdown-hint">Supports **bold** with double asterisks</span>
            </label>
            <textarea id="q-prompt-${questionIndex}"
                      class="form-control question-prompt"
                      rows="3"
                      required>${escapeHtml(prompt)}</textarea>
        </div>

        <div class="form-group question-content-group"
             ${type !== 'long_answer' && type !== 'code' ? 'style="display:none;"' : ''}>
            <label for="q-content-${questionIndex}">
                <i class="fas fa-file-alt"></i> Default Content:
                <span class="help-tooltip" title="Initial content to show in the answer box">
                    <i class="fas fa-question-circle"></i>
                </span>
            </label>
            <textarea id="q-content-${questionIndex}"
                      class="form-control question-content"
                      rows="3">${escapeHtml(content)}</textarea>
        </div>

        <div class="conditional-fields-container">
            <div class="conditional-field"
                 data-type="code"
                 ${type === 'code' ? 'style="display:block;"' : ''}>
                <div class="form-group">
                    <label for="q-lang-${questionIndex}">
                        <i class="fas fa-code"></i> Programming Language:
                        <span class="help-tooltip" title="Specify language for syntax highlighting">
                            <i class="fas fa-question-circle"></i>
                        </span>
                    </label>
                    <input type="text"
                           id="q-lang-${questionIndex}"
                           class="form-control question-lang"
                           placeholder="e.g., python"
                           value="${escapeHtml(lang)}">
                </div>
            </div>

            <div class="conditional-field"
                 data-type="attachment"
                 ${type === 'attachment' ? 'style="display:block;"' : ''}>
                <div class="form-group">
                    <label for="q-types-${questionIndex}">
                        <i class="fas fa-file-upload"></i> Allowed File Types:
                        <span class="help-tooltip" title="Comma-separated list of allowed extensions (.pdf,.zip)">
                            <i class="fas fa-question-circle"></i>
                        </span>
                    </label>
                    <input type="text"
                           id="q-types-${questionIndex}"
                           class="form-control question-allowed-types"
                           placeholder="e.g., .pdf,.zip,.jpg"
                           value="${escapeHtml(allowedTypes)}">
                </div>
                <div class="form-group">
                    <label for="q-size-${questionIndex}">
                        <i class="fas fa-weight"></i> Max File Size (MB):
                        <span class="help-tooltip" title="Maximum allowed file size in megabytes">
                            <i class="fas fa-question-circle"></i>
                        </span>
                    </label>
                    <input type="number"
                           id="q-size-${questionIndex}"
                           class="form-control question-max-size"
                           min="1"
                           value="${escapeHtml(maxSize)}">
                </div>
            </div>

            <div class="conditional-field"
                 data-type="multiple_select"
                 ${type === 'multiple_select' ? 'style="display:block;"' : ''}>
                <div class="form-group">
                    <label for="q-options-${questionIndex}">
                        <i class="fas fa-list"></i> Answer Options:
                        <span class="help-tooltip" title="Enter one option per line">
                            <i class="fas fa-question-circle"></i>
                        </span>
                    </label>
                    <textarea id="q-options-${questionIndex}"
                              class="form-control question-options"
                              rows="4"
                              placeholder="Option A&#10;Option B&#10;Option C">${escapeHtml(options)}</textarea>
                </div>
                <div class="form-group">
                    <label for="q-correct-${questionIndex}">
                        <i class="fas fa-check"></i> Correct Answer(s):
                        <span class="help-tooltip" title="Enter the exact text of the correct option(s), one per line">
                            <i class="fas fa-question-circle"></i>
                        </span>
                    </label>
                    <textarea id="q-correct-${questionIndex}"
                              class="form-control question-correct"
                              rows="2"
                              placeholder="Option B">${escapeHtml(correct)}</textarea>
                    <div class="help-text">Enter the exact text of correct option(s), one per line</div>
                </div>
            </div>
        </div>
    `;
    
    questionsBuilderDiv.appendChild(block);
    initTooltips();
	// Hide points field for text_only type
    if (type === 'text_only') {
        const pointsGroup = block.querySelector('.question-points-group');
        if (pointsGroup) pointsGroup.classList.add('hidden');
    }
}

        // handleQuestionTypeChange - Unchanged
        function handleQuestionTypeChange(event) {
    if (!event.target.classList.contains('question-type-select')) return;
    
    const block = event.target.closest('.question-block');
    if (!block) return;
    
    const selectedType = event.target.value;
    
    // Show/hide points field for text_only type
    const pointsGroup = block.querySelector('.question-points-group');
    if (pointsGroup) {
        if (selectedType === 'text_only') {
            pointsGroup.classList.add('hidden');
            const pointsInput = block.querySelector('.question-points');
            if (pointsInput) pointsInput.value = '0'; // Set to 0 for text_only
        } else {
            pointsGroup.classList.remove('hidden');
        }
    }
    
    // Update prompt label
    const promptLabel = block.querySelector('.question-prompt-group label');
    if (promptLabel) {
        const iconSpan = promptLabel.querySelector('i');
        const textNode = promptLabel.childNodes[1]; // Text node after icon
        if (textNode) {
            textNode.nodeValue = selectedType === 'text_only' ? 'Text Content:' : 'Question Text:';
        }
    }
    
    // Show/hide conditional fields
    block.querySelectorAll('.conditional-field').forEach(field => field.style.display = 'none');
    const conditionalField = block.querySelector(`.conditional-field[data-type="${selectedType}"]`);
    if (conditionalField) conditionalField.style.display = 'block';
}
        // handleRemoveQuestion - Unchanged
        function handleRemoveQuestion(event) { if (!event.target.classList.contains('remove-question-btn')) return; const block = event.target.closest('.question-block'); if (block) { block.remove(); questionsBuilderDiv.querySelectorAll('.question-block').forEach((qBlock, index) => { const headerSpan = qBlock.querySelector('.question-block-header span'); if (headerSpan) headerSpan.textContent = `Question ${index + 1}`; }); if (questionsBuilderDiv.children.length === 0) questionsBuilderDiv.innerHTML = '<p style="text-align: center; color: #777;">No questions added yet.</p>'; } }
        // handleSaveExam - Modified to include points (see previous thought/code)
async function handleSaveExam() {
    if (!isAdminAllowed || !isOnline) return;

    // Check required exam fields
    if (
        !examPinInput.value ||
        !examCodeInput.value ||
        !examNameInput.value ||
        !examDurationInput.value ||
        !examStartDateInput.value ||
        !examStartTimeInput.value ||
        !examModeInput.value ||
        !examShuffleInput.value // Add the shuffle option
    ) {
        showImprovedNotification('warning', 'Missing Fields', 'Please fill in all required exam details.');
        return;
    }

    const questionsArray = [];
    const questionBlocks = questionsBuilderDiv.querySelectorAll('.question-block');
    let questionsValid = true;

    questionBlocks.forEach((block, index) => {
        const qNum        = index + 1;
        const typeSelect  = block.querySelector('.question-type-select');
        const promptInput = block.querySelector('.question-prompt');
        const pointsInput = block.querySelector('.question-points');
        const type        = typeSelect.value;
        const prompt      = promptInput.value.trim();

        // Robust parsing of points: allow zero
        let points = null;
        const rawPts = pointsInput.value.trim();
        if (rawPts !== '') {
            const parsed = parseFloat(rawPts);
            if (!Number.isNaN(parsed)) {
                points = parsed;
            }
        }

        // Reset any previous error styling
        promptInput.style.borderColor = '';
        block.querySelectorAll('.question-options, .question-correct')
             .forEach(el => el.style.borderColor = '');

        // Validate prompt
        if (!prompt) {
            questionsValid = false;
            promptInput.style.borderColor = 'red';
            showImprovedNotification('warning', `Validation Error (Q${qNum})`, 'Prompt cannot be empty.');
        }

        // Validate points
        if (points !== null && points < 0) {
            questionsValid = false;
            pointsInput.style.borderColor = 'red';
            showImprovedNotification('warning', `Validation Error (Q${qNum})`, 'Points cannot be negative.');
        }

        // Build question object
        const question = { type, prompt };
        if (points !== null) question.points = points;

        // Type‑specific fields
        if (type === 'code') {
            const lang = block.querySelector('.question-lang').value.trim();
            if (lang) question.language = lang;
        }
        else if (type === 'attachment') {
            const typesStr = block.querySelector('.question-allowed-types').value.trim();
            const sizeStr  = block.querySelector('.question-max-size').value.trim();

            if (typesStr) {
                question.allowed_types = typesStr
                    .split(',')
                    .map(t => t.trim())
                    .filter(t => t);
            }

            if (sizeStr) {
                const sizeNum = parseInt(sizeStr, 10);
                if (!isNaN(sizeNum) && sizeNum > 0) {
                    question.max_size_mb = sizeNum;
                } else {
                    questionsValid = false;
                    block.querySelector('.question-max-size').style.borderColor = 'red';
                    showImprovedNotification(
                        'warning',
                        `Validation Error (Q${qNum})`,
                        'Max size must be a positive number.'
                    );
                }
            }
        }
        else if (type === 'multiple_select') {
            const optionsInput = block.querySelector('.question-options');
            const correctInput = block.querySelector('.question-correct');
            const optionsStr   = optionsInput.value.trim();
            const correctStr   = correctInput.value.trim();

            // Validate options
            if (!optionsStr) {
                questionsValid = false;
                optionsInput.style.borderColor = 'red';
                showImprovedNotification('warning', `Validation Error (Q${qNum})`, 'Options cannot be empty.');
            } else {
                question.options = optionsStr
                    .split('\n')
                    .map(opt => opt.trim())
                    .filter(opt => opt);

                if (question.options.length < 1) {
                    questionsValid = false;
                    optionsInput.style.borderColor = 'red';
                    showImprovedNotification('warning', `Validation Error (Q${qNum})`, 'Needs at least one option.');
                }
            }

            // Validate correct answers
            if (!correctStr) {
                questionsValid = false;
                correctInput.style.borderColor = 'red';
                showImprovedNotification(
                    'warning',
                    `Validation Error (Q${qNum})`,
                    'Correct answer(s) cannot be empty.'
                );
            } else {
                question.correct_answers = correctStr
                    .split('\n')
                    .map(ans => ans.trim())
                    .filter(ans => ans);

                if (question.correct_answers.length === 0) {
                    questionsValid = false;
                    correctInput.style.borderColor = 'red';
                    showImprovedNotification(
                        'warning',
                        `Validation Error (Q${qNum})`,
                        'At least one correct answer required.'
                    );
                }

                if (
                    question.options &&
                    question.correct_answers.length > 0 &&
                    !question.correct_answers.every(ans => question.options.includes(ans))
                ) {
                    questionsValid = false;
                    correctInput.style.borderColor = 'red';
                    showImprovedNotification(
                        'warning',
                        `Validation Error (Q${qNum})`,
                        'Correct answer not found in options.'
                    );
                }
            }
        }

        // If this question passed validation, add it
        if (questionsValid) {
            questionsArray.push(question);
        }
    });

    // If any question failed, abort
    if (!questionsValid) {
        showImprovedNotification('error', 'Validation Failed', 'Please check highlighted fields.');
        return;
    }

    // Prepare and send data
    const questionsJsonString = JSON.stringify(questionsArray);
    const examData = [
        examPinInput.value.trim(),
        examCodeInput.value.trim(),
        examNameInput.value.trim(),
        examDurationInput.value,
        examStartDateInput.value,
        examStartTimeInput.value,
        examModeInput.value,
        questionsJsonString,
        examShuffleInput.value.trim() // Add the shuffle option
    ];

    saveExamDialogBtn.disabled = true;
    saveExamDialogBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';

    let success = false;
    const originalIndexStr = examRowIndexInput.value;

    if (originalIndexStr !== '') {
        const sheetRowToUpdate = parseInt(originalIndexStr, 10) + 2;
        const rangeToUpdate = `${EXAM_DETAILS_SHEET_NAME}!A${sheetRowToUpdate}:I${sheetRowToUpdate}`;
        console.log("UPDATING exam on sheet row:", sheetRowToUpdate);
        success = await updateSheetData(EXAM_SPREADSHEET_ID, rangeToUpdate, [examData]);
    } else {
        console.log("ADDING new exam");
        success = await appendSheetData(EXAM_SPREADSHEET_ID, EXAM_DETAILS_SHEET_NAME, [examData]);
    }

    saveExamDialogBtn.disabled = !isOnline || !isAdminAllowed;
    saveExamDialogBtn.innerHTML = originalIndexStr ? 'Save Changes' : 'Add Exam';

    if (success) {
        showImprovedNotification(
            'success',
            'Exam Saved',
            `Exam "${escapeHtml(examData[2])}" was ${originalIndexStr ? 'updated' : 'added'}.`
        );
        closeExamDialog();
        loadExamsData();
    }
}

        // === Action Button Handlers ===
        function handleExamsTableActions(event) {
             const target = event.target.closest('button'); if (!target) return;
             const row = target.closest('tr'); if (!row) return;
             const originalIndex = parseInt(row.dataset.originalIndex, 10); // Use 0-based index
             const sheetRow = parseInt(row.dataset.sheetRow, 10); // Use 1-based sheet row
             const pin = row.dataset.pin;

             if (target.classList.contains('edit-exam-btn')) editExam(pin, originalIndex);
             else if (target.classList.contains('delete-exam-btn')) deleteExam(pin, sheetRow);
             else if (target.classList.contains('duplicate-exam-btn')) duplicateExam(originalIndex); // Pass original index
         }
        // handleAttemptsTableActions - Unchanged
        function handleAttemptsTableActions(event) { const target = event.target.closest('button'); if (!target) return; const row = target.closest('tr'); if (!row) return; const sheetRow = row.dataset.sheetRow; const key = row.dataset.key; if (target.classList.contains('delete-attempt-btn')) deleteAttempt(key, parseInt(sheetRow, 10)); else if (target.classList.contains('grade-attempt-btn')) openGradingDialog(row); }
        // editExam - Modified to populate points field (see previous thought/code)
async function editExam(pin, originalIndex) {
    if (!isAdminAllowed) return;
    console.log(`Editing exam with PIN: ${pin}, Original Index: ${originalIndex}`);
    const examItem = allExamsData.find(item => item.originalIndex === originalIndex);
    if (!examItem) { 
        showImprovedNotification('error', 'Edit Error', `Could not find data for exam index ${originalIndex}. Please refresh.`); 
        return; 
    }

    const examData = examItem.data;
    examDialogTitle.textContent = `Edit Exam (PIN: ${escapeHtml(examData[0])})`;
    saveExamDialogBtn.textContent = "Save Changes";
    examRowIndexInput.value = originalIndex;
    
    examPinInput.value = examData[0] || '';
    examCodeInput.value = examData[1] || '';
    examNameInput.value = examData[2] || '';
    examDurationInput.value = examData[3] || '';
    examStartDateInput.value = examData[4] || '';
    examStartTimeInput.value = examData[5] || '';
    examModeInput.value = examData[6] || 'Quiz';
    examShuffleInput.value = examData[8] || 'yes'; // Load the shuffle option, default to 'yes'


            questionsBuilderDiv.innerHTML = ''; const questionsRaw = examData[7] || '[]';
            try {
                const questions = JSON.parse(questionsRaw);
                if (Array.isArray(questions) && questions.length > 0) questions.forEach(q => addQuestionBlock(q)); // Pass data to populate
                else if (questions.length === 0) questionsBuilderDiv.innerHTML = '<p style="text-align: center; color: #777;">No questions defined.</p>';
                else throw new Error("Questions data not an array.");
            } catch (e) { console.error("Error parsing/populating questions for edit:", e); questionsBuilderDiv.innerHTML = `<p style="color: red; text-align: center;">Error loading questions: ${e.message}</p>`; showImprovedNotification('error', 'Question Load Error', `Could not parse questions: ${e.message}`); }

            saveExamDialogBtn.disabled = !isOnline || !isAdminAllowed; examDialogBackdrop.classList.add('visible');
        }
        // deleteExam - Unchanged
        async function deleteExam(pin, sheetRow) { if (!isAdminAllowed) return; if (confirm(`Are you sure you want to clear Exam row ${sheetRow} (PIN: ${pin})?`)) { const success = await clearSheetRows(EXAM_SPREADSHEET_ID, EXAM_DETAILS_SHEET_NAME, sheetRow - 1, 1); if (success) { showImprovedNotification('success', 'Exam Cleared', `Exam row ${sheetRow} content cleared.`); loadExamsData(); } } }
        // deleteAttempt - Unchanged
        async function deleteAttempt(key, sheetRow) { if (!isAdminAllowed) return; if (confirm(`Are you sure you want to clear Attempt row ${sheetRow}?`)) { const success = await clearSheetRows(EXAM_SPREADSHEET_ID, EXAM_ATTEMPTS_SHEET_NAME, sheetRow - 1, 1); if (success) { showImprovedNotification('success', 'Attempt Cleared', `Attempt row ${sheetRow} content cleared.`); loadAttemptsData(); } } }

        // NEW: Duplicate Exam Function
        function duplicateExam(originalIndex) {
             if (!isAdminAllowed) return;
             console.log(`Duplicating exam from Original Index: ${originalIndex}`);

             const examItem = allExamsData.find(item => item.originalIndex === originalIndex);
             if (!examItem) { showImprovedNotification('error', 'Duplicate Error', `Could not find data for exam index ${originalIndex}. Please refresh.`); return; }

             const examData = examItem.data;
             // Show Add dialog, pre-filled
             showAddExamDialog(); // Reset and show dialog first

             examDialogTitle.textContent = "Duplicate Exam";
             saveExamDialogBtn.textContent = "Add Duplicated Exam";
             examRowIndexInput.value = ''; // Ensure it saves as NEW

             // Pre-fill fields from original exam data
             examPinInput.value = (examData[0] || '') + '-COPY'; // Suggest new PIN
             examCodeInput.value = examData[1] || '';
             examNameInput.value = (examData[2] || '') + ' (Copy)'; // Suggest new Name
             examDurationInput.value = examData[3] || '';
             // Keep auto-filled date/time from showAddExamDialog or use original? Using auto-filled for now.
             // examStartDateInput.value = examData[4] || '';
             // examStartTimeInput.value = examData[5] || '';
             examModeInput.value = examData[6] || 'Quiz';

             // Pre-fill questions (same logic as editExam)
             questionsBuilderDiv.innerHTML = ''; const questionsRaw = examData[7] || '[]';
             try {
                 const questions = JSON.parse(questionsRaw);
                 if (Array.isArray(questions) && questions.length > 0) questions.forEach(q => addQuestionBlock(q));
                 else if (questions.length === 0) questionsBuilderDiv.innerHTML = '<p style="text-align: center; color: #777;">No questions defined.</p>';
                 else throw new Error("Questions data not an array.");
             } catch (e) { console.error("Error parsing/populating questions for duplicate:", e); questionsBuilderDiv.innerHTML = `<p style="color: red; text-align: center;">Error loading questions: ${e.message}</p>`; }

             showImprovedNotification('info', 'Exam Duplicated', 'Exam data loaded into the form. Modify PIN and details as needed before saving.');
        }

        // === Content Popup Functions ===
        // UPDATED: showAnswersPopup and showFingerprintPopup to handle JSON parse errors
        function showAnswersPopup(rowElement) {
             const answersRaw = rowElement.dataset.answers || '{}';
             const formattedContent = formatJsonForDisplay(answersRaw); // formatJsonForDisplay handles parsing & errors
             showContentPopup('Student Answers', formattedContent);
         }
        function showFingerprintPopup(rowElement) {
             const fingerprintRaw = rowElement.dataset.fingerprint || '{}';
             const formattedContent = formatJsonForDisplay(fingerprintRaw); // formatJsonForDisplay handles parsing & errors
             showContentPopup('Submission Fingerprint', formattedContent);
         }
        // showQuestionsPopup removed as preview is now in table

        // showContentPopup & closeContentPopup - Unchanged
        function showContentPopup(title, contentHtml) { contentPopupTitle.textContent = title; contentPopupContent.innerHTML = contentHtml; contentPopupBackdrop.classList.add('visible'); }
        function closeContentPopup() { contentPopupBackdrop.classList.remove('visible'); contentPopupContent.innerHTML = ''; contentPopupTitle.textContent = 'Content Details'; }

        // === Grading Functions ===
        // async openGradingDialog - Modified to populate navigator (see previous thought/code)
        async function openGradingDialog(rowElement) {
            if (!isAdminAllowed) return;
            try {
                currentGradeSheetRow = parseInt(rowElement.dataset.sheetRow, 10);
                const studentName = rowElement.dataset.name || 'N/A'; const studentEmail = rowElement.dataset.email || 'N/A'; const examPin = rowElement.dataset.pin || 'N/A'; const timestamp = rowElement.dataset.timestamp || 'N/A'; const answersRaw = rowElement.dataset.answers || '{}'; const gradesRaw = rowElement.dataset.grades || '{}';

                gradingDialogTitle.textContent = `Grade Submission (Row ${currentGradeSheetRow})`; gradingStudentName.textContent = studentName; gradingStudentEmail.textContent = studentEmail; gradingExamPin.textContent = examPin; gradingTimestamp.textContent = timestamp; gradingQuestionsContainer.innerHTML = '<p style="text-align: center;"><i class="fas fa-spinner fa-spin"></i> Loading exam details...</p>'; gradingFeedbackInput.value = ''; gradingTotalScoreInput.value = ''; gradingMaxScoreSpan.textContent = '0'; gradingPercentageSpan.textContent = '0%'; gradingNavigatorSelect.innerHTML = '<option value="">-- Select Question --</option>'; // Clear navigator
                gradingDialogBackdrop.classList.add('visible');

                currentSubmissionAnswers = {}; try { currentSubmissionAnswers = JSON.parse(answersRaw); } catch (e) { console.error(`Error parsing student answers JSON row ${currentGradeSheetRow}:`, e); showImprovedNotification('error', 'Answer Parse Error', `Could not parse answers: ${e.message}`); gradingQuestionsContainer.innerHTML = '<p style="color: red;">Error parsing student answers.</p>'; return; }
                const examDetails = await findExamDetailsByPin(examPin); if (!examDetails) { gradingQuestionsContainer.innerHTML = `<p style="color: red;">Error: Could not find exam details for PIN: ${examPin}</p>`; return; }
                gradingExamName.textContent = examDetails.Name || 'N/A';

                currentExamQuestions = []; try { currentExamQuestions = JSON.parse(examDetails.Questions || '[]'); if (!Array.isArray(currentExamQuestions)) throw new Error("Questions not an array."); } catch (e) { console.error(`Error parsing exam questions JSON PIN ${examPin}:`, e); showImprovedNotification('error', 'Question Parse Error', `Could not parse exam questions: ${e.message}`); gradingQuestionsContainer.innerHTML = '<p style="color: red;">Error parsing exam questions.</p>'; return; }

                const totalPoints = calculateTotalPoints(currentExamQuestions); gradingMaxScoreSpan.textContent = totalPoints;
                populateGradingQuestions(); // Populates questions AND navigator dropdown
                loadExistingGrades(gradesRaw);

            } catch (error) { console.error("Error in openGradingDialog:", error); showImprovedNotification('error', 'Error', 'Failed to open grading dialog: ' + error.message); closeGradingDialog(); }
        }
        // findExamDetailsByPin - Unchanged
        async function findExamDetailsByPin(pin) { if (allExamsData.length === 0) { console.log("Exam cache empty, fetching..."); await loadExamsData(); } const examItem = allExamsData.find(item => item.data[0] === pin); if (examItem) { const d = examItem.data; return { PIN: d[0], Code: d[1], Name: d[2], Duration: d[3], StartDate: d[4], StartTime: d[5], Mode: d[6], Questions: d[7] }; } console.warn(`Exam details not found in cache for PIN: ${pin}`); return null; }
        // closeGradingDialog - Unchanged
        function closeGradingDialog() { gradingDialogBackdrop.classList.remove('visible'); currentExamQuestions = null; currentSubmissionAnswers = null; currentGradeSheetRow = null; gradingQuestionsContainer.innerHTML = '<p style="text-align: center; color: #777;">Loading...</p>'; gradingFeedbackInput.value = ''; gradingTotalScoreInput.value = ''; }
        // calculateTotalPoints - Unchanged (uses question.points || 1)
        function calculateTotalPoints(questions) { return questions.reduce((sum, q) => sum + (parseFloat(q.points) || 1), 0); }
        // populateGradingQuestions - Modified to populate navigator and remove button text (see previous thought/code)
     function populateGradingQuestions() {
     if (!currentExamQuestions || !currentSubmissionAnswers) { 
         gradingQuestionsContainer.innerHTML = '<p style="color: red;">Error: Missing questions or answers.</p>'; 
         return; 
     }
     if (currentExamQuestions.length === 0) { 
         gradingQuestionsContainer.innerHTML = '<p style="color: #777;">No questions found.</p>'; 
         return; 
     }

     let questionsHtml = ''; 
     let navigatorHtml = '<option value="">-- Select Question --</option>';
     
     // Add "Confirm All" button at the top
     questionsHtml += `
        <div style="text-align: right; margin-bottom: 20px;">
            <button type="button" class="btn-info" onclick="confirmAllQuestions()">
                <i class="fas fa-check-double"></i> Confirm All Questions
            </button>
        </div>
     `;
     
     currentExamQuestions.forEach((question, index) => {
         const qNum = index + 1;
         // Default points to 1 if not specified, including for text-only fields
         const maxPoints = parseFloat(question.points) || 1;
         const answerId = `ans-${qNum}`;
         const studentAnswer = currentSubmissionAnswers[answerId] ?? '';
         const isMultipleChoice = question.type === 'multiple_select';
         const isTextOnly = question.type === 'text_only';

         // Add to navigator dropdown
         navigatorHtml += `<option value="grading-q-${qNum}">Question ${qNum} (${escapeHtml(question.prompt.substring(0, 20))}...)</option>`;

         // Add appropriate question card based on type
         if (isTextOnly) {
             // Text-only questions now have points
             questionsHtml += `
                 <div class="question-grading-card text-only-question" id="grading-q-${qNum}" data-question-index="${index}">
                     <div class="text-content">${escapeHtml(question.prompt)}</div>
                     <div class="question-grading-controls" style="margin-top: 12px;">
                         <div class="form-group" style="flex-grow: 1;">
                             <label for="comment-q-${qNum}">Instructor Comments:</label>
                             <textarea id="comment-q-${qNum}" class="form-control" rows="2" 
                                 placeholder="Add comments about this text (optional)"></textarea>
                         </div>
                         <div class="question-points" style="margin: 10px 0;">
                             <label for="points-q-${qNum}">Points:</label>
                             <input type="number" class="form-control" id="points-q-${qNum}" 
                                    min="0" max="${maxPoints}" value="0" step="0.1" 
                                    onchange="updateTotalScore()">
                             <span>/ ${maxPoints}</span>
                         </div>
                         <div class="grading-button-group">
                             <button type="button" class="btn-sm btn-primary confirm-btn" data-question="${qNum}" onclick="confirmTextQuestion(${qNum})" title="Mark as Reviewed">
                                 <i class="fas fa-check"></i> Confirm
                             </button>
                         </div>
                     </div>
                 </div>
             `;
         } else {
             // Regular graded questions
             questionsHtml += `
                 <div class="question-grading-card ungraded" id="grading-q-${qNum}" data-question-index="${index}">
                     <div class="question-grading-main">
                         <div class="question-prompt">Question ${qNum}: ${escapeHtml(question.prompt)}</div>
                         
                         <div class="student-answer">
                             <span class="answer-label">Student Answer:</span>
                             <div>${formatStudentAnswer(studentAnswer, question.type)}</div>
                         </div>`;
                         
             if (isMultipleChoice && Array.isArray(question.correct_answers) && question.correct_answers.length > 0) {
                 questionsHtml += `
                     <div class="correct-answer">
                         <span class="answer-label">Correct Answer(s):</span>
                         <div>${formatCorrectAnswer(question)}</div>
                     </div>`;
             }
             
             questionsHtml += `
                     </div>
                     <div class="form-group" style="margin: 10px 0;">
                         <label for="comment-q-${qNum}">Instructor Comments:</label>
                         <textarea id="comment-q-${qNum}" class="form-control" rows="2" 
                             placeholder="Add feedback for this question (optional)"></textarea>
                     </div>
                     <div class="question-grading-controls">
                         <div class="question-points">
                             <label for="points-q-${qNum}">Points:</label>
                             <input type="number" class="form-control" id="points-q-${qNum}" 
                                    min="0" max="${maxPoints}" value="0" step="0.1" 
                                    onchange="updateTotalScore()">
                             <span>/ ${maxPoints}</span>
                         </div>
                         <div class="grading-button-group">`;
             
             // Only show Correct/Incorrect buttons for multiple choice questions
             if (isMultipleChoice) {
                 questionsHtml += `
                     <button type="button" class="btn-sm btn-success" onclick="markCorrect(${qNum}, ${maxPoints})" title="Mark Correct (Full Points)">
                         <i class="fas fa-check"></i> Correct
                     </button>
                     <button type="button" class="btn-sm btn-danger" onclick="markIncorrect(${qNum})" title="Mark Incorrect (Zero Points)">
                         <i class="fas fa-times"></i> Incorrect
                     </button>
                     <button type="button" class="btn-sm btn-info" onclick="autoGradeQuestion(${qNum}, ${maxPoints})" title="Auto Grade">
                         <i class="fas fa-magic"></i> Auto
                     </button>`;
             }
             
             questionsHtml += `
                         <button type="button" class="btn-sm btn-primary confirm-btn" data-question="${qNum}" onclick="confirmQuestion(${qNum})" title="Mark as Reviewed">
                             <i class="fas fa-check"></i> Confirm
                         </button>
                     </div>
                 </div>
             </div>`;
         }
     });
     
     gradingQuestionsContainer.innerHTML = questionsHtml;
     gradingNavigatorSelect.innerHTML = navigatorHtml; // Populate dropdown
     
     // Apply styles to code snippets (black background)
     document.querySelectorAll('.student-answer pre').forEach(codeBlock => {
         codeBlock.style.backgroundColor = '#1f2937';
         codeBlock.style.color = '#e5e7eb';
         codeBlock.style.padding = '10px';
         codeBlock.style.borderRadius = '6px';
         codeBlock.style.fontFamily = 'monospace';
         codeBlock.style.overflow = 'auto';
         codeBlock.style.maxHeight = '200px';
     });
     
     updateTotalScore();
}
        // loadExistingGrades - Unchanged
        function loadExistingGrades(gradesRaw) { if (!gradesRaw || gradesRaw === '{}') return; try { const grades = JSON.parse(gradesRaw); console.log("Loading existing grades:", grades); gradingTotalScoreInput.value = grades.totalScore ?? 0; gradingFeedbackInput.value = grades.feedback ?? ''; if (grades.questionGrades) { for (const qId in grades.questionGrades) { if (qId.startsWith('q-')) { const qNum = parseInt(qId.substring(2), 10); const pointsInput = document.getElementById(`points-q-${qNum}`); const card = document.getElementById(`grading-q-${qNum}`); const qGrade = grades.questionGrades[qId]; if (pointsInput) pointsInput.value = qGrade.points ?? 0; if (card && qGrade.status) card.className = `question-grading-card ${qGrade.status}`; } } } updateGradePercentage(); } catch (e) { console.error("Error loading existing grades JSON:", e); showImprovedNotification('warning', 'Grade Load Warning', `Could not load previous grades: ${e.message}`); } }
        // formatStudentAnswer - Unchanged
        function formatStudentAnswer(answer, questionType) { if (answer === null || typeof answer === 'undefined' || answer === '') return '<em>No answer provided</em>'; const escapedAnswer = escapeHtml(String(answer)); switch (questionType) { case 'code': return `<pre>${escapedAnswer}</pre>`; case 'attachment': return String(answer).startsWith('FILE_UPLOADED:') ? `<em>File:</em> ${escapeHtml(String(answer).replace('FILE_UPLOADED:', ''))}` : `<em>${escapedAnswer}</em>`; case 'long_answer': return escapedAnswer.replace(/\n/g, '<br>'); default: return escapedAnswer; } }
        // formatCorrectAnswer - Unchanged
        function formatCorrectAnswer(question) { if (question.type === 'multiple_select' && Array.isArray(question.correct_answers)) return question.correct_answers.map(ans => escapeHtml(ans)).join('<br>'); return '<em>(Manual grading)</em>'; }
        // markCorrect - Unchanged
        function markCorrect(questionNumber, maxPoints = 1) { const pointsInput = document.getElementById(`points-q-${questionNumber}`); const card = document.getElementById(`grading-q-${questionNumber}`); if (pointsInput) pointsInput.value = maxPoints; if (card) card.className = 'question-grading-card correct'; updateTotalScore(); }
        // markIncorrect - Unchanged
        function markIncorrect(questionNumber) { const pointsInput = document.getElementById(`points-q-${questionNumber}`); const card = document.getElementById(`grading-q-${questionNumber}`); if (pointsInput) pointsInput.value = 0; if (card) card.className = 'question-grading-card incorrect'; updateTotalScore(); }
        // autoGradeQuestion - Unchanged
        function autoGradeQuestion(questionNumber, maxPoints = 1) { const questionIndex = questionNumber - 1; if (!currentExamQuestions || !currentSubmissionAnswers || questionIndex < 0 || questionIndex >= currentExamQuestions.length) return; const question = currentExamQuestions[questionIndex]; const answerId = `ans-${questionNumber}`; const studentAnswer = currentSubmissionAnswers[answerId] ?? ''; if (question.type !== 'multiple_select' || !Array.isArray(question.correct_answers) || question.correct_answers.length === 0) { showImprovedNotification('warning', 'Auto-grade Error', `Q${questionNumber} not auto-gradable.`); return; } const isCorrect = question.correct_answers.includes(String(studentAnswer)); if (isCorrect) markCorrect(questionNumber, maxPoints); else markIncorrect(questionNumber); }
        // runAutograder - Unchanged
        function runAutograder() { if (!currentExamQuestions) return; let autoGradedCount = 0; currentExamQuestions.forEach((q, index) => { const qNum = index + 1; const maxPoints = parseFloat(q.points) || 1; if (q.type === 'multiple_select' && Array.isArray(q.correct_answers) && q.correct_answers.length > 0) { autoGradeQuestion(qNum, maxPoints); autoGradedCount++; } }); showImprovedNotification('info', 'Auto-grading Complete', `Attempted to auto-grade ${autoGradedCount} question(s).`); }
        // updateTotalScore - Unchanged
        function updateTotalScore() { if (!currentExamQuestions) return; const maxPossibleScore = calculateTotalPoints(currentExamQuestions); let currentTotalScore = 0; currentExamQuestions.forEach((q, index) => { const qNum = index + 1; const pointsInput = document.getElementById(`points-q-${qNum}`); if (pointsInput) currentTotalScore += parseFloat(pointsInput.value) || 0; }); gradingTotalScoreInput.value = currentTotalScore.toFixed(1); updateGradePercentage(); }
        // updateGradePercentage - Unchanged
        function updateGradePercentage() { const totalScore = parseFloat(gradingTotalScoreInput.value) || 0; const maxScore = parseFloat(gradingMaxScoreSpan.textContent) || 0; let percentage = 0; if (maxScore > 0) percentage = (totalScore / maxScore) * 100; gradingPercentageSpan.textContent = `${percentage.toFixed(1)}%`; }
        // saveGrades - Unchanged
        async function saveGrades() { if (!currentGradeSheetRow || !currentExamQuestions) { showImprovedNotification('error', 'Save Error', 'Missing data for saving grades.'); return; } saveGradingDialogBtn.disabled = true; saveGradingDialogBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...'; const totalScore = parseFloat(gradingTotalScoreInput.value) || 0; const maxScore = parseFloat(gradingMaxScoreSpan.textContent) || 0; const percentage = gradingPercentageSpan.textContent || '0%'; const feedback = gradingFeedbackInput.value.trim(); const questionGrades = {}; let allGraded = true; currentExamQuestions.forEach((q, index) => { const qNum = index + 1; const pointsInput = document.getElementById(`points-q-${qNum}`); const card = document.getElementById(`grading-q-${qNum}`); let status = 'ungraded'; if (card) { if (card.classList.contains('correct')) status = 'correct'; else if (card.classList.contains('incorrect')) status = 'incorrect'; else if (card.classList.contains('partial')) status = 'partial'; } if (status === 'ungraded') allGraded = false; questionGrades[`q-${qNum}`] = { points: parseFloat(pointsInput?.value || 0), status: status }; }); const gradeData = { totalScore: totalScore.toFixed(1), maxScore: maxScore, percentage: percentage, feedback: feedback, gradedAt: new Date().toISOString(), gradedBy: currentUser?.email || 'Unknown', questionGrades: questionGrades }; const gradeJson = JSON.stringify(gradeData); console.log(`Saving grades row ${currentGradeSheetRow}:`, gradeData); const gradeRange = `${EXAM_ATTEMPTS_SHEET_NAME}!J${currentGradeSheetRow}`; const statusRange = `${EXAM_ATTEMPTS_SHEET_NAME}!G${currentGradeSheetRow}`; const newStatus = allGraded ? 'graded' : 'submit'; let gradeSaveSuccess = false; let statusUpdateSuccess = false; try { gradeSaveSuccess = await updateSheetData(EXAM_SPREADSHEET_ID, gradeRange, [[gradeJson]]); if (gradeSaveSuccess) statusUpdateSuccess = await updateSheetData(EXAM_SPREADSHEET_ID, statusRange, [[newStatus]]); if (gradeSaveSuccess && statusUpdateSuccess) { showImprovedNotification('success', 'Grades Saved', `Grades saved & status updated for row ${currentGradeSheetRow}.`); closeGradingDialog(); loadAttemptsData(); } else if (gradeSaveSuccess && !statusUpdateSuccess) { showImprovedNotification('warning', 'Partial Save', `Grades saved, but failed to update status for row ${currentGradeSheetRow}.`); loadAttemptsData(); } else console.error('Grade save failed.'); } catch (error) { console.error('Error during saveGrades:', error); showImprovedNotification('error', 'Save Failed', `Unexpected error: ${error.message}`); } finally { saveGradingDialogBtn.disabled = !isOnline || !isAdminAllowed; saveGradingDialogBtn.innerHTML = 'Save Grades'; } }

         // NEW: Handle Grade Navigator Change
         function handleGradeNavigate() {
             const selectedQuestionId = gradingNavigatorSelect.value;
             if (selectedQuestionId) {
                 const targetElement = document.getElementById(selectedQuestionId);
                 if (targetElement) {
                     targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                     // Optional: Add a temporary highlight effect
                     targetElement.style.transition = 'background-color 0.5s ease';
                     targetElement.style.backgroundColor = 'rgba(57, 73, 171, 0.1)';
                     setTimeout(() => {
                         targetElement.style.backgroundColor = ''; // Reset background
                     }, 1500);
                 }
             }
         }
         
        // === PDF Export Functions ===
        function exportExamToPDF() {
            if (!isAdminAllowed || allExamsData.length === 0) {
                showImprovedNotification('warning', 'Export Error', 'No exam data available to export');
                return;
            }
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4'
            });
            
            // Add title and metadata
            doc.setFontSize(16);
            doc.setTextColor(33, 33, 33);
            doc.text('Exam List Report', 15, 15);
            
            // Add generation info
            doc.setFontSize(9);
            doc.setTextColor(100, 100, 100);
            const generatedDate = new Date().toLocaleString();
            doc.text(`Generated by: ${currentUser?.name || 'Admin'} on ${generatedDate}`, 15, 22);
            
            // Add table of exams
            const tableData = [];
            const tableHeaders = [['PIN', 'Course', 'Name', 'Duration', 'Date', 'Time', 'Mode']];
            
            // Sort by course code first
            const sortedData = [...allExamsData].sort((a, b) => {
                const courseA = a.data[1] || '';
                const courseB = b.data[1] || '';
                return courseA.localeCompare(courseB);
            });
            
            // Group by course code
            let currentCourse = '';
            
            sortedData.forEach(item => {
                const row = item.data;
                const pin = row[0] || '';
                const course = row[1] || '';
                const name = row[2] || '';
                const duration = row[3] || '';
                const date = row[4] || '';
                const time = row[5] || '';
                const mode = row[6] || '';
                
                // Add course headers
                if (course !== currentCourse) {
                    currentCourse = course;
                    tableData.push([{
                        content: `Course: ${currentCourse}`,
                        colSpan: 7,
                        styles: {
                            fontStyle: 'bold',
                            fillColor: [59, 73, 171],
                            textColor: [255, 255, 255],
                            cellPadding: 3
                        }
                    }]);
                }
                
                tableData.push([pin, course, name, duration, date, time, mode]);
            });
            
            // Generate the table
            doc.autoTable({
                head: tableHeaders,
                body: tableData,
                startY: 25,
                theme: 'grid',
                styles: {
                    fontSize: 9,
                    cellPadding: 2
                },
                headStyles: {
                    fillColor: [51, 102, 255],
                    textColor: [255, 255, 255],
                    fontStyle: 'bold'
                },
                alternateRowStyles: {
                    fillColor: [240, 240, 240]
                },
                columnStyles: {
                    0: { cellWidth: 15 }, // PIN
                    1: { cellWidth: 20 }, // Course
                    2: { cellWidth: 50 }, // Name
                    3: { cellWidth: 18 }, // Duration
                    4: { cellWidth: 25 }, // Date
                    5: { cellWidth: 20 }, // Time
                    6: { cellWidth: 20 }  // Mode
                }
            });
            
            // Add page number
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(9);
                doc.setTextColor(100, 100, 100);
                doc.text(`Page ${i} of ${pageCount}`, doc.internal.pageSize.width - 25, doc.internal.pageSize.height - 10);
            }
            
            // Save PDF
            doc.save('exam-list-report.pdf');
            showImprovedNotification('success', 'Export Complete', 'Exam list has been exported as PDF', 3000);
        }
        
        function exportSubmissionsToPDF() {
            if (!isAdminAllowed || allAttemptsData.length === 0) {
                showImprovedNotification('warning', 'Export Error', 'No submission data available to export');
                return;
            }
            
            // Get filtered submissions based on current filter settings
            const filteredData = applyCurrentFiltersToAttempts();
            
            if (filteredData.length === 0) {
                showImprovedNotification('warning', 'Export Error', 'No submissions match the current filters');
                return;
            }
            
            // If more than 10 submissions matched, ask for confirmation
            if (filteredData.length > 10 && !confirm(`This will generate a detailed report for ${filteredData.length} submissions, which may create a large PDF. Continue?`)) {
                return;
            }
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4'
            });
            
            // Add title and metadata on first page
            doc.setFontSize(16);
            doc.setTextColor(33, 33, 33);
            doc.text('Detailed Exam Submissions Report', 15, 15);
            
            // Add generation info
            doc.setFontSize(9);
            doc.setTextColor(100, 100, 100);
            const generatedDate = new Date().toLocaleString();
            doc.text(`Generated by: ${currentUser?.name || 'Admin'} on ${generatedDate}`, 15, 22);
            
            // Set starting y position
            let yPosition = 30;
            let currentPage = 1;
            
            // Process each submission
            const processSubmissions = async () => {
                for (let i = 0; i < filteredData.length; i++) {
                    const item = filteredData[i];
                    const row = item.data;
                    
                    // Check if we need a new page
                    if (yPosition > 250) {
                        doc.addPage();
                        currentPage++;
                        yPosition = 20;
                    }
                    
                    // Extract submission data
                    const timestamp = row[0] || '';
                    const studentName = row[1] || '';
                    const email = row[2] || '';
                    const pin = row[3] || '';
                    const course = row[4] || '';
                    const studentId = row[5] || '';
                    const status = row[6] || '';
                    const answersRaw = row[7] || '{}';
                    const gradesRaw = row[9] || '{}';
                    
                    // Get exam information and questions
                    const examInfo = await findExamDetailsByPin(pin);
                    if (!examInfo) {
                        console.error(`Could not find exam info for PIN: ${pin}`);
                        continue;
                    }
                    
                    // Add student header
                    doc.setFillColor(59, 73, 171);
                    doc.setDrawColor(59, 73, 171);
                    doc.rect(15, yPosition, 180, 10, 'F');
                    doc.setTextColor(255, 255, 255);
                    doc.setFontSize(12);
                    doc.setFont(undefined, 'bold');
                    doc.text(`Student: ${studentName} (${studentId})`, 17, yPosition + 6);
                    yPosition += 14;
                    
                    // Add exam info
                    doc.setTextColor(33, 33, 33);
                    doc.setFontSize(10);
                    doc.setFont(undefined, 'normal');
                    doc.text(`Course: ${course}`, 15, yPosition);
                    doc.text(`Exam: ${examInfo.Name || 'Unknown'} (PIN: ${pin})`, 15, yPosition + 5);
                    doc.text(`Submitted: ${timestamp}`, 15, yPosition + 10);
                    doc.text(`Status: ${status}`, 15, yPosition + 15);
                    yPosition += 22;
                    
                    // Parse answers and grades
                    let answers = {};
                    let grades = {};
                    let totalScore = 'Not graded';
                    let maxScore = '';
                    let percentage = '';
                    let feedback = '';
                    
                    try {
                        answers = JSON.parse(answersRaw);
                    } catch (e) {
                        console.error('Error parsing answers:', e);
                    }
                    
                    try {
                        if (gradesRaw && gradesRaw !== '{}') {
                            grades = JSON.parse(gradesRaw);
                            totalScore = grades.totalScore || 'Not graded';
                            maxScore = grades.maxScore || '';
                            percentage = grades.percentage || '';
                            feedback = grades.feedback || '';
                        }
                    } catch (e) {
                        console.error('Error parsing grades:', e);
                    }
                    
                    // Add overall grade
                    if (status.toLowerCase() === 'graded') {
                        doc.setFillColor(16, 185, 129); // Success color
                        doc.setDrawColor(16, 185, 129);
                        doc.setTextColor(255, 255, 255);
                        doc.roundedRect(15, yPosition, 180, 10, 2, 2, 'F');
                        doc.setFontSize(11);
                        doc.setFont(undefined, 'bold');
                        doc.text(`Overall Grade: ${totalScore}/${maxScore} (${percentage})`, 17, yPosition + 6);
                        yPosition += 14;
                    }
                    
                    // Parse exam questions
                    let questions = [];
                    try {
                        questions = JSON.parse(examInfo.Questions || '[]');
                    } catch (e) {
                        console.error('Error parsing questions:', e);
                    }
                    
                    // Add each question and answer
                    doc.setTextColor(33, 33, 33);
                    doc.setFontSize(11);
                    doc.setFont(undefined, 'bold');
                    doc.text('Questions and Answers:', 15, yPosition);
                    yPosition += 7;
                    
                    for (let j = 0; j < questions.length; j++) {
                        // Skip text_only questions in submissions
                        if (questions[j].type === 'text_only') continue;
                        
                        const qNum = j + 1;
                        const answerId = `ans-${qNum}`;
                        const studentAnswer = answers[answerId] || '';
                        const questionPoints = questions[j].points || 1;
                        let questionScore = '';
                        let questionStatus = '';
                        
                        // Get the grade for this question if available
                        if (grades.questionGrades && grades.questionGrades[`q-${qNum}`]) {
                            const qGrade = grades.questionGrades[`q-${qNum}`];
                            questionScore = qGrade.points !== undefined ? qGrade.points : '';
                            questionStatus = qGrade.status || '';
                        }
                        
                        // Check if we need a new page
                        if (yPosition > 240) {
                            doc.addPage();
                            currentPage++;
                            yPosition = 20;
                        }
                        
                        // Add question
                        doc.setFillColor(240, 240, 240);
                        doc.setDrawColor(200, 200, 200);
                        doc.roundedRect(15, yPosition, 180, 10, 2, 2, 'F');
                        doc.setTextColor(59, 73, 171);
                        doc.setFontSize(11);
                        doc.setFont(undefined, 'bold');
                        const questionText = `Q${qNum}: ${questions[j].prompt || 'No prompt'}`;
                        
                        // Handle long questions
                        if (questionText.length > 80) {
                            doc.text(questionText.substring(0, 80) + '...', 17, yPosition + 6);
                        } else {
                            doc.text(questionText, 17, yPosition + 6);
                        }
                        yPosition += 14;
                        
                        // Add question details
                        doc.setTextColor(100, 100, 100);
                        doc.setFontSize(9);
                        doc.setFont(undefined, 'italic');
                        let details = `Type: ${questions[j].type || 'N/A'}`;
                        if (questionPoints) details += `, Points: ${questionPoints}`;
                        doc.text(details, 15, yPosition);
                        yPosition += 6;
                        
                        // Add student answer
                        doc.setTextColor(33, 33, 33);
                        doc.setFontSize(10);
                        doc.setFont(undefined, 'normal');
                        doc.text('Student Answer:', 15, yPosition);
                        yPosition += 5;
                        
                        // Handle different answer types
                        if (!studentAnswer) {
                            doc.setFont(undefined, 'italic');
                            doc.setTextColor(150, 150, 150);
                            doc.text('No answer provided', 20, yPosition);
                            yPosition += 5;
                        } else if (questions[j].type === 'multiple_select') {
                            doc.text(studentAnswer, 20, yPosition);
                            yPosition += 5;
                        } else if (questions[j].type === 'attachment') {
                            let fileInfo = studentAnswer;
                            if (String(studentAnswer).startsWith('FILE_UPLOADED:')) {
                                fileInfo = String(studentAnswer).replace('FILE_UPLOADED:', '');
                            }
                            doc.text(`File: ${fileInfo}`, 20, yPosition);
                            yPosition += 5;
                        } else if (questions[j].type === 'code' || questions[j].type === 'long_answer') {
                            // Format code or long answer with indentation and handling line breaks
                            const answerLines = String(studentAnswer).split('\n');
                            for (let k = 0; k < Math.min(answerLines.length, 15); k++) {
                                // Check if we need a new page for this line
                                if (yPosition > 270) {
                                    doc.addPage();
                                    currentPage++;
                                    yPosition = 20;
                                }
                                
                                const line = answerLines[k].trim();
                                if (line) {
                                    doc.text(line, 20, yPosition);
                                    yPosition += 5;
                                }
                            }
                            
                            // If answer is too long, show ellipsis
                            if (answerLines.length > 15) {
                                doc.setFont(undefined, 'italic');
                                doc.text('... (answer truncated for PDF)', 20, yPosition);
                                yPosition += 5;
                            }
                        } else {
                            doc.text(String(studentAnswer), 20, yPosition);
                            yPosition += 5;
                        }
                        
                        // Add grading information if available
                        if (questionScore !== '') {
                            // Set color based on status
                            if (questionStatus === 'correct') {
                                doc.setTextColor(16, 185, 129); // Green
                            } else if (questionStatus === 'incorrect') {
                                doc.setTextColor(239, 68, 68); // Red
                            } else if (questionStatus === 'partial') {
                                doc.setTextColor(245, 158, 11); // Orange
                            } else {
                                doc.setTextColor(59, 130, 246); // Blue
                            }
                            
                            doc.setFontSize(10);
                            doc.setFont(undefined, 'bold');
                            doc.text(`Grading: ${questionScore}/${questionPoints} points (${questionStatus || 'unknown'})`, 15, yPosition);
                            yPosition += 7;
                        } else {
                            yPosition += 2;
                        }
                        
                        // Add separator
                        doc.setDrawColor(220, 220, 220);
                        doc.line(15, yPosition, 195, yPosition);
                        yPosition += 7;
                    }
                    
                    // Add teacher feedback if available
                    if (feedback) {
                        // Check if we need a new page
                        if (yPosition > 240) {
                            doc.addPage();
                            currentPage++;
                            yPosition = 20;
                        }
                        
                        doc.setTextColor(33, 33, 33);
                        doc.setFontSize(11);
                        doc.setFont(undefined, 'bold');
                        doc.text('Teacher Feedback:', 15, yPosition);
                        yPosition += 7;
                        
                        doc.setFont(undefined, 'normal');
                        doc.setFontSize(10);
                        
                        // Split feedback into lines to handle potential word wrap
                        const feedbackLines = doc.splitTextToSize(feedback, 175);
                        for (let j = 0; j < feedbackLines.length; j++) {
                            if (yPosition > 270) {
                                doc.addPage();
                                currentPage++;
                                yPosition = 20;
                            }
                            
                            doc.text(feedbackLines[j], 15, yPosition);
                            yPosition += 5;
                        }
                    }
                    
                    // Add page separator
                    doc.addPage();
                    currentPage++;
                    yPosition = 20;
                }
                
                // Add page numbers to all pages
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFontSize(9);
                    doc.setTextColor(100, 100, 100);
                    doc.text(`Page ${i} of ${pageCount}`, doc.internal.pageSize.width - 25, doc.internal.pageSize.height - 10);
                }
                
                // Save the PDF
                doc.save('detailed-submissions-report.pdf');
                showImprovedNotification('success', 'Export Complete', `Detailed submission report for ${filteredData.length} student(s) has been exported as PDF`, 3000);
            };
            
            // Start processing
            processSubmissions().catch(error => {
                console.error('Error generating PDF:', error);
                showImprovedNotification('error', 'Export Error', `Failed to generate PDF: ${error.message}`);
            });
        }
        
        function exportGradesToPDF() {
            if (!isAdminAllowed || allAttemptsData.length === 0) {
                showImprovedNotification('warning', 'Export Error', 'No grade data available to export');
                return;
            }
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4'
            });
            
            // Add title and metadata
            doc.setFontSize(16);
            doc.setTextColor(33, 33, 33);
            doc.text('Exam Grades Report', 15, 15);
            
            // Add generation info
            doc.setFontSize(9);
            doc.setTextColor(100, 100, 100);
            const generatedDate = new Date().toLocaleString();
            doc.text(`Generated by: ${currentUser?.name || 'Admin'} on ${generatedDate}`, 15, 22);
            
            // Filter data to only include graded submissions
            const filteredData = applyCurrentFiltersToAttempts().filter(item => {
                const status = item.data[6] || '';
                return status.toLowerCase() === 'graded';
            });
            
            if (filteredData.length === 0) {
                showImprovedNotification('warning', 'Export Error', 'No graded submissions found');
                return;
            }
            
            // Group data by course/exam
            const groupedByCourse = {};
            
            filteredData.forEach(item => {
                const row = item.data;
                const course = row[4] || 'Unknown Course';
                const pin = row[3] || 'Unknown PIN';
                
                if (!groupedByCourse[course]) {
                    groupedByCourse[course] = {};
                }
                
                if (!groupedByCourse[course][pin]) {
                    groupedByCourse[course][pin] = [];
                }
                
                groupedByCourse[course][pin].push(item);
            });
            
            // Generate tables for each course and exam
            let yPosition = 25;
            let currentPage = 1;
            
            // Sort courses alphabetically
            const sortedCourses = Object.keys(groupedByCourse).sort();
            
            sortedCourses.forEach((course, courseIndex) => {
                // Sort exams by PIN
                const sortedPins = Object.keys(groupedByCourse[course]).sort();
                
                sortedPins.forEach((pin, pinIndex) => {
                    const examData = groupedByCourse[course][pin];
                    
                    // Check if we need a new page
                    if (yPosition > 230) {
                        doc.addPage();
                        currentPage++;
                        yPosition = 20;
                    }
                    
                    // Add course and exam header
                    doc.setFontSize(12);
                    doc.setTextColor(59, 73, 171);
                    doc.setFont(undefined, 'bold');
                    doc.text(`${course} - Exam PIN: ${pin}`, 15, yPosition);
                    yPosition += 8;
                    
                    // Define table headers
                    const tableHeaders = [['Student Name', 'Student ID', 'Score', 'Max', 'Percentage', 'Grade']];
                    const tableData = [];
                    
                    // Process grade data
                    examData.forEach(item => {
                        const row = item.data;
                        const studentName = row[1] || 'N/A';
                        const studentId = row[5] || 'N/A';
                        let score = 'N/A';
                        let maxScore = 'N/A';
                        let percentage = 'N/A';
                        let letterGrade = 'N/A';
                        
                        if (row[9]) {
                            try {
                                const grades = JSON.parse(row[9]);
                                score = grades.totalScore || '0';
                                maxScore = grades.maxScore || '0';
                                percentage = grades.percentage || '0%';
                                
                                // Calculate letter grade
                                const percentValue = parseFloat(percentage);
                                if (!isNaN(percentValue)) {
                                    if (percentValue >= 90) letterGrade = 'A';
                                    else if (percentValue >= 80) letterGrade = 'B';
                                    else if (percentValue >= 70) letterGrade = 'C';
                                    else if (percentValue >= 60) letterGrade = 'D';
                                    else letterGrade = 'F';
                                }
                            } catch (e) {
                                // Keep default values on parse error
                            }
                        }
                        
                        tableData.push([studentName, studentId, score, maxScore, percentage, letterGrade]);
                    });
                    
                    // Generate the table
                    const table = doc.autoTable({
                        head: tableHeaders,
                        body: tableData,
                        startY: yPosition,
                        theme: 'grid',
                        styles: {
                            fontSize: 10,
                            cellPadding: 3
                        },
                        headStyles: {
                            fillColor: [59, 73, 171],
                            textColor: [255, 255, 255],
                            fontStyle: 'bold'
                        },
                        alternateRowStyles: {
                            fillColor: [240, 240, 240]
                        },
                        columnStyles: {
                            0: { cellWidth: 50 }, // Name
                            1: { cellWidth: 30 }, // ID
                            2: { cellWidth: 20 }, // Score
                            3: { cellWidth: 20 }, // Max
                            4: { cellWidth: 30 }, // Percentage
                            5: { cellWidth: 20 }  // Grade
                        }
                    });
                    
                    // Update Y position for next table
                    yPosition = table.finalY + 15;
                });
            });
            
            // Add page numbers to all pages
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(9);
                doc.setTextColor(100, 100, 100);
                doc.text(`Page ${i} of ${pageCount}`, doc.internal.pageSize.width - 25, doc.internal.pageSize.height - 10);
            }
            
            // Save PDF
            doc.save('exam-grades-report.pdf');
            showImprovedNotification('success', 'Export Complete', 'Grades have been exported as PDF', 3000);
        }
        
        // Helper function to get filtered attempts based on current filter settings
        function applyCurrentFiltersToAttempts() {
            if (!allAttemptsData || allAttemptsData.length === 0) {
                return [];
            }
            
            const filterName = filterNameInput.value.toLowerCase();
            const filterStudentId = filterStudentIdInput.value.toLowerCase();
            const filterPin = filterPinInput.value.toLowerCase();
            const filterCourse = filterCourseInput.value.toLowerCase();
            
            return allAttemptsData.filter(item => {
                const row = item.data;
                const name = (row[1] || '').toLowerCase();
                const email = (row[2] || '').toLowerCase();
                const pin = (row[3] || '').toLowerCase();
                const course = (row[4] || '').toLowerCase();
                const studentId = (row[5] || '').toLowerCase();
                
                const nameMatch = filterName === '' || name.includes(filterName) || email.includes(filterName);
                const studentIdMatch = filterStudentId === '' || studentId.includes(filterStudentId);
                const pinMatch = filterPin === '' || pin.includes(filterPin);
                const courseMatch = filterCourse === '' || course.includes(filterCourse);
                
                return nameMatch && studentIdMatch && pinMatch && courseMatch;
            });
        }

        // Make showQuestionsPopup globally accessible
        window.showQuestionsPopup = showQuestionsPopup;
        window.showAnswersPopup = showAnswersPopup;
        window.showFingerprintPopup = showFingerprintPopup;
        window.markCorrect = markCorrect;
        window.markIncorrect = markIncorrect;
        window.autoGradeQuestion = autoGradeQuestion;
        window.updateTotalScore = updateTotalScore;
    </script>

</body>
</html>