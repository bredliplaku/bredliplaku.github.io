<!DOCTYPE html>
<html lang="en-GB"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Exam Portal</title>
    <link rel="icon" type="image/png" href="https://bredliplaku.github.io/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
 <style>
        /* --- CSS --- */
        :root {
            --primary-color: #3949ab;
            --primary-dark: #1a237e;
            --success-color: #43a047;
            --warning-color: #fb8c00;
            --info-color: #2196F3;
            --danger-color: #f44336;
            --text-light: #fff;
            /* Define variables for confirmed state for easy adjustment */
            --confirmed-bg: #f0f0f0; /* Light background for confirmed inputs */
            --confirmed-text: transparent; /* Make text invisible */
            --confirmed-opacity: 0.1; /* Very low opacity */
            --confirmed-border: #e0e0e0; /* Lighter border */
            --confirmed-placeholder: transparent; /* Hide placeholder */
        }
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body, html {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            background: #ffffff;
            color: #333;
        }
        .container {
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
        }
        .app-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }
        .app-loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loading-spinner {
            border: 5px solid rgba(57, 73, 171, 0.2);
            border-top: 5px solid #3949ab;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0%   { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .content-hidden {
            visibility: hidden;
            opacity: 0;
        }
        .content-visible {
            visibility: visible;
            opacity: 1;
            transition: opacity 0.5s ease-in;
        }
        .app-header {
            background: linear-gradient(135deg, #3949ab, #1a237e);
            color: white;
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2.0em;
            display: flex;
            align-items: center;
        }
        h1 i {
            margin-right: 10px;
        }
        h2 {
            margin: 0 0 2px 0;
            font-weight: 400;
            font-size: 1.0em;
        }
        .app-info {
            display: flex;
            flex-wrap: wrap;
            margin-top: 15px;
            gap: 10px;
        }
        .info-item {
            background-color: rgba(255,255,255,0.1);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9em;
            line-height: 30px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        .module {
            background-color: #fff;
            border-radius: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            overflow: hidden;
        }
        .module-header {
            background-color: #3949ab;
            color: white;
            padding: 15px;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .module-title {
            font-size: 1.1em;
            display: flex;
            align-items: center;
        }
        .module-title i {
            margin-right: 10px;
        }
        .module-content {
            padding: 20px;
        }
        .not-signed-in-message {
            text-align: center;
            padding: 20px;
            margin-top: 15px;
            border-radius: 15px;
            background-color: rgba(57, 73, 171, 0.1);
            color: #333;
        }
        button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background-color: var(--primary-color);
            color: var(--text-light);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            transition: background-color 0.3s, transform 0.3s, opacity 0.3s;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 0;
            cursor: pointer;
        }
        /* Apply hover only when button is not disabled */
        button:hover:not(:disabled) {
            background-color: var(--primary-dark);
            transform: scale(1.05);
        }
        button:disabled {
            background-color: #aaa;
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .btn-green {
            background-color: var(--success-color);
        }
        .btn-blue {
            background-color: var(--info-color);
        }
        .btn-orange {
             background-color: var(--warning-color);
        }
        .btn-grey {
             background-color: #6c757d;
        }
        .btn-sm {
            padding: 6px 12px;
            font-size: 0.85em;
            border-radius: 15px;
        }
        .in-page-notifications {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            width: 350px;
            max-width: 90%;
            pointer-events: none;
        }
        .in-page-notification {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: slide-in 0.3s ease-out forwards;
            overflow: hidden;
            display: flex;
            align-items: center;
            opacity: 1;
            transition: transform 0.3s ease-in, opacity 0.3s ease-in;
            pointer-events: auto;
        }
        .in-page-notification.removing {
            opacity: 0;
            transform: translateX(100%);
        }
        @keyframes slide-in {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .in-page-notification i.fa-icon {
            margin-right: 10px;
            font-size: 1.2em;
            flex-shrink: 0;
        }
        .notification-content {
            flex-grow: 1;
        }
        .notification-close {
            background: none;
            border: none;
            font-size: 20px;
            line-height: 1;
            color: inherit;
            opacity: 0.7;
            padding: 0 5px;
            margin-left: 10px;
            cursor: pointer;
        }
        .notification-close:hover {
            opacity: 1;
        }
        .in-page-notification-info {
            background-color: #e3f2fd;
            color: #0d47a1;
        }
        .in-page-notification-warning {
            background-color: #fff3e0;
            color: #e65100;
        }
        .in-page-notification-error {
            background-color: #ffebee;
            color: #b71c1c;
        }
        .in-page-notification-success {
            background-color: #e8f5e9;
            color: #1b5e20;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label { /* Labels for inputs like Name, Email, PIN */
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .form-control { /* Base style for text inputs, textareas */
            width: 100%;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
            transition: opacity 0.3s, background-color 0.3s, color 0.3s, border-color 0.3s;
            background-color: #fff;
            color: #333;
            opacity: 1;
        }
        /* Basic disabled style - often overridden by .confirmed */
        input:disabled, textarea:disabled {
            background-color: #eee;
            cursor: not-allowed;
            opacity: 0.7;
        }
        textarea.form-control {
            min-height: 100px;
        }
    .footer {
        max-width: 1000px;
        text-align: center;
        padding: 20px 0;
        color: var(--primary-dark);
        border-radius: 20px;
        margin-left: auto;
        margin-right: auto;
        -webkit-user-select: none;
        -khtml-user-select: none;
    }
    
    .social-links {
        margin-bottom: 10px;
        margin-top: 10px;
    }
    
    .social-links a {
        color: var(--primary-dark);
        font-size: 1.0em;
        margin: 0 10px;
        transition: color 0.3s;
    }
    
    .social-links a:hover {
        color: var(--secondary-color);
    }
        .auth-container {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
        }
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
        }
        .sync-auth-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .sync-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .sync-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9em;
        }
        .sync-status.online i {
            color: var(--success-color);
        }
        .sync-status.offline i {
            color: var(--warning-color);
        }
        #exam-details-display p {
            margin: 8px 0;
        }
        #exam-details-display strong {
            color: var(--primary-dark);
            margin-right: 5px;
        }
        #exam-questions-area {
            margin-top: 20px;
            padding: 20px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 10px;
        }
        #exam-questions-area .question {
            margin-bottom: 25px;
            padding: 20px;
            border-bottom: 1px dashed #ddd;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
             /* Add transition for smoother background change on confirm */
             /* transition: background-color 0.3s; */
        }
        #exam-questions-area .question:last-child {
            border-bottom: none;
        }
        /* Style for the question prompt label */
        #exam-questions-area .question > label {
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
            cursor: default; /* Ensure label isn't confusingly clickable */
        }
        #exam-questions-area .question-content {
             margin-bottom: 15px;
        }
        #exam-questions-area .question-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: flex-end;
        }

        /* --- Enhanced Styling for Confirmed State --- */
        .question.confirmed {
             background-color: #fafafa; /* Slightly off-white background for the whole block */
        }

        /* Style inputs/textareas/checkbox items when confirmed */
        .question.confirmed .form-control, /* Targets text inputs, textareas, file inputs with this class */
        .question.confirmed .checkbox-item { /* Targets the wrapper for each checkbox+label */
            opacity: var(--confirmed-opacity) !important; /* Use variable, !important might be needed */
            background-color: var(--confirmed-bg) !important; /* Use variable */
            color: var(--confirmed-text) !important; /* Use variable (transparent) */
            text-shadow: none !important; /* Remove any text shadow */
            pointer-events: none !important; /* Disable all mouse interactions */
            cursor: default !important; /* Standard cursor */
            border-color: var(--confirmed-border) !important; /* Use variable */
        }

        /* Ensure text placeholders also become invisible */
         .question.confirmed .form-control::placeholder {
             color: var(--confirmed-placeholder) !important; /* Use variable */
             opacity: 1 !important; /* Keep placeholder opacity high if needed */
         }

        /* Ensure labels next to checkboxes are also affected */
        .question.confirmed .checkbox-item label {
             color: var(--confirmed-text) !important; /* Make label text transparent */
             cursor: default !important;
             opacity: 0.2 !important; /* Slightly visible background effect perhaps */
        }

         /* Ensure checkbox itself looks disabled and blends */
         .question.confirmed .form-control-checkbox { /* Target the checkbox input specifically if needed */
             cursor: default !important;
             opacity: var(--confirmed-opacity) !important; /* Match opacity */
         }
        /* --- End Enhanced Styling for Confirmed State --- */


        /* --- Button Visibility Rules --- */
        /* Hide edit button by default */
        .btn-edit {
            display: none;
         }

        /* Show edit button when confirmed */
        .question.confirmed .btn-edit {
            display: inline-flex; /* Use inline-flex to match button styles */
        }

        /* Hide confirm button when confirmed */
        .question.confirmed .btn-confirm {
            display: none;
        }
        /* --- End Button Visibility Rules --- */


        /* --- Multiple Select Checkbox Styling --- */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            transition: opacity 0.3s, background-color 0.3s, color 0.3s;
            padding: 5px;
            border-radius: 4px;
        }
        /* Style the checkbox input itself */
        .checkbox-item input[type="checkbox"].form-control-checkbox {
            margin-right: 8px;
            cursor: pointer;
            width: 18px;
            height: 18px;
            flex-shrink: 0; /* Prevent checkbox from shrinking */
            transition: opacity 0.3s; /* Add transition */
        }
         /* Style the label associated with the checkbox */
         .checkbox-item label {
             margin-bottom: 0;
             font-weight: normal;
             cursor: pointer;
             flex-grow: 1;
             transition: color 0.3s; /* Add transition */
         }
        /* --- End Checkbox Styling --- */


        #submit-exam-btn {
            margin-top: 30px;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
        }
        .hidden {
            display: none !important;
        }
        #timer-display {
            font-weight: bold;
        }
        .confirmation-message {
            text-align: center;
            font-weight: bold;
            color: var(--success-color);
            padding: 30px;
            font-size: 1.2em;
        }
        .file-helper-text {
            display: block;
            margin-top: 5px;
            color: #666;
            font-size: 0.85em;
        }
        .length-limit-note { /* Style for the code length note */
            display: block;
            margin-top: 5px;
            color: #757575;
            font-size: 0.8em;
            font-style: italic;
        }
        @media (max-width: 768px) {
            .sync-auth-container {
                flex-direction: column-reverse;
                align-items: flex-end;
                gap: 10px;
                border-bottom: none;
            }
            .auth-container,
            .sync-container {
                width: 100%;
                justify-content: flex-end;
            }
            .in-page-notifications {
                width: 90%;
                left: 50%;
                transform: translateX(-50%);
            }
        }
    </style>
</head>
<body class="content-hidden">
    <div id="app-loading" class="app-loading">
        <img src="https://raw.githubusercontent.com/bredliplaku/bredliplaku.github.io/refs/heads/main/loading.gif" alt="Loading..." style="width: 150px; height: 150px;">
        <div style="margin-top: 10px; font-size: 14px; color: #666;">Loading Exam Portal...</div>
    </div>
    <div class="container" id="main-container">
        <div class="sync-auth-container">
            <div class="sync-container">
                 <div id="sync-status" class="sync-status offline">
                    <i class="fas fa-circle"></i>
                    <span id="sync-text">Offline</span>
                </div>
            </div>
            <div class="auth-container">
                 <div id="login-container">
                    <button id="login-btn" class="btn-blue">
                        <i class="fas fa-sign-in-alt"></i> Sign in
                    </button>
                </div>
                <div id="user-container" style="display: none">
                    <div class="user-info">
                        <img id="user-avatar" class="user-avatar" src="" alt="Avatar">
                        <span id="user-name"></span>
                         <button id="logout-btn" class="btn-sm">
                            <i class="fas fa-sign-out-alt"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <div class="app-header">
            <h1><i class="fa-solid fa-clipboard-question"></i> Exam Portal</h1>
            <h2 id="exam-name-header">Enter PIN to load exam</h2>
            <div class="app-info">
                <span class="info-item">
                     <i class="fa-solid fa-table-list"></i> Course:
                    <span id="exam-code-display">N/A</span>
                </span>
                <span class="info-item">
                    <i class="far fa-clock fa-spin"></i> Duration:
                     <span id="exam-duration-display">N/A</span>
                </span>
                <span class="info-item">
                    <i class="fas fa-calendar-alt"></i> Start Time:
                    <span id="exam-start-time-display">N/A</span>
                 </span>
            </div>
        </div>
        <div id="in-page-notification-area" class="in-page-notifications"></div>
        <div id="signin-prompt-module" class="module">
            <div class="module-content not-signed-in-message">
                <h3><i class="fas fa-info-circle"></i> Welcome</h3>
                <p>Sign in with your University Google Account.</p>
            </div>
        </div>
        <div id="exam-start-module" class="module hidden">
            <div class="module-header">
                <span class="module-title">
                    <i class="fas fa-user-check"></i> Student Details
                </span>
            </div>
            <div class="module-content">
                <div class="form-group">
                    <label for="student-name">Name:</label>
                     <input type="text" id="student-name" class="form-control" disabled>
                </div>
                <div class="form-group">
                    <label for="student-email">Email:</label>
                    <input type="email" id="student-email" class="form-control" disabled>
                </div>
                  <div class="form-group">
                    <label for="exam-pin-input">Exam PIN:</label>
                    <input type="text" id="exam-pin-input" class="form-control" placeholder="The lecturer will provide you with the PIN">
                </div>
                <div id="student-exam-id-group" class="form-group hidden">
                    <label for="student-exam-id-input">Student Exam ID (Confidential - 5 characters):</label>
                    <input type="text" id="student-exam-id-input" class="form-control" placeholder="Enter your Exam ID from the attendance sheet" maxlength="5">
                </div>
                <button id="load-exam-btn" class="btn-blue" disabled>
                     <i class="fas fa-download"></i> Load Exam
                </button>
                <button id="start-exam-btn-alt" class="btn-green hidden" disabled>
                    <i class="fas fa-play"></i> Start Exam
                </button>
             </div>
        </div>
        <div id="exam-details-module" class="module hidden">
            <div class="module-header">
                <span class="module-title">
                    <i class="fas fa-info-circle"></i> Exam Information
                </span>
             </div>
            <div class="module-content" id="exam-details-display">
                <p>
                    <strong>Exam Name:</strong>
                    <span id="exam-name-detail"></span>
                </p>
                 <p>
                    <strong>Course Code:</strong>
                    <span id="exam-course-code-detail"></span>
                </p>
                <p>
                      <strong>Mode:</strong>
                    <span id="exam-mode-detail"></span>
                </p>
                <p>
                    <strong>Duration:</strong>
                    <span id="exam-duration-detail"></span>
                 </p>
                <p>
                    <strong>Start Time:</strong>
                    <span id="exam-start-time-detail"></span>
                </p>
                 <button id="start-exam-btn" class="btn-green" disabled>
                    <i class="fas fa-play"></i> Start Exam
                </button>
            </div>
        </div>
        <div id="exam-questions-module" class="module hidden">
            <div class="module-header">
                 <span class="module-title">
                    <i class="fa-solid fa-list-ol"></i> Exercises
                </span>
                <span class="info-item" style="background-color: var(--danger-color); color: white;">
                    <i class="fas fa-stopwatch"></i> Time Left:
                    <span id="timer-display">--:--</span>
                </span>
            </div>
            <div class="module-content">
                 <form id="exam-form">
                    <div id="exam-questions-area">
                        <p>Loading questions...</p>
                    </div>
                    <button type="button" id="submit-exam-btn" class="btn-green" disabled>
                         <i class="fas fa-check-circle"></i> Submit Exam
                    </button>
                </form>
            </div>
        </div>
        <div id="submission-confirmation-module" class="module hidden">
              <div class="module-content confirmation-message">
                <i class="fas fa-check-circle fa-3x" style="color: var(--success-color); margin-bottom: 15px;"></i><br>
                Exam Submitted Successfully!
            </div>
        </div>
    <footer class="footer">
        <div class="social-links">
            <a href="https://eis.epoka.edu.al/cv/fullcv/655" target="_blank" rel="noopener noreferrer"><i class="far fa-id-card"></i></a>
            <a href="mailto:bplaku@epoka.edu.al" target="_blank" rel="noopener noreferrer"><i class="far fa-envelope"></i></a>
        </div>
        <p style="font-size:0.7em"><i class="far fa-copyright"></i> 2023-<span id="currentYear"></span> Bredli Plaku. All Rights Reserved.</p>
    </footer>
    </div>

<script>
        // === Configuration ===
        const ADMIN_EMAILS = ['bplaku@epoka.edu.al'];
        const CLIENT_ID = '740588046540-npg0crodtcuinveu6bua9rd6c3hb2s1m.apps.googleusercontent.com'; // Keep for sign-in
        const API_KEY = 'AIzaSyD295FTtMHvXxZablRf0f-FR-IQ2dQRPQE'; // Keep for GAPI client init (e.g., reading sheets)


                const SCOPES = "https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile";


        // --- !!! ADD YOUR DEPLOYED APPS SCRIPT URL HERE !!! ---
        const BACKEND_URL = 'https://script.google.com/macros/s/AKfycbxoC490P6zOD4_FcXCmu890EeGGg8BAbElwSEFkZzlg8AT8g2uWSQBsI4fGw74Dylmh/exec';


        // === App State ===
        let isAdmin = false;
        let isSignedIn = false;
        let currentUser = null;
        let tokenClient = null;
        let isOnline = navigator.onLine;
        let isSyncing = false; // Still useful for read operations
        let isInitializing = true;
        let examDetails = null;         // Holds the loaded exam data {PIN, Code, Name, Duration, StartDate, StartTime, Mode, Questions, OriginalOrderMap}
        let studentPINEntered = '';     // PIN entered by the student
        let studentExamIdEntered = '';  // 5-character ID ONLY for 'Exam' mode, entered by student
        let examTimerInterval = null;   // Interval ID for the countdown timer
        let examEndTime = null;         // Absolute end time (timestamp in ms)
        const appStateKey = 'examAppState'; // Key for localStorage
		let totalQuestions = 0; // To track total number of questions displayed
		let confirmedQuestionsCount = 0; // To track confirmed questions


        // === DOM Elements === (Keep all these as they are used for UI)
        const loadingIndicator      = document.getElementById('app-loading');
        const mainContainer         = document.getElementById('main-container');
        const syncStatus            = document.getElementById('sync-status');
        const syncText              = document.getElementById('sync-text');
        const loginBtn              = document.getElementById('login-btn');
        const logoutBtn             = document.getElementById('logout-btn');
        const loginContainer        = document.getElementById('login-container');
        const userContainer         = document.getElementById('user-container');
        const userName              = document.getElementById('user-name');
        const userAvatar            = document.getElementById('user-avatar');
        const notificationArea      = document.getElementById('in-page-notification-area');
        const examNameHeader        = document.getElementById('exam-name-header');
        const examCodeDisplay       = document.getElementById('exam-code-display');
        const examDurationDisplay   = document.getElementById('exam-duration-display');
        const examStartTimeDisplay  = document.getElementById('exam-start-time-display');
        const signinPromptModule    = document.getElementById('signin-prompt-module');
        const examStartModule       = document.getElementById('exam-start-module');
        const studentNameInput      = document.getElementById('student-name');
        const studentEmailInput     = document.getElementById('student-email');
        const examPinInput          = document.getElementById('exam-pin-input');
        const studentExamIdGroup    = document.getElementById('student-exam-id-group');
        const studentExamIdInput    = document.getElementById('student-exam-id-input');
        const loadExamBtn           = document.getElementById('load-exam-btn');
        const examDetailsModule     = document.getElementById('exam-details-module');
        const examDetailsDisplay    = document.getElementById('exam-details-display');
        const examNameDetail        = document.getElementById('exam-name-detail');
        const examCourseCodeDetail  = document.getElementById('exam-course-code-detail');
        const examModeDetail        = document.getElementById('exam-mode-detail');
        const examDurationDetail    = document.getElementById('exam-duration-detail');
        const examStartTimeDetail   = document.getElementById('exam-start-time-detail');
        const startExamBtn          = document.getElementById('start-exam-btn'); // Button in Details module (Quiz mode)
        const startExamBtnAlt       = document.getElementById('start-exam-btn-alt'); // Button in Start module (Exam mode)
        const examQuestionsModule   = document.getElementById('exam-questions-module');
        const examForm              = document.getElementById('exam-form');
        const examQuestionsArea     = document.getElementById('exam-questions-area');
        const submitExamBtn         = document.getElementById('submit-exam-btn');
        const timerDisplay          = document.getElementById('timer-display');
        const submissionConfirmationModule = document.getElementById('submission-confirmation-module');


        // === Initialisation ===
        window.addEventListener('load', init);

    function init() {
        console.log("Initialising...");
        document.body.classList.remove('content-hidden');
        mainContainer.classList.add('content-visible');
        updateYear();
        setupEventListeners();
        loadAppState(); // Load any saved state early
        updateOnlineStatus();
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);

        // Delay API init slightly
        setTimeout(() => {
            if (typeof gapi !== 'undefined' && typeof google !== 'undefined') {
                initGoogleApi();
            } else {
                handleApiInitError(new Error("Google API objects not loaded"));
            }
        }, 500);
    }

        function setupEventListeners() {
            loginBtn?.addEventListener('click', handleAuthClick);
            logoutBtn?.addEventListener('click', handleSignoutClick);
            loadExamBtn?.addEventListener('click', handleLoadExam);
            startExamBtn?.addEventListener('click', handleStartExam); // For Quiz mode
            startExamBtnAlt?.addEventListener('click', handleStartExam); // For Exam mode
            submitExamBtn?.addEventListener('click', () => handleSubmitExam(false)); // Manual submit trigger

            // Enable load button only when PIN is entered, signed in, and online
            examPinInput?.addEventListener('input', () => {
                if (loadExamBtn) {
                    loadExamBtn.disabled = examPinInput.value.trim() === '' || !isSignedIn || !isOnline;
                }
            });

            // Validate Student Exam ID input for Exam mode
            studentExamIdInput?.addEventListener('input', validateStudentExamIdInput);

            // Initial button states
            if (loadExamBtn) loadExamBtn.disabled = true;
            if (startExamBtn) startExamBtn.disabled = true;
            if (startExamBtnAlt) startExamBtnAlt.classList.add('hidden'); // Hide Exam mode button initially
            if (submitExamBtn) submitExamBtn.disabled = true;
        }

        function showAppContent() {
            loadingIndicator?.classList.add('hidden');
            mainContainer?.classList.add('content-visible');
            console.log("App content shown.");
        }

        function updateYear() {
            const el = document.getElementById('currentYear');
            if (el) {
                el.textContent = new Date().getFullYear();
            }
        }

// === Google API & Auth === (Simplified)
function initGoogleApi() {
        console.log('Initialising Google Sign-In and GAPI client...');
        try {
            // Initialize the token client first
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: handleTokenResponse
            });

            // Load the base GAPI client library. This is needed for gapi.client.setToken/getToken.
            // We don't need to init specific APIs like 'sheets' here anymore.
            gapi.load('client', async () => {
                console.log('GAPI client library loaded.');
                // No need for gapi.client.init({apiKey: ..., discoveryDocs: ...}) here
                // unless you use other gapi.client services later.

                // Now that 'client' is loaded, check for saved token
                checkSavedTokenAndProceed();
            });

        } catch (error) {
            handleApiInitError(error);
        }
    }
	
	async function checkSavedTokenAndProceed() {
         const savedToken = localStorage.getItem('gapi_token');
            if (savedToken) {
                const token = JSON.parse(savedToken);
                if (token?.access_token /* && !isTokenExpired(token) */) {
                    try {
                        // gapi.client should be available now
                        gapi.client.setToken(token); // Set token for potential use (like fetchUserInfo originally did)
                        console.log("Using saved token.");
                        await tokenObtained(token); // Process the existing token
                    } catch (e) {
                         console.warn("Error setting saved token even after gapi.load:", e);
                         updateAuthUI(); // Show logged out UI if token can't be set
                         showAppContent();
                    }
                } else {
                    localStorage.removeItem('gapi_token');
                    console.log("Saved token invalid or expired.");
                    updateAuthUI();
                    showAppContent();
                }
            } else {
                 console.log("No saved token found.");
                 updateAuthUI();
                 showAppContent();
            }
    }

    function handleApiInitError(error) { // Keep as is
        console.error('API Initialisation Error:', error);
        showImprovedNotification('error', 'API Load Error', `Failed to load Google services: ${error.message}`);
        updateAuthUI();
        showAppContent();
    }

        // Placeholder for a proper token expiry check if needed
        function isTokenExpired(token) {
            // Implement logic to check token.expires_in or similar field
            return false;
        }

        function handleAuthClick() {
            if (tokenClient) {
                showImprovedNotification('info', 'Signing In', 'Opening Google Sign-In...');
                // Prompt the user to select an account and grant access.
                tokenClient.requestAccessToken({ prompt: 'select_account' });
            } else {
                console.error('Token client not initialised.');
                showImprovedNotification('error', 'Authentication Error', 'Authentication service is not ready. Please try again later.');
            }
        }

        // Callback function after user grants or denies access
        function handleTokenResponse(resp) {
            if (resp.error) {
                console.error('Token response error:', resp);
                let msg = `Authentication failed: ${resp.error}`;
                if (resp.error === 'popup_closed_by_user') msg = 'Sign-in cancelled by user.';
                if (resp.error === 'access_denied') msg = 'Access denied. Please grant permission to proceed.';
                showImprovedNotification('error', 'Authentication Error', msg);
                updateAuthUI();
                showAppContent(); // Ensure content is visible
                return;
            }
            console.log('Access token received.');
			localStorage.setItem('gapi_token', JSON.stringify(resp)); // Save token

        // Ensure gapi.client is loaded before setting token
        if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined') {
            gapi.client.setToken(resp); // Set token for GAPI client
            tokenObtained(resp); // Proceed with obtained token
        } else {
            console.error("handleTokenResponse: gapi.client not ready when token received!");
            // Handle error - perhaps try again after a short delay or show error message
            showImprovedNotification('error', 'Auth Error', 'Failed to process token immediately. Please try reloading.');
        }
        }

        // Called after a token is successfully obtained (new or saved)
        async function tokenObtained(token) {
			console.log("Token available, proceeding...");
			isSignedIn = true;
			// Pass the token object directly to fetchUserInfo
			await fetchUserInfo(token);
			updateAuthUI(); // Update UI to logged-in state
			showAppContent();

            // Check if there's a saved exam state for this user
            const loadedState = JSON.parse(localStorage.getItem(appStateKey) || '{}');
            if (currentUser &&
                loadedState.currentUserEmail === currentUser.email &&
                loadedState.examEndTime &&
                Date.now() < loadedState.examEndTime) {
                console.log("Attempting to restore active exam session.");
                restoreAppState(loadedState); // Try to restore the previous session
            } else if (loadedState.currentUserEmail) {
                console.log("Saved state is invalid or expired for the current user.");
                localStorage.removeItem(appStateKey); // Clear invalid/old state
                saveAppState(); // Save a clean initial state if needed
            }
        }

// Modified to accept token object and use its access_token
    async function fetchUserInfo(tokenObject) { // Accepts token object
        // Use the access_token from the passed object
        const accessToken = tokenObject?.access_token;

        if (!accessToken) {
            console.warn("fetchUserInfo called without a valid access token in tokenObject.");
            // Handle error - maybe sign out?
            // Consider showing an error notification before signing out
            showImprovedNotification('error', 'Auth Error', 'Missing access token. Signing out.');
            handleSignoutClick(); // Force sign out if token is missing
            return;
        }

        console.log('Fetching user information using provided token...');
        try {
            // Use the browser's standard fetch API with the User Info endpoint
            const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                headers: {
                    // Use the access token directly from the function argument
                    'Authorization': `Bearer ${accessToken}`
                }
            });

            // Check if the fetch request itself was successful
            if (!response.ok) {
                // Handle specific errors like 401 Unauthorized (token expired/revoked)
                if (response.status === 401) {
                    console.warn("User Info fetch failed (401 - Unauthorized). Token might be invalid/expired. Signing out.");
                    showImprovedNotification('error', 'Auth Expired', 'Your session has expired. Please sign in again.');
                    handleSignoutClick(); // Force sign out if token is invalid
                    return;
                }
                // Throw an error for other HTTP issues
                throw new Error(`(${response.status}) ${await response.text()}`);
            }

            // Parse the user information from the response
            const userInfo = await response.json();

            // Store the user details in the global currentUser variable
            currentUser = {
                id: userInfo.sub,
                name: userInfo.name || 'N/A',
                email: userInfo.email || 'N/A',
                picture: userInfo.picture || ''
            };
            console.log('User details fetched:', currentUser.email);

            // Update UI elements with the fetched user info
            if (studentNameInput) studentNameInput.value = currentUser.name;
            if (studentEmailInput) studentEmailInput.value = currentUser.email;
            if (userAvatar) userAvatar.src = currentUser.picture;
            if (userName) userName.textContent = currentUser.name;

            // Check admin status based on the fetched email
            isAdmin = ADMIN_EMAILS.includes(currentUser.email);
            document.body.classList.toggle('is-admin', isAdmin);

            // Enable PIN input now that user is signed in and info is fetched
            if (examPinInput) examPinInput.disabled = false;

            // Re-evaluate load button state based on PIN input and online status
            if (loadExamBtn) {
                loadExamBtn.disabled = examPinInput.value.trim() === '' || !isOnline;
            }

        } catch (e) {
            // Handle any errors during the fetch or processing
            console.error('Fetch user info error:', e);
            showImprovedNotification('error', 'User Info Error', `Could not get user details: ${e.message}. Please try signing in again.`);
            currentUser = null; // Clear user info on error
            updateAuthUI(); // Update UI to reflect error state (likely show logged out)
        }
    }

        function handleSignoutClick() {
            console.log("Signing out...");
            const token = localStorage.getItem('gapi_token'); // Get token from storage
		if (token) {
             const parsedToken = JSON.parse(token);
             if(parsedToken?.access_token && typeof google !== 'undefined' && google.accounts?.oauth2) {
                 try {
                     google.accounts.oauth2.revoke(parsedToken.access_token, () => console.log('Token revoked successfully.'));
                 } catch (e) { console.warn("Error revoking token:", e); }
             }
        }
        // Clear token from gapi.client if it exists
        if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined') {
             try { gapi.client.setToken(''); } catch(e) { console.warn("Error clearing gapi token on signout", e);}
        }
        localStorage.removeItem('gapi_token');
        localStorage.removeItem(appStateKey);

            // Reset application state variables
            isSignedIn = false;
            isAdmin = false;
            currentUser = null;
            examDetails = null;
            studentPINEntered = '';
            studentExamIdEntered = '';
            stopTimer(); // Stop any active exam timer

            resetExamState(); // Reset UI to initial state
            updateAuthUI(); // Update UI to logged-out state
            showImprovedNotification('info', 'Signed Out', 'You have been signed out.');
        }


        // === UI State & Reset === (Keep as is)
        function resetExamState() {
            console.log("Resetting UI to initial state.");
            // Hide modules related to active exam
            examStartModule?.classList.add('hidden');
            examDetailsModule?.classList.add('hidden');
            examQuestionsModule?.classList.add('hidden');
            submissionConfirmationModule?.classList.add('hidden');
            studentExamIdGroup?.classList.add('hidden'); // Hide Student ID input

            // Show the initial sign-in prompt if it exists
            signinPromptModule?.classList.remove('hidden');

            // Reset input fields
            if (examPinInput) {
                examPinInput.value = '';
                examPinInput.disabled = true; // Disable until signed in
            }
            if (studentExamIdInput) studentExamIdInput.value = '';
            if (studentNameInput) studentNameInput.value = '';
            if (studentEmailInput) studentEmailInput.value = '';

            // Reset buttons to initial state
            if (loadExamBtn) {
                loadExamBtn.disabled = true;
                loadExamBtn.classList.remove('hidden');
                loadExamBtn.innerHTML = '<i class="fas fa-download"></i> Load Exam';
            }
            if (startExamBtn) startExamBtn.disabled = true;
            if (startExamBtnAlt) {
                startExamBtnAlt.classList.add('hidden');
                startExamBtnAlt.disabled = true;
            }
             if (submitExamBtn) { // Ensure submit button is reset correctly
                 submitExamBtn.disabled = true;
                 submitExamBtn.innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)';
             }

            // Reset header/details display
            const na = 'N/A';
            if (examCodeDisplay) examCodeDisplay.textContent = na;
            if (examDurationDisplay) examDurationDisplay.textContent = na;
            if (examStartTimeDisplay) examStartTimeDisplay.textContent = na;
            if (examNameHeader) examNameHeader.textContent = 'Please sign in to load the exam';
            if (examNameDetail) examNameDetail.textContent = '';
            if (examCourseCodeDetail) examCourseCodeDetail.textContent = '';
            if (examModeDetail) examModeDetail.textContent = '';
            if (examDurationDetail) examDurationDetail.textContent = '';
            if (examStartTimeDetail) examStartTimeDetail.textContent = '';

            // Clear questions area and timer
            if (examQuestionsArea) examQuestionsArea.innerHTML = '<p>Exam questions will appear here...</p>';
            stopTimer();
            if (timerDisplay) timerDisplay.textContent = '--:--';

            // Reset confirmation counts
            totalQuestions = 0;
            confirmedQuestionsCount = 0;
        }


        function updateAuthUI() {
            console.log('Updating Auth UI - SignedIn:', isSignedIn, 'CurrentUser:', !!currentUser);
            document.body.classList.toggle('is-admin', isAdmin);

            if (isSignedIn && currentUser) {
                // Logged-in state
                console.log('Showing logged-in UI.');
                loginContainer.style.display = 'none';
                userContainer.style.display = 'flex';
                signinPromptModule.classList.add('hidden'); // Hide sign-in prompt

                 // Show exam start module only if no exam is active/loaded yet
                 if (examStartModule && !examDetails && examQuestionsModule.classList.contains('hidden')) {
                     examStartModule.classList.remove('hidden');
                 }

                if (examPinInput) examPinInput.disabled = false; // Enable PIN input
                if (loadExamBtn) { // Enable load button if PIN is entered and online
                    loadExamBtn.disabled = examPinInput.value.trim() === '' || !isOnline;
                }

                // Populate user details fields
                if (studentNameInput) studentNameInput.value = currentUser.name || 'N/A';
                if (studentEmailInput) studentEmailInput.value = currentUser.email || 'N/A';
                if (userName) userName.textContent = currentUser.name || '';
                if (userAvatar) userAvatar.src = currentUser.picture || '';
            } else {
                // Logged-out state
                console.log('Showing logged-out UI.');
                loginContainer.style.display = 'flex';
                userContainer.style.display = 'none';
                resetExamState(); // Reset everything to initial logged-out view
                signinPromptModule.classList.remove('hidden'); // Ensure sign-in prompt is visible
            }
        }

        // === Google Sheets Interaction === (READ ONLY NOW)

        // Fetch data from a specified range (Kept for reading exam details/attempts)
        async function getSheetData(spreadsheetId, range) {
            // Check if the Sheets API client is loaded and ready
            if (!gapi?.client?.sheets) {
                 showImprovedNotification('error', 'API Error', 'Google Sheets API client not ready.');
                 console.error("getSheetData called but gapi.client.sheets is not available.");
                 return null;
            }
             // Check for sign-in status (needed for authorization)
             if (!isSignedIn) {
                 showImprovedNotification('error', 'Authentication Error', 'You must be signed in to load data.');
                 console.error("getSheetData called but user is not signed in.");
                 return null;
             }
             if (!isOnline) {
                 showImprovedNotification('warning', 'Offline', 'Cannot fetch data while offline.');
                 return null;
             }

            console.log(`Workspaceing data from: ${spreadsheetId}, Range: ${range}`);
            setSyncing(true); // Indicate network activity
            try {
                const response = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId,
                    range
                });
                console.log(`Successfully fetched data for ${range}.`);
                return response.result.values || []; // Return data rows or empty array
            } catch (err) {
                console.error(`Error fetching ${range}:`, err);
                const errorDetails = err.result?.error;
                showImprovedNotification('error', 'Sheet Read Error', `Could not fetch data: ${errorDetails?.message || err.message} (Code: ${errorDetails?.status})`);
                return null; // Indicate failure
            } finally {
                setSyncing(false); // End network activity indication
            }
        }

        // --- REMOVED: appendSheetData function ---
        // --- REMOVED: updateSheetData function ---


        // === Exam Logic === (Most logic remains, but submission changes)

        // Triggered when the "Load Exam" button is clicked (Keep as is)
        async function handleLoadExam() {
            studentPINEntered = examPinInput.value.trim();
            if (!studentPINEntered) {
                showImprovedNotification('warning', 'Missing PIN', 'Please Get your Exam ID from the attendance sheet.');
                return;
            }
            loadExamBtn.disabled = true;
            loadExamBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';

            await fetchExamDetails(studentPINEntered); // Fetch details FROM BACKEND NOW

            loadExamBtn.disabled = false;
            loadExamBtn.innerHTML = '<i class="fas fa-download"></i> Load Exam';

            if (startExamBtn) startExamBtn.disabled = !examDetails || !isOnline;
            if (startExamBtnAlt) startExamBtnAlt.disabled = !examDetails || !isOnline;
        }

        // Fetches exam configuration from the 'Exams' sheet based on PIN (Keep as is)
    async function fetchExamDetails(pin) {
        showImprovedNotification('info', 'Fetching Exam', `Loading details for PIN: ${pin}...`);
        setSyncing(true);

        examDetails = null; // Reset previous details
        examEndTime = null; // Reset end time

        try {
            const fetchUrl = `${BACKEND_URL}?pin=${encodeURIComponent(pin)}&action=getDetails`; // Ensure action=getDetails is sent if needed
            console.log(`Workspaceing exam details from backend: ${fetchUrl}`);

            const response = await fetch(fetchUrl, { /* ... GET request as before ... */ });

            if (!response.ok) { /* ... handle HTTP errors ... */ }

            const result = await response.json();
            console.log("Backend response (Exam Details):", result);

            if (result.success && result.examData) {
                const fetchedData = result.examData;

                // Validate essential data
                const duration = parseInt(fetchedData.Duration, 10);
                const startTimestampUTC = fetchedData.StartTimestampUTC; // Get the timestamp
                const mode = String(fetchedData.Mode || 'Quiz').trim().toLowerCase();
                const questionsJson = String(fetchedData.Questions || '[]').trim();
                // Keep formatted date/time strings for display if needed
                const startDateStr = String(fetchedData.StartDate || '').trim();
                const startTimeStr = String(fetchedData.StartTime || '').trim();


                if (isNaN(duration) || duration <= 0) throw new Error("Invalid exam duration received from backend.");
                if (typeof startTimestampUTC !== 'number' || isNaN(startTimestampUTC)) {
                    throw new Error("Invalid StartTimestampUTC received from backend.");
                }
                // Basic JSON check for questions
                try { JSON.parse(questionsJson); } catch (e) { throw new Error(`Invalid questions JSON received: ${e.message}`); }


                // --- Calculate exam end time using the UTC timestamp ---
                try {
                    const startTimeFromSheet = startTimestampUTC; // USE THE TIMESTAMP DIRECTLY!
                    const durationMillis = duration * 60 * 1000;
                    examEndTime = startTimeFromSheet + durationMillis; // Calculate end timestamp in UTC ms

                    // Log using the reliable timestamp and formatted strings for clarity
                    console.log(`[TIMER CALC] StartDate: ${startDateStr}, StartTime: ${startTimeStr}, Received Start TS (UTC ms): ${startTimeFromSheet}, Duration(ms): ${durationMillis}, Calculated End TS (UTC ms): ${examEndTime} (${new Date(examEndTime).toLocaleString()})`); // Log local string representation of end time
                } catch (e) {
                    throw new Error(`Could not calculate exam end time: ${e.message}`);
                }


                // Store the loaded exam details
                examDetails = {
                    PIN: fetchedData.PIN,
                    Code: fetchedData.Code,
                    Name: fetchedData.Name,
                    Duration: duration,
                    StartDate: startDateStr, // Keep formatted string for display
                    StartTime: startTimeStr, // Keep formatted string for display
                    Mode: mode,
                    Questions: questionsJson,
                    OriginalOrderMap: null,
                    StartTimestampUTC: startTimestampUTC // Store timestamp if needed elsewhere
                };
                console.log("Exam details processed successfully:", examDetails);

                displayExamDetailsHeader(); // Update header info (uses formatted strings)
                showImprovedNotification('success', 'Exam Loaded', `Details for "${examDetails.Name}" loaded successfully.`);

                     // Adjust UI based on exam mode (same logic as before)
                     if (examDetails.Mode === 'exam') {
                         console.log("Exam Mode detected: Showing Student Exam ID input.");
                         examStartModule.classList.remove('hidden'); studentExamIdGroup.classList.remove('hidden');
                         studentExamIdInput.value = ''; examDetailsModule.classList.add('hidden');
                         startExamBtnAlt.classList.remove('hidden'); startExamBtn.classList.add('hidden');
                         startExamBtn.disabled = true; loadExamBtn.classList.add('hidden');
                         validateStudentExamIdInput();
                     } else { // Quiz Mode
                         console.log("Quiz Mode detected: Showing Exam Information module.");
                         studentExamIdGroup.classList.add('hidden'); studentExamIdInput.value = '';
                         studentExamIdEntered = ''; examStartModule.classList.add('hidden');
                         displayExamDetailsFull(); examDetailsModule.classList.remove('hidden');
                         startExamBtnAlt.classList.add('hidden'); startExamBtn.classList.remove('hidden');
                         startExamBtn.disabled = !isOnline; loadExamBtn.disabled = true;
                         loadExamBtn.classList.remove('hidden');
                     }
                     saveAppState(); // Save the loaded state

                 } else {
                     // Backend reported failure (e.g., PIN not found)
                     throw new Error(result.message || "Exam details not found or backend error.");
                 }

            } catch (error) {
                 console.error(`Error fetching/processing exam details for PIN ${pin}:`, error);
                 showImprovedNotification('error', 'Exam Load Failed', `Could not load exam: ${error.message}`);
                 examDetails = null; // Ensure details are null on error
                 // Reset UI elements if needed
                 examDetailsModule.classList.add('hidden');
                 examStartModule.classList.remove('hidden'); // Show start module for retry
                 if (loadExamBtn) loadExamBtn.disabled = !isOnline;
                 resetExamState(); // Consider full reset on load failure
            } finally {
                setSyncing(false); // End network activity indication
            }
        }


        // Finds the first attempt record matching criteria and specific status
        // Returns { rowNumber, rowData } or null
        // (Kept for checking if already submitted, uses READ-ONLY scope)
         async function findAttemptRecord(email, pin, studentExamId, mode, targetStatus) {
             if ((mode === 'quiz' && !email) || !pin || (mode === 'exam' && !studentExamId)) {
                 console.error("Missing identifiers for finding attempt record. Mode:", mode, "Email:", !!email, "PIN:", !!pin, "ExamID:", !!studentExamId);
                 // Avoid showing notification here, let calling function handle context
                 return null;
             }

             // Fetch columns needed for identification + Status column
             // A=Timestamp, B=Name, C=Email, D=PIN, E=CourseCode, F=StudentExamID, G=Status
             const range = `${EXAM_ATTEMPTS_SHEET_NAME}!A:G`;
             console.log(`Searching for attempt record in ${range} with status '${targetStatus}'... Criteria: PIN=${pin}, Mode=${mode}` + (mode==='exam' ? `, ExamID=${studentExamId}` : `, Email=${email}`));
             const data = await getSheetData(EXAM_SPREADSHEET_ID, range); // Uses read-only now

             if (data === null || data.length <= 1) { // Check if fetch failed or only header exists
                 console.log("No attempt data found or fetch failed.");
                 return null;
             }

             // Iterate through rows (skip header row at index 0)
             for (let i = 1; i < data.length; i++) {
                 const row = data[i];
                 // Check if row has enough columns (A-G = 7 columns)
                 if (row && row.length >= 7) {
                     const sheetEmail = String(row[2] || '').trim().toLowerCase(); // Col C (Index 2)
                     const sheetPin = String(row[3] || '').trim().toLowerCase(); // Col D (Index 3)
                     const sheetStudentExamId = String(row[5] || '').trim(); // Col F (Index 5)
                     const sheetStatus = String(row[6] || '').trim().toLowerCase(); // Col G (Index 6)

                     let match = false;
                     // Check criteria based on mode
                     if (mode === 'quiz' &&
                         sheetEmail === email.toLowerCase() &&
                         sheetPin === pin.toLowerCase()) {
                         match = true;
                     } else if (mode === 'exam' &&
                                sheetStudentExamId === studentExamId && // Match exact student ID
                                sheetPin === pin.toLowerCase()) {
                         match = true;
                     }

                     // If identification criteria match, check the status
                     if (match && sheetStatus === targetStatus.toLowerCase()) {
                         const rowNumber = i + 1; // Sheet rows are 1-based, loop index i is 0-based after header
                         console.log(`Found matching record with status '${targetStatus}' at row ${rowNumber} (data index ${i}).`);
                         return {
                             rowNumber: rowNumber,
                             rowData: row // Return the fetched row data (Cols A-G)
                         };
                     }
                 } else {
                     // Log if a row seems malformed (optional)
                     // console.warn(`Skipping malformed row at index ${i + 1}:`, row);
                 }
             }

             console.log(`No record found matching criteria with status '${targetStatus}'.`);
             return null; // No matching record found
         }

        // Checks if all questions are confirmed and updates the main submit button (Keep as is)
        function checkAllConfirmed() {
            // Only proceed if the questions area is visible and we know the total count
            if (!examQuestionsArea || examQuestionsModule.classList.contains('hidden') || totalQuestions <= 0) {
                if(submitExamBtn) {
                    submitExamBtn.disabled = true;
                    submitExamBtn.innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)';
                }
                return;
            }

            const allConfirmed = confirmedQuestionsCount === totalQuestions;
            console.log(`Confirmed ${confirmedQuestionsCount}/${totalQuestions} questions. All confirmed: ${allConfirmed}`);

            if (submitExamBtn) {
                // Enable button only if all questions are confirmed AND user is online
                // Note: isOnline check might be less critical now if submission retries are handled,
                // but still good to prevent submitting if definitely offline.
                submitExamBtn.disabled = !allConfirmed || !isOnline;

                // Update button text for clarity
                if (allConfirmed && isOnline) {
                    submitExamBtn.innerHTML = '<i class="fas fa-check-circle"></i> Submit Exam Now';
                } else if (!isOnline) {
                     submitExamBtn.innerHTML = '<i class="fas fa-wifi"></i> Submit Exam (Offline)';
                } else {
                     submitExamBtn.innerHTML = `<i class="fas fa-lock"></i> Submit Exam (${confirmedQuestionsCount}/${totalQuestions} Confirmed)`;
                }
            }
        }

        // Validates the 5-character input for Student Exam ID in Exam mode (Keep as is)
        function validateStudentExamIdInput() {
            const startButtonToUse = startExamBtnAlt; // Use the Exam mode start button
            // Ensure button, input, and exam details (in exam mode) exist
            if (!startButtonToUse || !studentExamIdInput || !examDetails || examDetails.Mode !== 'exam') return;

            const idValue = studentExamIdInput.value.trim();
            const isValid = idValue.length === 5; // Simple length check

            // Enable/disable the Exam mode start button based on validity and online status
            startButtonToUse.disabled = !isValid || !isOnline;

            // Visual feedback for the input field
            studentExamIdInput.style.borderColor = (isValid || idValue === '') ? '#ccc' : 'red'; // Red border if invalid and not empty
        }

        // Updates the header section with basic exam details (Keep as is)
        function displayExamDetailsHeader() {
            if (!examDetails) return;
            if (examCodeDisplay) examCodeDisplay.textContent = examDetails.Code || 'N/A';
            if (examDurationDisplay) examDurationDisplay.textContent = `${examDetails.Duration} minutes`;
            const startTimeString = `${examDetails.StartDate || ''} ${examDetails.StartTime || ''}`.trim();
            if (examStartTimeDisplay) examStartTimeDisplay.textContent = startTimeString || 'N/A';
            if (examNameHeader) examNameHeader.textContent = examDetails.Name || 'Exam Loaded';
        }

        // Populates the dedicated "Exam Information" module (Quiz mode) (Keep as is)
        function displayExamDetailsFull() {
            if (!examDetails) return;
            if (examNameDetail) examNameDetail.textContent = examDetails.Name || 'N/A';
            if (examCourseCodeDetail) examCourseCodeDetail.textContent = examDetails.Code || 'N/A';
            // Capitalize mode for display
            const displayMode = examDetails.Mode ? (examDetails.Mode.charAt(0).toUpperCase() + examDetails.Mode.slice(1)) : 'N/A';
            if (examModeDetail) examModeDetail.textContent = displayMode;
            if (examDurationDetail) examDurationDetail.textContent = `${examDetails.Duration} minutes`;
            const startTimeString = `${examDetails.StartDate || ''} ${examDetails.StartTime || ''}`.trim();
            if (examStartTimeDetail) examStartTimeDetail.textContent = startTimeString || 'N/A';
        }


         // Checks if a 'submit' record already exists for this attempt (Keep as is, uses read-only)
async function checkIfAttemptExists(email, pin, studentExamId, mode) {
            console.log("Checking backend for existing 'submit' record...");
            setSyncing(true);
            try {
                // Construct URL parameters for the check
                const params = new URLSearchParams({
                    action: 'checkExists',
                    pin: pin,
                    mode: mode
                });
                if (mode === 'quiz') {
                    params.append('email', email);
                } else if (mode === 'exam') {
                    params.append('studentExamId', studentExamId);
                }

                const fetchUrl = `${BACKEND_URL}?${params.toString()}`;
                console.log(`Checking existence via backend: ${fetchUrl}`);

                const response = await fetch(fetchUrl, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });

                if (!response.ok) {
                    let errorMsg = `Backend check error! Status: ${response.status}`;
                    try { const errorData = await response.json(); errorMsg = errorData.message || errorMsg; } catch (e) {}
                    throw new Error(errorMsg);
                }

                const result = await response.json();
                console.log("Backend check response:", result);

                if (result.success) {
                    return result.exists; // Return true if backend found existing submission, false otherwise
                } else {
                    // Backend reported an error during the check
                    throw new Error(result.message || "Backend error during existence check.");
                }

            } catch (error) {
                console.error('Error checking submission existence via backend:', error);
                showImprovedNotification('error', 'Check Failed', `Could not verify previous submissions: ${error.message}. Assuming none exist.`);
                return false; // Default to false (allow starting) if the check fails, to avoid blocking students unfairly
            } finally {
                setSyncing(false);
            }
        }

        // Triggered when "Start Exam" button (Quiz or Exam mode) is clicked (Keep mostly as is)
async function handleStartExam() {
        if (!examDetails || !currentUser) {
            showImprovedNotification('error', 'Start Error', 'Cannot start the exam. User or exam details are missing.');
            return;
        }

        const currentMode = examDetails.Mode.toLowerCase();
        let identifierForCheck = null; // Variable to hold email or studentExamId

        // Validate and store Student Exam ID if in Exam mode
        if (currentMode === 'exam') {
            const currentStudentExamId = studentExamIdInput.value.trim(); // Read input value
            if (currentStudentExamId.length !== 5) {
                showImprovedNotification('error', 'Invalid ID', 'Please enter the 5-character Student Exam ID.');
                studentExamIdInput.focus(); // Focus the input for correction
                return;
            }
            // Store the validated ID globally AND use it for the check
            studentExamIdEntered = currentStudentExamId;
            identifierForCheck = studentExamIdEntered; // Use the ID for the check
            console.log(`Exam Mode: Using StudentExamID '${identifierForCheck}' for existence check.`);
        } else {
            // Quiz mode: Use email for the check
            studentExamIdEntered = ''; // Ensure global variable is clear for quiz mode
            identifierForCheck = currentUser.email;
             console.log(`Quiz Mode: Using Email '${identifierForCheck}' for existence check.`);
        }

        console.log("Performing pre-start checks...");

        // --- Check if already SUBMITTED (Uses the correct identifier now) ---
        const alreadySubmitted = await checkIfAttemptExists(
            currentUser.email, // Keep passing email for potential logging or future use
            examDetails.PIN,
            identifierForCheck, // Pass the correct identifier (email or studentExamId)
            currentMode
        );
        if (alreadySubmitted) {
            showImprovedNotification('error', 'Already Submitted', `This exam (${examDetails.PIN}) has already been submitted and cannot be retaken.`, 0);
            if (startExamBtn) startExamBtn.disabled = true;
            if (startExamBtnAlt) startExamBtnAlt.disabled = true;
            return; // Stop if already submitted
        }
        // --- End Check ---


        // 2. Check Exam Timing (Keep this check)
        try {
            // ... existing timing check logic ...
            const startTimestampUTC = examDetails.StartTimestampUTC; // Use stored timestamp
            if (!startTimestampUTC || isNaN(startTimestampUTC)) { throw new Error("Start timestamp missing or invalid.");}
            const startTime = startTimestampUTC; // Already in UTC ms

            if (Date.now() < startTime) {
                 showImprovedNotification('error', 'Exam Not Yet Available', `This exam is scheduled to start at ${new Date(startTime).toLocaleString()}. Please wait.`);
                 return;
            }
            if (!examEndTime || isNaN(examEndTime)) { throw new Error("Could not determine the exam end time."); }
            if (Date.now() >= examEndTime) {
                 showImprovedNotification('error', 'Exam Deadline Passed', `The deadline (${new Date(examEndTime).toLocaleString()}) for starting or resuming this exam has passed.`, 0);
                 return;
             }
        } catch (e) {
             console.error("Exam timing check error:", e);
             showImprovedNotification('warning', 'Timing Check Warning', `Could not fully verify exam timing: ${e.message}. Proceeding cautiously.`);
        }

        // Proceed to show questions
        console.log(`Starting ${currentMode} mode. PIN: ${examDetails.PIN}` + (currentMode === 'exam' ? `, Student Exam ID: ${studentExamIdEntered}` : ''));
        confirmedQuestionsCount = 0;
        examStartModule.classList.add('hidden');
        examDetailsModule.classList.add('hidden');
        examQuestionsModule.classList.remove('hidden');
        submissionConfirmationModule.classList.add('hidden');
        displayQuestions(examDetails.Questions);
        startTimer();
        saveAppState();
        checkAllConfirmed();
    }

        // Parses the JSON string and displays questions in the UI (Keep as is)
        function displayQuestions(questionsJsonString) {
            console.log("Parsing and displaying exam questions...");
            examQuestionsArea.innerHTML = ''; // Clear previous questions
            totalQuestions = 0; // Reset count for this display run
            try {
                let questionsArray = [];

                // Robust JSON parsing
                try {
                    questionsArray = JSON.parse(questionsJsonString);
                    if (!Array.isArray(questionsArray)) {
                        throw new Error("Parsed questions data is not an array.");
                    }
                } catch (parseError) {
                     // Fallback if JSON is invalid
                     console.warn("Could not parse questions JSON. Displaying as single block.", parseError);
                     questionsArray = [{ type: "long_answer", prompt: "Exam Instructions / Questions", content: questionsJsonString }];
                 }

                totalQuestions = questionsArray.length; // Store the total number of questions
                console.log(`Total questions loaded: ${totalQuestions}`);

                // **Randomize Question Order**
                 const originalIndices = questionsArray.map((_, index) => index);
                 for (let i = originalIndices.length - 1; i > 0; i--) {
                     const j = Math.floor(Math.random() * (i + 1));
                     [originalIndices[i], originalIndices[j]] = [originalIndices[j], originalIndices[i]];
                 }
                 console.log("Shuffled display order (indices):", originalIndices);

                // Store Original Order Map for submission
                 examDetails.OriginalOrderMap = {};
                 questionsArray.forEach((q, index) => { examDetails.OriginalOrderMap[index] = q; });

                // **Display questions in the shuffled order**
                originalIndices.forEach((originalIndex, displayIndex) => {
                    const q = questionsArray[originalIndex];
                    const displayQNum = displayIndex + 1;
                    const originalQNum = originalIndex + 1;
                    const questionId = `q-${originalQNum}`; // Unique ID for the question container div
                    const answerId = `ans-${originalQNum}`;
                    const answerName = `ans-${originalQNum}`;

                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'question form-group'; // Add 'form-group' if needed for styling
                    questionDiv.id = questionId;
                    questionDiv.dataset.originalIndex = originalIndex;

                    let inputHtml = '';
                    const promptText = q.prompt || `Question ${displayQNum}`;
                    let questionContentHtml = '<div class="question-content">';

                    switch (q.type) {
                        case 'short_answer':
                            questionContentHtml += `<input type="text" id="${answerId}" name="${answerName}" class="form-control" placeholder="Enter your answer">`;
                            break;
                        case 'long_answer':
                            questionContentHtml += `<textarea id="${answerId}" name="${answerName}" class="form-control" rows="5" placeholder="Enter your detailed answer">${q.content || ''}</textarea>`;
                            break;
                        case 'code':
                            const langHint = q.language ? `(${q.language})` : '';
                            questionContentHtml += `<textarea id="${answerId}" name="${answerName}" class="form-control" rows="8" placeholder="Enter your code here ${langHint}" style="font-family: monospace; white-space: pre; overflow-wrap: normal; overflow-x: scroll;"></textarea>`;
                            // Generic note about length limits
                            questionContentHtml += `<small class="length-limit-note">Note: Very long code submissions might have length limitations.</small>`;
                            break;
                        case 'attachment':
                             const allowedTypes = q.allowed_types || []; const acceptAttr = allowedTypes.join(',');
                             const maxSizeMB = q.max_size_mb; const maxBytes = maxSizeMB ? maxSizeMB * 1024 * 1024 : null;
                             questionContentHtml += `<input type="file" id="${answerId}" name="${answerName}" class="form-control" accept="${acceptAttr}" ${maxBytes ? `data-max-size="${maxBytes}"` : ''} data-allowed-types='${JSON.stringify(allowedTypes)}'> <small class="file-helper-text">Allowed: ${acceptAttr || 'any'}${maxSizeMB ? `, Max: ${maxSizeMB}MB` : ''}</small>`;
                             setTimeout(() => addAttachmentValidation(answerId), 0); // Add validation after element is in DOM
                             break;
                        case 'multiple_select':
                             questionContentHtml += `<div class="checkbox-group" id="${answerId}">`;
                             if (Array.isArray(q.options)) {
                                 q.options.forEach((option, optIndex) => {
                                     const optionId = `${answerId}-opt${optIndex}`;
                                     // Use 'form-control-checkbox' for consistency if needed by confirm/edit logic
                                     // Corrected line:
									questionContentHtml += `<div class="checkbox-item"><input type="radio" id="<span class="math-inline">\{optionId\}" name\="</span>{answerName}" value="<span class="math-inline">\{option\}" class\="form\-control\-checkbox"\><label for\="</span>{optionId}">${option}</label></div>`;
                                 });
                             } else { questionContentHtml += `<p style="color:red;">Error: Options missing.</p>`; }
                             questionContentHtml += `</div>`;
                             break;
                        default:
                             questionContentHtml += `<p style="color:red;">Unsupported type: ${q.type}</p><p>${q.content || ''}</p>`;
                    }
                    questionContentHtml += '</div>'; // End question-content

                    // Add Confirm/Edit Buttons
                    const actionsHtml = `<div class="question-actions">
                                          <button type="button" class="btn-confirm btn-orange btn-sm" onclick="confirmAnswer('${questionId}')"><i class="fas fa-check"></i> Confirm</button>
                                          <button type="button" class="btn-edit btn-grey btn-sm" onclick="editAnswer('${questionId}')"><i class="fas fa-pencil-alt"></i> Edit</button>
                                       </div>`;

                    // Assemble the full question block
                    // Ensure the prompt label targets the primary input ID where appropriate
                    const labelTargetId = (q.type === 'multiple_select' || q.type === 'attachment') ? questionId : answerId; // Target group or main input
                    questionDiv.innerHTML = `<label for="${labelTargetId}">${promptText}</label>${questionContentHtml}${actionsHtml}`;

                    examQuestionsArea.appendChild(questionDiv);
                });

            } catch (e) {
                console.error("Error processing or displaying questions:", e);
                examQuestionsArea.innerHTML = `<p style="color:red;">Error loading questions: ${e.message}.</p>`;
                showImprovedNotification('error', 'Question Display Error', `Could not display questions: ${e.message}`);
                if (submitExamBtn) submitExamBtn.disabled = true;
                totalQuestions = 0; // Ensure count is 0 on error
            }
            checkAllConfirmed(); // Initial check after displaying questions or on error
        }


         // Confirms an answer (Keep as is)
        function confirmAnswer(questionId) {
            const questionDiv = document.getElementById(questionId);
            // Ignore if not found or already confirmed to prevent double counting
            if (!questionDiv || questionDiv.classList.contains('confirmed')) return;

            questionDiv.classList.add('confirmed');
            confirmedQuestionsCount++; // Increment count *only when confirming*

            // Disable all relevant input elements within this question
            const inputs = questionDiv.querySelectorAll('.form-control, .form-control-checkbox');
            inputs.forEach(input => { input.disabled = true; });

            console.log(`Confirmed answer for question: ${questionId}`);
            checkAllConfirmed(); // Update overall submit button status
        }

        // Enables editing for an answer (Keep as is)
        function editAnswer(questionId) {
            const questionDiv = document.getElementById(questionId);
            // Ignore if not found or not currently confirmed to prevent incorrect decrement
             if (!questionDiv || !questionDiv.classList.contains('confirmed')) return;

            questionDiv.classList.remove('confirmed');
            confirmedQuestionsCount--; // Decrement count *only when un-confirming*

            // Re-enable all relevant input elements
            const inputs = questionDiv.querySelectorAll('.form-control, .form-control-checkbox');
            inputs.forEach(input => { input.disabled = false; });

            console.log(`Enabled editing for question: ${questionId}`);
            checkAllConfirmed(); // Update overall submit button status
        }


        // Adds validation listeners to file input elements (Keep as is)
        function addAttachmentValidation(inputId) {
            const fileInput = document.getElementById(inputId);
            if (!fileInput || fileInput.type !== 'file') return;

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return; // No file selected

                const maxSize = parseInt(fileInput.getAttribute('data-max-size'), 10);
                const allowedTypes = JSON.parse(fileInput.getAttribute('data-allowed-types') || '[]');

                // Check file size
                if (maxSize && file.size > maxSize) {
                    const maxSizeMB = (maxSize / (1024 * 1024)).toFixed(1);
                    showImprovedNotification('error', 'File Too Large', `The file "${file.name}" (${(file.size / (1024 * 1024)).toFixed(1)}MB) exceeds the maximum allowed size of ${maxSizeMB}MB.`);
                    fileInput.value = ''; // Clear the invalid selection
                    return;
                }

                // Check file type
                if (allowedTypes.length > 0 && !allowedTypes.includes(file.type) && !allowedTypes.includes('.' + file.name.split('.').pop())) {
                    // Check both MIME type and extension as a fallback
                     showImprovedNotification('error', 'Invalid File Type', `The file type of "${file.name}" (${file.type || 'unknown'}) is not allowed. Allowed types: ${allowedTypes.join(', ')}`);
                     fileInput.value = ''; // Clear the invalid selection
                     return;
                 }

                // File is valid (passed checks)
                showImprovedNotification('success', 'File Selected', `Selected file: "${file.name}" (${(file.size / 1024).toFixed(1)}KB)`);
            });
        }

        // Starts the countdown timer (Keep as is)
        function startTimer() {
            if (examTimerInterval) { // Prevent multiple timers
                console.warn("Timer is already running.");
                return;
            }
            // Ensure examEndTime is valid and in the future
            if (!examEndTime || isNaN(examEndTime) || examEndTime <= Date.now()) {
                console.error("Cannot start timer: Invalid or past exam end time.", examEndTime);
                timerDisplay.textContent = "Error";
                // Consider auto-submitting or showing an error message if deadline passed
                if (examEndTime && examEndTime <= Date.now()) {
                    showImprovedNotification('error', 'Deadline Passed', 'The time for this exam has already expired.', 0);
                    handleSubmitExam(true); // Auto-submit if deadline is already passed when starting timer
                }
                return;
            }
            console.log(`Timer starting. Target end time: ${new Date(examEndTime).toLocaleString()}`);
            updateTimerDisplay(); // Initial display update
            examTimerInterval = setInterval(updateTimerDisplay, 1000); // Update every second
        }

        // Updates the timer display every second (Keep as is)
        function updateTimerDisplay() {
            if (!examEndTime) { // Should not happen if startTimer validated, but good safety check
                console.warn("Timer update called without a valid end time.");
                stopTimer();
                timerDisplay.textContent = "--:--";
                return;
            }

            const now = Date.now();
            const timeLeft = Math.max(0, examEndTime - now); // Time remaining in milliseconds

            // Calculate minutes and seconds
            const minutes = Math.floor(timeLeft / (1000 * 60));
            const seconds = Math.floor((timeLeft / 1000) % 60);

            // Format and display the time
            timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

            // Check if time is up
            if (timeLeft <= 0) {
                console.log("Exam time has expired!");
                stopTimer(); // Stop the interval
                showImprovedNotification('warning', "Time's Up!", 'The exam time has expired. Submitting automatically.', 0);
                handleSubmitExam(true); // Trigger automatic submission
            }
        }

        // Stops the countdown timer interval (Keep as is)
        function stopTimer() {
            if (examTimerInterval) {
                clearInterval(examTimerInterval);
                examTimerInterval = null; // Clear the interval ID
                console.log("Timer stopped.");
            }
        }

        // Collects browser/device fingerprint data (basic) (Keep as is)
        function getFingerprintData() {
            const webglFp = getWebglFingerprint();
            const data = {
                // --- Category 1: Basic Browser & Config ---
                ua: navigator.userAgent || 'N/A',
                lang: navigator.language || 'N/A',
                vendor: navigator.vendor || 'N/A',
                cookieEnabled: navigator.cookieEnabled || false,
                doNotTrack: navigator.doNotTrack || 'unknown',
                plugins: Array.from(navigator.plugins || []).map(p => ({ name: p.name, filename: p.filename })).sort((a,b) => a.name.localeCompare(b.name)),
                mimeTypes: Array.from(navigator.mimeTypes || []).map(m => ({ type: m.type, description: m.description })).sort((a,b) => a.type.localeCompare(b.type)),

                // --- Category 2: Hardware / OS ---
                platform: navigator.platform || 'N/A',
                cores: navigator.hardwareConcurrency || undefined,
                memory: navigator.deviceMemory || undefined,
                maxTouchPoints: navigator.maxTouchPoints || 0,

                // --- Category 3: Screen & Display ---
                screenRes: `${screen.width || 0}x${screen.height || 0}x${screen.colorDepth || 0}`,
                availScreenRes: `${screen.availWidth || 0}x${screen.availHeight || 0}`,
                windowInnerSize: `${window.innerWidth || 0}x${window.innerHeight || 0}`,
                timezoneOffset: new Date().getTimezoneOffset(),

                // --- Category 4: GPU Info (from WebGL) ---
                webglAvailable: webglFp.available, // Was WebGL context available?
                webglVendor: webglFp.vendor,       // GPU Vendor string
                webglRenderer: webglFp.renderer,   // GPU Renderer string (often the model)

                // --- Timestamp ---
                ts: Date.now()
            };
            console.log("Collected Fingerprint Data:", data);
            // Return as OBJECT now, will be stringified before sending
            return data;
        }

        // Helper function for WebGL fingerprinting (Keep as is)
        function getWebglFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                // Try both standard and experimental contexts
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    return { available: false, vendor: 'N/A', renderer: 'N/A' }; // WebGL not supported
                }
                // Get debug extension to potentially unmask renderer/vendor info
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                const vendor = gl.getParameter(debugInfo ? debugInfo.UNMASKED_VENDOR_WEBGL : gl.VENDOR);
                const renderer = gl.getParameter(debugInfo ? debugInfo.UNMASKED_RENDERER_WEBGL : gl.RENDERER);
                return {
                    available: true,
                    vendor: vendor || 'unknown',
                    renderer: renderer || 'unknown'
                };
            } catch (e) {
                console.warn("WebGL fingerprinting failed:", e);
                return { available: false, vendor: 'error', renderer: 'error', errorMsg: e.message };
            }
        }

        // Triggers a download of JSON data as a file (Keep as is, useful backup)
        function downloadJsonBackup(data, filename) {
            try {
                const jsonString = JSON.stringify(data, null, 2); // Pretty-print JSON
                const blob = new Blob([jsonString], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename; // Set the download filename
                document.body.appendChild(link); // Append link to body
                link.click(); // Programmatically click the link to trigger download
                document.body.removeChild(link); // Remove link from body
                URL.revokeObjectURL(url); // Release the object URL
                console.log("JSON backup download initiated:", filename);
                showImprovedNotification('info', 'Backup Saved', 'A JSON backup file of your submission has been downloaded.');
            } catch (e) {
                console.error("Error creating or triggering JSON backup download:", e);
                showImprovedNotification('error', 'Backup Error', 'Could not create the backup file. Please manually copy your answers if needed.');
            }
        }


        // --- MODIFIED: handleSubmitExam ---
        // Handles the final exam submission process by sending data to the backend
        async function handleSubmitExam(isAutoSubmit = false) {
            const timeIsUp = examEndTime && Date.now() >= examEndTime;
            if (timeIsUp && !isAutoSubmit) {
                 console.warn("Manual submit clicked after deadline. Treating as auto-submit.");
                 showImprovedNotification('warning', 'Deadline Passed', 'Time expired. Submitting automatically.');
                 isAutoSubmit = true;
             }

            stopTimer(); // Stop the timer immediately

            // Disable submit button and show submitting state (always)
            submitExamBtn.disabled = true;
            submitExamBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';

            // --- Mandatory Confirmation Check for MANUAL submit ---
            if (!isAutoSubmit) {
                if (confirmedQuestionsCount !== totalQuestions) {
                    showImprovedNotification('error', 'Not All Confirmed', `Please confirm all ${totalQuestions} questions before submitting. You have confirmed ${confirmedQuestionsCount}.`, 5000);
                    // Do not re-enable timer here, just update button state
                    checkAllConfirmed(); // This will keep it disabled but update text
                    return; // Stop submission
                }
                // If all confirmed manually, ask for final user confirmation
                if (!confirm("You have confirmed all answers. Are you absolutely sure you want to submit your exam?\nThis action cannot be undone.")) {
                     checkAllConfirmed(); // Re-enable button if online/all confirmed
                     // Restart timer only if time still remains
                     if (examEndTime && Date.now() < examEndTime) { startTimer(); }
                     return; // Abort submission
                 }
            }
            // --- End Manual Confirmation Check ---

            console.log("Processing submission..." + (isAutoSubmit ? " (Auto)" : " (Manual - All Confirmed)"));
            const answers = {}; // Object to hold answers
            const fingerprintObject = getFingerprintData(); // Get fingerprint OBJECT

            // Collect Answers - respecting ORIGINAL order AND confirmation status for auto-submit
            if (!examDetails || !examDetails.OriginalOrderMap || totalQuestions <= 0) {
                showImprovedNotification('error', 'Submission Error', 'Cannot collect answers. Exam data or question count is invalid.', 0);
                checkAllConfirmed(); // Reset button state
                return;
            }

            const originalIndices = Object.keys(examDetails.OriginalOrderMap).map(Number).sort((a, b) => a - b);
            originalIndices.forEach(originalIndex => {
                const originalQNum = originalIndex + 1;
                const questionData = examDetails.OriginalOrderMap[originalIndex];
                const answerName = `ans-${originalQNum}`;
                const questionDivId = `q-${originalQNum}`;
                const questionDiv = document.getElementById(questionDivId);
                // Check confirmation status *reliably*
                const isConfirmed = questionDiv ? questionDiv.classList.contains('confirmed') : false;

                // For AUTO submit, ONLY collect CONFIRMED answers.
                // For MANUAL submit, collect ALL (we already checked they are all confirmed).
                if (isAutoSubmit && !isConfirmed) {
                    answers[answerName] = "[NOT CONFIRMED]"; // Mark unconfirmed answers explicitly
                    console.log(`Auto-submit: Answer for ${answerName} was not confirmed.`);
                } else {
                    // Collect answer normally (manual submit OR confirmed auto-submit)
                    const formElementsWithName = examForm.elements[answerName];
                    if (formElementsWithName) {
                        switch (questionData.type) {
                            case 'attachment':
                                const fileInput = formElementsWithName;
                                // Handle file uploads - Backend needs logic to actually receive the file if needed.
                                // For now, just send the filename as a placeholder.
                                answers[answerName] = (fileInput.files && fileInput.files.length > 0)
                                    ? `FILE_UPLOADED:${fileInput.files[0].name}` // Placeholder for backend
                                    : '';
                                break;
                            case 'multiple_select':
                                const checkboxes = Array.isArray(formElementsWithName) ? formElementsWithName : [formElementsWithName];
                                answers[answerName] = checkboxes.filter(cb => cb.checked).map(cb => cb.value);
                                break;
                            default: // short_answer, long_answer, code
                                // Ensure element has a 'value' property (e.g., not a fieldset)
                                answers[answerName] = (typeof formElementsWithName.value !== 'undefined') ? formElementsWithName.value : 'ERROR_NO_VALUE_PROP';
                                break;
                        }
                    } else {
                        console.warn(`Could not find form element for answer: ${answerName}`);
                        answers[answerName] = 'ERROR_ELEMENT_NOT_FOUND';
                    }
                }
            });


            // --- Create Backup Data --- (Keep this local backup)
             const backupData = {
                 submissionTimestamp: new Date().toISOString(),
                 examDetails: { PIN: examDetails?.PIN, Name: examDetails?.Name, Mode: examDetails?.Mode, Code: examDetails?.Code },
                 studentInfo: { pinEntered: studentPINEntered, studentExamId: examDetails?.Mode === 'exam' ? studentExamIdEntered : undefined, name: currentUser?.name, email: currentUser?.email },
                 answers: answers, // Keep raw answers object
                 fingerprint: fingerprintObject, // Keep parsed object
                 submittedLate: timeIsUp,
                 autoSubmitted: isAutoSubmit, // Flag if it was an auto-submit
                 confirmedCountOnSubmit: confirmedQuestionsCount, // Record how many were confirmed
                 totalQuestionsOnSubmit: totalQuestions // Record total questions
             };
             const backupFilename = `exam_backup_${examDetails?.PIN || 'unknown'}_${(currentUser?.email || studentExamIdEntered || 'anon').replace(/@.*/, '')}_${Date.now()}.json`;
             downloadJsonBackup(backupData, backupFilename);

            // --- Prepare data payload for the backend ---
            const submissionData = {
                timestamp: backupData.submissionTimestamp, // Use consistent timestamp
                pin: examDetails?.PIN,
                courseCode: examDetails?.Code,
                mode: examDetails?.Mode,
                // Include identifiers based on mode
                studentEmail: (examDetails?.Mode === 'quiz' ? currentUser?.email : undefined),
                studentName: (examDetails?.Mode === 'quiz' ? currentUser?.name : undefined),
                studentExamId: (examDetails?.Mode === 'exam' ? studentExamIdEntered : undefined),
                answers: answers, // The collected answers object
                fingerprint: fingerprintObject, // Send parsed fingerprint object
                isAutoSubmit: isAutoSubmit, // Let backend know if it was auto
                timeIsUp: timeIsUp     // Let backend know if time was up
            };

            // --- Send data to Backend using Fetch ---
            let submissionSuccess = false;
            try {
                console.log(`Sending data to backend: ${BACKEND_URL}`);
                const response = await fetch(BACKEND_URL, {
                    method: 'POST',
                    mode: 'no-cors', // Simpler, but hides response details. Change to 'cors' if backend handles it.
                    headers: {
                        // 'Content-Type': 'application/json', // Not needed with Blobs/FormData or text/plain for Apps Script simple POST
                        'Content-Type': 'text/plain;charset=utf-8', // Required for Apps Script e.postData.contents
                    },
                    // Send data within a 'submission' object, stringified
                    body: JSON.stringify({ submission: submissionData })
                });

                // NOTE: With mode: 'no-cors', we CANNOT reliably check response.ok or response.status here.
                // We assume success if the fetch promise resolves without a network error.
                // The real confirmation is seeing the data appear in the Sheet.
                console.log("Fetch request sent to backend (response status hidden due to no-cors).");
                submissionSuccess = true; // Assume success after sending

                 /* // If using mode: 'cors' and backend returns JSON:
                 if (!response.ok) {
                     let errorMsg = `Backend error! Status: ${response.status}`;
                     try { const errorData = await response.json(); errorMsg += ` - ${errorData.message || 'Unknown error'}`; } catch (e) {}
                     throw new Error(errorMsg);
                 }
                 const result = await response.json();
                 console.log('Backend response:', result);
                 submissionSuccess = result.success; // Check success flag from backend
                 if (!submissionSuccess) {
                    showImprovedNotification('error', 'Submission Failed', `Backend reported: ${result.message || 'Unknown error'} (backup downloaded).`, 0);
                 }
                 */

            } catch (error) {
                console.error('Error submitting data to backend:', error);
                showImprovedNotification('error', 'Submission Error', `Could not send submission: ${error.message}. A backup file was downloaded.`, 0);
                submissionSuccess = false; // Explicitly set failure
            }

            // --- Final UI Update based on assumed/checked success ---
            if (submissionSuccess) {
                showImprovedNotification('success', 'Exam Submitted Successfully!', `Your submission has been sent.`, 0);
                examQuestionsModule.classList.add('hidden');
                submissionConfirmationModule.classList.remove('hidden');
                localStorage.removeItem(appStateKey); // Clear state on successful send
                // Reset state variables fully
                examDetails = null;
                studentPINEntered = ''; studentExamIdEntered = ''; examEndTime = null; totalQuestions = 0; confirmedQuestionsCount = 0;
            } else {
                 // Error notifications were already shown in the catch block or CORS success check
                 console.error("Online submission failed after backup.");
                 // Re-enable button ONLY if manual submit failed, allowing retry
                 if (!isAutoSubmit) {
                     checkAllConfirmed(); // Update button state (might remain disabled if offline)
                 } else {
                     showImprovedNotification('error', 'Auto-Submit Failed', 'Could not automatically send submission online. Backup downloaded.', 0);
                     // Keep button disabled for auto-submit failure
                 }
            }
        }

        // --- REMOVED: recordExamAttempt function ---


        // Updates online status and related UI elements (Keep as is)
        function updateOnlineStatus() {
            isOnline = navigator.onLine;
            console.log('Connection Status:', isOnline ? 'Online' : 'Offline');
            const statusIcon = syncStatus?.querySelector('i');

            if (isOnline) {
                syncStatus.className = 'sync-status online';
                if (statusIcon) statusIcon.style.color = 'var(--success-color)';
                if (syncText) syncText.textContent = 'Online';
            } else {
                syncStatus.className = 'sync-status offline';
                if (statusIcon) statusIcon.style.color = 'var(--warning-color)';
                if (syncText) syncText.textContent = 'Offline';
                if (!isInitializing) {
                    showImprovedNotification('warning', 'Offline', 'You are currently offline. Features requiring connection may be limited.', 5000);
                }
            }

            if (statusIcon && !isSyncing) { // Reset icon if not syncing
                statusIcon.className = 'fas fa-circle';
                if(isOnline) statusIcon.style.color = 'var(--success-color)'; else statusIcon.style.color = 'var(--warning-color)';
            }


            // Update button states based on online status
            if (loadExamBtn) {
                 loadExamBtn.disabled = !isOnline || !isSignedIn || (examPinInput && examPinInput.value.trim() === '');
             }
             let startDisabled = !isOnline || !isSignedIn || !examDetails;
             const isExamModeActive = examDetails && examDetails.Mode === 'exam';
             if (isExamModeActive) {
                 startDisabled = startDisabled || (studentExamIdInput && studentExamIdInput.value.trim().length !== 5);
                 if (startExamBtnAlt) startExamBtnAlt.disabled = startDisabled;
                 if (startExamBtn) startExamBtn.disabled = true;
             } else {
                 if (startExamBtn) startExamBtn.disabled = startDisabled;
                 if (startExamBtnAlt && examDetails) startExamBtnAlt.classList.add('hidden');
            }

            // Let checkAllConfirmed handle the submit button state considering online status
            checkAllConfirmed();

            if (isInitializing && (typeof gapi !== 'undefined')) {
                isInitializing = false;
                console.log("Initialisation process complete.");
            }
        }

        // Updates the sync status indicator UI (Still useful for Reads)
        function setSyncing(syncing) {
            isSyncing = syncing;
            console.log("Network Syncing:", isSyncing);
            const statusIcon = syncStatus?.querySelector('i');
            if (statusIcon) {
                if (syncing) {
                    statusIcon.className = 'fas fa-spinner fa-spin'; // Spinning icon
                    statusIcon.style.color = 'var(--info-color)'; // Use info color for syncing
                    if (syncText) syncText.textContent = 'Syncing...';
                } else {
                    // Revert to online/offline status display
                    updateOnlineStatus(); // This will set the correct icon/text/color
                }
            }
        }

        // Displays dismissible notifications at the bottom-right (Keep as is)
        function showImprovedNotification(type, title, message, duration = 5000) {
            const container = notificationArea;
            if (!container) {
                console.error("Notification container element not found in the DOM.");
                return; // Cannot display notification
            }

            // Create notification element
            const notification = document.createElement('div');
            notification.className = `in-page-notification in-page-notification-${type}`; // Base + type class

            // Determine icon based on type
            let iconClass;
            switch (type) {
                case 'success': iconClass = 'fa-check-circle'; break;
                case 'error':   iconClass = 'fa-times-circle'; break;
                case 'warning': iconClass = 'fa-exclamation-triangle'; break;
                default:        iconClass = 'fa-info-circle'; // Default to info
            }

            // Set inner HTML with icon, title, message, and close button
            notification.innerHTML = `<i class="fas ${iconClass} fa-icon"></i>
                                      <div class="notification-content"><strong>${title}</strong><br>${message.replace(/\n/g, '<br>')}</div>
                                      <button type="button" class="notification-close" aria-label="Close">&times;</button>`;

            container.appendChild(notification); // Add to the DOM

            // Get close button and add click listener for manual dismissal
            const closeBtn = notification.querySelector('.notification-close');
            const removeNotification = () => {
                notification.classList.add('removing'); // Add class to trigger slide-out animation
                // Remove the element after the animation completes
                setTimeout(() => {
                    // Check if parentNode still exists before removing
                    if (notification.parentNode) {
                         notification.parentNode.removeChild(notification);
                    }
                }, 300); // Match timeout to CSS animation duration
            };

            closeBtn?.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                removeNotification();
            });

            // Auto-dismiss after duration (if duration > 0)
            if (duration > 0) {
                setTimeout(removeNotification, duration);
            }
        }

        // === State Persistence === (Keep as is, still useful for resuming sessions)

        // Saves the current relevant state to localStorage
        function saveAppState() {
             // Only save state if an exam is actively loaded or in progress
            if (!examDetails || (examQuestionsModule && examQuestionsModule.classList.contains('hidden') && !submissionConfirmationModule.classList.contains('hidden'))) {
                 // Don't save if no exam loaded, or if exam is finished (confirmation shown)
                 // If questions module is hidden but confirmation is also hidden, it means we are in setup phase, safe to save.
                 if (examQuestionsModule && examQuestionsModule.classList.contains('hidden') && submissionConfirmationModule.classList.contains('hidden')) {
                     // Proceed to save setup state (PIN entered etc.)
                 } else {
                    console.log("Not saving state: Exam not active or already submitted.");
                    // Consider explicitly clearing state if submission occurred but wasn't cleared?
                    // localStorage.removeItem(appStateKey);
                    return;
                 }
             }

            try {
                const state = {
                    // Auth info
                    isSignedIn: isSignedIn,
                    currentUserEmail: currentUser?.email, // Save email to match state to user

                    // Exam progress info
                    examDetails: examDetails, // Includes PIN, Mode, Questions JSON, OriginalOrderMap etc.
                    studentPINEntered: studentPINEntered, // PIN used to load this exam
                    studentExamIdEntered: studentExamIdEntered, // Student ID if Exam mode
                    examEndTime: examEndTime, // Crucial for resuming timer
                    // Potentially save current answers periodically here if needed (more complex)
                    // currentAnswers: collectCurrentAnswers() // Example placeholder
                };
                localStorage.setItem(appStateKey, JSON.stringify(state));
                console.log("Application state saved to localStorage.");
            } catch (e) {
                console.error("Error saving application state to localStorage:", e);
                // Handle potential storage limits or errors
            }
        }

        // Loads state from localStorage on initial page load
        function loadAppState() {
            const savedStateString = localStorage.getItem(appStateKey);
            if (!savedStateString) {
                console.log("No saved application state found in localStorage.");
                return; // Nothing to load
            }
            try {
                const state = JSON.parse(savedStateString);
                console.log("Found saved application state:", state);
                // **Important:** Don't automatically apply the state here.
                // The `tokenObtained` function will check this loaded state against the
                // *currently signed-in user* before deciding whether to restore it.
                // This prevents loading User A's state if User B signs in.
                // We just load it here so it's available for that check later.
            } catch (e) {
                console.error("Error parsing saved application state from localStorage:", e);
                localStorage.removeItem(appStateKey); // Clear corrupted state
            }
        }

        // Restores the application UI and state based on loaded data (called after user signs in and state matches)
        function restoreAppState(state) {
            console.log("Restoring application state...");
            // Restore key state variables
            examDetails = state.examDetails;
            studentPINEntered = state.studentPINEntered;
            studentExamIdEntered = state.studentExamIdEntered;
            examEndTime = state.examEndTime;

             // Validate restored end time
             if (!examEndTime || isNaN(examEndTime) || Date.now() >= examEndTime) {
                 console.warn("Restored exam state has expired or end time is invalid. Clearing state.");
                 localStorage.removeItem(appStateKey); // Clear expired state
                 resetExamState(); // Reset UI
                 showImprovedNotification('warning', 'Session Expired', 'Your previous exam session has expired.', 0);
                 return; // Stop restoration
             }


             showImprovedNotification('info', 'Exam Session Restored', 'Resuming your previous exam session.', 5000);

             // --- Rebuild UI to match the restored state ---
             // Hide setup modules
             signinPromptModule.classList.add('hidden');
             examStartModule.classList.add('hidden');
             examDetailsModule.classList.add('hidden');
             submissionConfirmationModule.classList.add('hidden');

             // Show questions module
             examQuestionsModule.classList.remove('hidden');

             // Display header info
             displayExamDetailsHeader();

             // Display the questions (will handle randomization based on stored map if needed)
             // Ensure the OriginalOrderMap exists before displaying
             if (examDetails && examDetails.Questions && examDetails.OriginalOrderMap) {
                 displayQuestions(examDetails.Questions);
                 // **TODO (Optional but Recommended):** Implement logic here to refill answers
                 // based on `state.currentAnswers` if you added periodic saving.
                 // Example: populateRestoredAnswers(state.currentAnswers);
             } else {
                  console.error("Cannot restore questions display: Missing Questions or Order Map in saved state.");
                   showImprovedNotification('error', 'Restore Failed', 'Could not restore exam questions. State might be corrupted.', 0);
                   localStorage.removeItem(appStateKey);
                   resetExamState();
                   return;
             }


             // Restart the timer
             startTimer();

             // Ensure submit button is enabled (subject to online status)
             checkAllConfirmed(); // Let this function handle button state based on confirms/online

             console.log("Application state restored successfully.");
         }

    </script>

</body>
</html>