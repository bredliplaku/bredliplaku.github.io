<!DOCTYPE html>
<html lang="en-GB"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Exam Portal</title>
    <link rel="icon" type="image/png" href="https://bredliplaku.github.io/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
 <style>
        /* --- CSS --- */
        :root {
            --primary-color: #3949ab;
            --primary-dark: #1a237e;
            --success-color: #43a047;
            --warning-color: #fb8c00;
            --info-color: #2196F3;
            --danger-color: #f44336;
            --text-light: #fff;
            /* Define variables for confirmed state for easy adjustment */
            --confirmed-bg: #f0f0f0; /* Light background for confirmed inputs */
            --confirmed-text: transparent; /* Make text invisible */
            --confirmed-opacity: 0.1; /* Very low opacity */
            --confirmed-border: #e0e0e0; /* Lighter border */
            --confirmed-placeholder: transparent; /* Hide placeholder */
        }
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body, html {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            background: #ffffff;
            color: #333;
        }
        .container {
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
        }
        .app-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }
        .app-loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loading-spinner {
            border: 5px solid rgba(57, 73, 171, 0.2);
            border-top: 5px solid #3949ab;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0%   { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .content-hidden {
            visibility: hidden;
            opacity: 0;
        }
        .content-visible {
            visibility: visible;
            opacity: 1;
            transition: opacity 0.5s ease-in;
        }
        .app-header {
            background: linear-gradient(135deg, #3949ab, #1a237e);
            color: white;
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2.0em;
            display: flex;
            align-items: center;
        }
        h1 i {
            margin-right: 10px;
        }
        h2 {
            margin: 0 0 2px 0;
            font-weight: 400;
            font-size: 1.0em;
        }
        .app-info {
            display: flex;
            flex-wrap: wrap;
            margin-top: 15px;
            gap: 10px;
        }
        .info-item {
            background-color: rgba(255,255,255,0.1);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9em;
            line-height: 30px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        .module {
            background-color: #fff;
            border-radius: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            overflow: hidden;
        }
        .module-header {
            background-color: #3949ab;
            color: white;
            padding: 15px;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .module-title {
            font-size: 1.1em;
            display: flex;
            align-items: center;
        }
        .module-title i {
            margin-right: 10px;
        }
        .module-content {
            padding: 20px;
        }
        .not-signed-in-message {
            text-align: center;
            padding: 20px;
            margin-top: 15px;
            border-radius: 15px;
            background-color: rgba(57, 73, 171, 0.1);
            color: #333;
        }
        button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background-color: var(--primary-color);
            color: var(--text-light);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            transition: background-color 0.3s, transform 0.3s, opacity 0.3s;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 0;
            cursor: pointer;
        }
        /* Apply hover only when button is not disabled */
        button:hover:not(:disabled) {
            background-color: var(--primary-dark);
            transform: scale(1.05);
        }
        button:disabled {
            background-color: #aaa;
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .btn-green {
            background-color: var(--success-color);
        }
        .btn-blue {
            background-color: var(--info-color);
        }
        .btn-orange {
             background-color: var(--warning-color);
        }
        .btn-grey {
             background-color: #6c757d;
        }
        .btn-sm {
            padding: 6px 12px;
            font-size: 0.85em;
            border-radius: 15px;
        }
        .in-page-notifications {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            width: 350px;
            max-width: 90%;
            pointer-events: none;
        }
        .in-page-notification {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: slide-in 0.3s ease-out forwards;
            overflow: hidden;
            display: flex;
            align-items: center;
            opacity: 1;
            transition: transform 0.3s ease-in, opacity 0.3s ease-in;
            pointer-events: auto;
        }
        .in-page-notification.removing {
            opacity: 0;
            transform: translateX(100%);
        }
        @keyframes slide-in {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .in-page-notification i.fa-icon {
            margin-right: 10px;
            font-size: 1.2em;
            flex-shrink: 0;
        }
        .notification-content {
            flex-grow: 1;
        }
        .notification-close {
            background: none;
            border: none;
            font-size: 20px;
            line-height: 1;
            color: inherit;
            opacity: 0.7;
            padding: 0 5px;
            margin-left: 10px;
            cursor: pointer;
        }
        .notification-close:hover {
            opacity: 1;
        }
        .in-page-notification-info {
            background-color: #e3f2fd;
            color: #0d47a1;
        }
        .in-page-notification-warning {
            background-color: #fff3e0;
            color: #e65100;
        }
        .in-page-notification-error {
            background-color: #ffebee;
            color: #b71c1c;
        }
        .in-page-notification-success {
            background-color: #e8f5e9;
            color: #1b5e20;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label { /* Labels for inputs like Name, Email, PIN */
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .form-control { /* Base style for text inputs, textareas */
            width: 100%;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
            transition: opacity 0.3s, background-color 0.3s, color 0.3s, border-color 0.3s;
            background-color: #fff;
            color: #333;
            opacity: 1;
        }
        /* Basic disabled style - often overridden by .confirmed */
        input:disabled, textarea:disabled {
            background-color: #eee;
            cursor: not-allowed;
            opacity: 0.7;
        }
        textarea.form-control {
            min-height: 100px;
        }
    .footer {
        max-width: 1000px;
        text-align: center;
        padding: 20px 0;
        color: var(--primary-dark);
        border-radius: 20px;
        margin-left: auto;
        margin-right: auto;
        -webkit-user-select: none;
        -khtml-user-select: none;
    }
    
    .social-links {
        margin-bottom: 10px;
        margin-top: 10px;
    }
    
    .social-links a {
        color: var(--primary-dark);
        font-size: 1.0em;
        margin: 0 10px;
        transition: color 0.3s;
    }
    
    .social-links a:hover {
        color: var(--secondary-color);
    }
        .auth-container {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
        }
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
        }
        .sync-auth-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .sync-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .sync-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9em;
        }
        .sync-status.online i {
            color: var(--success-color);
        }
        .sync-status.offline i {
            color: var(--warning-color);
        }
        #exam-details-display p {
            margin: 8px 0;
        }
        #exam-details-display strong {
            color: var(--primary-dark);
            margin-right: 5px;
        }
        #exam-questions-area {
            margin-top: 20px;
            padding: 20px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 10px;
        }
        #exam-questions-area .question {
            margin-bottom: 25px;
            padding: 20px;
            border-bottom: 1px dashed #ddd;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
             /* Add transition for smoother background change on confirm */
             /* transition: background-color 0.3s; */
        }
        #exam-questions-area .question:last-child {
            border-bottom: none;
        }
        /* Style for the question prompt label */
        #exam-questions-area .question > label {
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
            cursor: default; /* Ensure label isn't confusingly clickable */
        }
        #exam-questions-area .question-content {
             margin-bottom: 15px;
        }
        #exam-questions-area .question-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: flex-end;
        }

        /* --- Enhanced Styling for Confirmed State --- */
        .question.confirmed {
             background-color: #fafafa; /* Slightly off-white background for the whole block */
        }

        /* Style inputs/textareas/checkbox items when confirmed */
        .question.confirmed .form-control, /* Targets text inputs, textareas, file inputs with this class */
        .question.confirmed .checkbox-item { /* Targets the wrapper for each checkbox+label */
            opacity: var(--confirmed-opacity) !important; /* Use variable, !important might be needed */
            background-color: var(--confirmed-bg) !important; /* Use variable */
            color: var(--confirmed-text) !important; /* Use variable (transparent) */
            text-shadow: none !important; /* Remove any text shadow */
            pointer-events: none !important; /* Disable all mouse interactions */
            cursor: default !important; /* Standard cursor */
            border-color: var(--confirmed-border) !important; /* Use variable */
        }

        /* Ensure text placeholders also become invisible */
         .question.confirmed .form-control::placeholder {
             color: var(--confirmed-placeholder) !important; /* Use variable */
             opacity: 1 !important; /* Keep placeholder opacity high if needed */
         }

        /* Ensure labels next to checkboxes are also affected */
        .question.confirmed .checkbox-item label {
             color: var(--confirmed-text) !important; /* Make label text transparent */
             cursor: default !important;
             opacity: 0.2 !important; /* Slightly visible background effect perhaps */
        }

         /* Ensure checkbox itself looks disabled and blends */
         .question.confirmed .form-control-checkbox { /* Target the checkbox input specifically if needed */
             cursor: default !important;
             opacity: var(--confirmed-opacity) !important; /* Match opacity */
         }
        /* --- End Enhanced Styling for Confirmed State --- */


        /* --- Button Visibility Rules --- */
        /* Hide edit button by default */
        .btn-edit {
            display: none;
         }

        /* Show edit button when confirmed */
        .question.confirmed .btn-edit {
            display: inline-flex; /* Use inline-flex to match button styles */
        }

        /* Hide confirm button when confirmed */
        .question.confirmed .btn-confirm {
            display: none;
        }
        /* --- End Button Visibility Rules --- */


        /* --- Multiple Select Checkbox Styling --- */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            transition: opacity 0.3s, background-color 0.3s, color 0.3s;
            padding: 5px;
            border-radius: 4px;
        }
        /* Style the checkbox input itself */
        .checkbox-item input[type="checkbox"].form-control-checkbox {
            margin-right: 8px;
            cursor: pointer;
            width: 18px;
            height: 18px;
            flex-shrink: 0; /* Prevent checkbox from shrinking */
            transition: opacity 0.3s; /* Add transition */
        }
         /* Style the label associated with the checkbox */
         .checkbox-item label {
             margin-bottom: 0;
             font-weight: normal;
             cursor: pointer;
             flex-grow: 1;
             transition: color 0.3s; /* Add transition */
         }
        /* --- End Checkbox Styling --- */


        #submit-exam-btn {
            margin-top: 30px;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
        }
        .hidden {
            display: none !important;
        }
        #timer-display {
            font-weight: bold;
        }
        .confirmation-message {
            text-align: center;
            font-weight: bold;
            color: var(--success-color);
            padding: 30px;
            font-size: 1.2em;
        }
        .file-helper-text {
            display: block;
            margin-top: 5px;
            color: #666;
            font-size: 0.85em;
        }
        .length-limit-note { /* Style for the code length note */
            display: block;
            margin-top: 5px;
            color: #757575;
            font-size: 0.8em;
            font-style: italic;
        }
        @media (max-width: 768px) {
            .sync-auth-container {
                flex-direction: column-reverse;
                align-items: flex-end;
                gap: 10px;
                border-bottom: none;
            }
            .auth-container,
            .sync-container {
                width: 100%;
                justify-content: flex-end;
            }
            .in-page-notifications {
                width: 90%;
                left: 50%;
                transform: translateX(-50%);
            }
        }
    </style>
</head>
<body class="content-hidden">
    <div id="app-loading" class="app-loading">
        <img src="https://raw.githubusercontent.com/bredliplaku/bredliplaku.github.io/refs/heads/main/loading.gif" alt="Loading..." style="width: 150px; height: 150px;">
        <div style="margin-top: 10px; font-size: 14px; color: #666;">Loading Exam Portal...</div>
    </div>
    <div class="container" id="main-container">
        <div class="sync-auth-container">
            <div class="sync-container">
                 <div id="sync-status" class="sync-status offline">
                    <i class="fas fa-circle"></i>
                    <span id="sync-text">Offline</span>
                </div>
            </div>
            <div class="auth-container">
                 <div id="login-container">
                    <button id="login-btn" class="btn-blue">
                        <i class="fas fa-sign-in-alt"></i> Sign in
                    </button>
                </div>
                <div id="user-container" style="display: none">
                    <div class="user-info">
                        <img id="user-avatar" class="user-avatar" src="" alt="Avatar">
                        <span id="user-name"></span>
                         <button id="logout-btn" class="btn-sm">
                            <i class="fas fa-sign-out-alt"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <div class="app-header">
            <h1><i class="fa-solid fa-clipboard-question"></i> Exam Portal</h1>
            <h2 id="exam-name-header">Enter PIN to load exam</h2>
            <div class="app-info">
                <span class="info-item">
                     <i class="fas fa-barcode"></i> Course:
                    <span id="exam-code-display">N/A</span>
                </span>
                <span class="info-item">
                    <i class="fas fa-stopwatch"></i> Duration:
                     <span id="exam-duration-display">N/A</span>
                </span>
                <span class="info-item">
                    <i class="fas fa-calendar-alt"></i> Start Time:
                    <span id="exam-start-time-display">N/A</span>
                 </span>
            </div>
        </div>
        <div id="in-page-notification-area" class="in-page-notifications"></div>
        <div id="signin-prompt-module" class="module">
            <div class="module-content not-signed-in-message">
                <h3><i class="fas fa-info-circle"></i> Welcome</h3>
                <p>Sign in with your University Google Account.</p>
            </div>
        </div>
        <div id="exam-start-module" class="module hidden">
            <div class="module-header">
                <span class="module-title">
                    <i class="fas fa-user-check"></i> Student Details &amp; Exam Access
                </span>
            </div>
            <div class="module-content">
                <div class="form-group">
                    <label for="student-name">Name:</label>
                     <input type="text" id="student-name" class="form-control" disabled>
                </div>
                <div class="form-group">
                    <label for="student-email">Email:</label>
                    <input type="email" id="student-email" class="form-control" disabled>
                </div>
                  <div class="form-group">
                    <label for="exam-pin-input">Exam PIN:</label>
                    <input type="text" id="exam-pin-input" class="form-control" placeholder="Get your Exam ID from the attendance sheet">
                </div>
                <div id="student-exam-id-group" class="form-group hidden">
                    <label for="student-exam-id-input">Student Exam ID (Confidential - 5 characters):</label>
                    <input type="text" id="student-exam-id-input" class="form-control" placeholder="Enter 5-character ID" maxlength="5">
                </div>
                <button id="load-exam-btn" class="btn-blue" disabled>
                     <i class="fas fa-download"></i> Load Exam Details
                </button>
                <button id="start-exam-btn-alt" class="btn-green hidden" disabled>
                    <i class="fas fa-play"></i> Start Exam
                </button>
             </div>
        </div>
        <div id="exam-details-module" class="module hidden">
            <div class="module-header">
                <span class="module-title">
                    <i class="fas fa-info-circle"></i> Exam Information
                </span>
             </div>
            <div class="module-content" id="exam-details-display">
                <p>
                    <strong>Exam Name:</strong>
                    <span id="exam-name-detail"></span>
                </p>
                 <p>
                    <strong>Course Code:</strong>
                    <span id="exam-course-code-detail"></span>
                </p>
                <p>
                      <strong>Mode:</strong>
                    <span id="exam-mode-detail"></span>
                </p>
                <p>
                    <strong>Duration:</strong>
                    <span id="exam-duration-detail"></span>
                 </p>
                <p>
                    <strong>Start Time:</strong>
                    <span id="exam-start-time-detail"></span>
                </p>
                 <button id="start-exam-btn" class="btn-green" disabled>
                    <i class="fas fa-play"></i> Start Exam
                </button>
            </div>
        </div>
        <div id="exam-questions-module" class="module hidden">
            <div class="module-header">
                 <span class="module-title">
                    <i class="fas fa-question-circle"></i> Exam Questions
                </span>
                <span class="info-item" style="background-color: var(--danger-color); color: white;">
                    <i class="fas fa-stopwatch"></i> Time Left:
                    <span id="timer-display">--:--</span>
                </span>
            </div>
            <div class="module-content">
                 <form id="exam-form">
                    <div id="exam-questions-area">
                        <p>Loading questions...</p>
                    </div>
                    <button type="button" id="submit-exam-btn" class="btn-green" disabled>
                         <i class="fas fa-check-circle"></i> Submit Exam
                    </button>
                </form>
            </div>
        </div>
        <div id="submission-confirmation-module" class="module hidden">
              <div class="module-content confirmation-message">
                <i class="fas fa-check-circle fa-3x" style="color: var(--success-color); margin-bottom: 15px;"></i><br>
                Exam Submitted Successfully!
            </div>
        </div>
    <footer class="footer">
        <div class="social-links">
            <a href="https://eis.epoka.edu.al/cv/fullcv/655" target="_blank" rel="noopener noreferrer"><i class="far fa-id-card"></i></a>
            <a href="mailto:bplaku@epoka.edu.al" target="_blank" rel="noopener noreferrer"><i class="far fa-envelope"></i></a>
        </div>
        <p style="font-size:0.7em"><i class="far fa-copyright"></i> 2023-<span id="currentYear"></span> Bredli Plaku. All Rights Reserved.</p>
    </footer>
    </div>

    <script>
        // === Configuration ===
        const ADMIN_EMAILS = ['bplaku@epoka.edu.al'];
        const CLIENT_ID = '740588046540-npg0crodtcuinveu6bua9rd6c3hb2s1m.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyD295FTtMHvXxZablRf0f-FR-IQ2dQRPQE'; // Replace with your actual API Key
        const EXAM_SPREADSHEET_ID = '14SgW9V3ZLYDqqoAutkvHEuLvcogpJ2hMEj_qj72wmEw';
        const EXAM_DETAILS_SHEET_NAME = 'Exams'; // Columns: PIN, Code, Name, Duration, StartDate (YYYY-MM-DD), StartTime (HH:MM:SS), Mode, Questions (JSON)
        const EXAM_ATTEMPTS_SHEET_NAME = 'Attempts'; // Columns: Timestamp, Name, Email, PIN, CourseCode, StudentExamID, Status, Answers (JSON), Fingerprint (JSON)

        const DISCOVERY_DOCS = ["https://sheets.googleapis.com/$discovery/rest?version=v4"];
        // *** Requires Write Scope for submission ***
        const SCOPES = "https://www.googleapis.com/auth/spreadsheets https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile";

        // === App State ===
        let isAdmin = false;
        let isSignedIn = false;
        let currentUser = null;
        let tokenClient = null;
        let isOnline = navigator.onLine;
        let isSyncing = false;
        let isInitializing = true;
        let examDetails = null;         // Holds the loaded exam data {PIN, Code, Name, Duration, StartDate, StartTime, Mode, Questions, OriginalOrderMap}
        let studentPINEntered = '';     // PIN entered by the student
        let studentExamIdEntered = '';  // 5-character ID ONLY for 'Exam' mode, entered by student
        let examTimerInterval = null;   // Interval ID for the countdown timer
        let examEndTime = null;         // Absolute end time (timestamp in ms)
        const appStateKey = 'examAppState'; // Key for localStorage
		let totalQuestions = 0; // To track total number of questions displayed
		let confirmedQuestionsCount = 0; // To track confirmed questions

        // === DOM Elements ===
        const loadingIndicator      = document.getElementById('app-loading');
        const mainContainer         = document.getElementById('main-container');
        const syncStatus            = document.getElementById('sync-status');
        const syncText              = document.getElementById('sync-text');
        const loginBtn              = document.getElementById('login-btn');
        const logoutBtn             = document.getElementById('logout-btn');
        const loginContainer        = document.getElementById('login-container');
        const userContainer         = document.getElementById('user-container');
        const userName              = document.getElementById('user-name');
        const userAvatar            = document.getElementById('user-avatar');
        const notificationArea      = document.getElementById('in-page-notification-area');
        const examNameHeader        = document.getElementById('exam-name-header');
        const examCodeDisplay       = document.getElementById('exam-code-display');
        const examDurationDisplay   = document.getElementById('exam-duration-display');
        const examStartTimeDisplay  = document.getElementById('exam-start-time-display');
        const signinPromptModule    = document.getElementById('signin-prompt-module');
        const examStartModule       = document.getElementById('exam-start-module');
        const studentNameInput      = document.getElementById('student-name');
        const studentEmailInput     = document.getElementById('student-email');
        const examPinInput          = document.getElementById('exam-pin-input');
        const studentExamIdGroup    = document.getElementById('student-exam-id-group');
        const studentExamIdInput    = document.getElementById('student-exam-id-input');
        const loadExamBtn           = document.getElementById('load-exam-btn');
        const examDetailsModule     = document.getElementById('exam-details-module');
        const examDetailsDisplay    = document.getElementById('exam-details-display');
        const examNameDetail        = document.getElementById('exam-name-detail');
        const examCourseCodeDetail  = document.getElementById('exam-course-code-detail');
        const examModeDetail        = document.getElementById('exam-mode-detail');
        const examDurationDetail    = document.getElementById('exam-duration-detail');
        const examStartTimeDetail   = document.getElementById('exam-start-time-detail');
        const startExamBtn          = document.getElementById('start-exam-btn'); // Button in Details module (Quiz mode)
        const startExamBtnAlt       = document.getElementById('start-exam-btn-alt'); // Button in Start module (Exam mode)
        const examQuestionsModule   = document.getElementById('exam-questions-module');
        const examForm              = document.getElementById('exam-form');
        const examQuestionsArea     = document.getElementById('exam-questions-area');
        const submitExamBtn         = document.getElementById('submit-exam-btn');
        const timerDisplay          = document.getElementById('timer-display');
        const submissionConfirmationModule = document.getElementById('submission-confirmation-module');

        // === Initialisation ===
        window.addEventListener('load', init);

        function init() {
            console.log("Initialising...");
            document.body.classList.remove('content-hidden');
            mainContainer.classList.add('content-visible');
            updateYear();
            setupEventListeners();
            loadAppState(); // Load any saved state early
            updateOnlineStatus();
            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);

            // Delay API init slightly to ensure scripts are loaded
            setTimeout(() => {
                if (typeof gapi !== 'undefined' && typeof google !== 'undefined') {
                    initGoogleApi();
                } else {
                    handleApiInitError(new Error("Google API objects not loaded"));
                }
            }, 500);
        }

        function setupEventListeners() {
            loginBtn?.addEventListener('click', handleAuthClick);
            logoutBtn?.addEventListener('click', handleSignoutClick);
            loadExamBtn?.addEventListener('click', handleLoadExam);
            startExamBtn?.addEventListener('click', handleStartExam); // For Quiz mode
            startExamBtnAlt?.addEventListener('click', handleStartExam); // For Exam mode
            submitExamBtn?.addEventListener('click', () => handleSubmitExam(false)); // Manual submit trigger

            // Enable load button only when PIN is entered, signed in, and online
            examPinInput?.addEventListener('input', () => {
                if (loadExamBtn) {
                    loadExamBtn.disabled = examPinInput.value.trim() === '' || !isSignedIn || !isOnline;
                }
            });

            // Validate Student Exam ID input for Exam mode
            studentExamIdInput?.addEventListener('input', validateStudentExamIdInput);

            // Initial button states
            if (loadExamBtn) loadExamBtn.disabled = true;
            if (startExamBtn) startExamBtn.disabled = true;
            if (startExamBtnAlt) startExamBtnAlt.classList.add('hidden'); // Hide Exam mode button initially
            if (submitExamBtn) submitExamBtn.disabled = true;
        }

        function showAppContent() {
            loadingIndicator?.classList.add('hidden');
            mainContainer?.classList.add('content-visible');
            console.log("App content shown.");
        }

        function updateYear() {
            const el = document.getElementById('currentYear');
            if (el) {
                el.textContent = new Date().getFullYear();
            }
        }

        // === Google API & Auth ===
        function initGoogleApi() {
            console.log('Initialising Google API...');
            try {
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CLIENT_ID,
                    scope: SCOPES,
                    callback: handleTokenResponse // This function will be called when the user grants access
                });

                gapi.load('client', async () => {
                    try {
                        await gapi.client.init({
                            apiKey: API_KEY,
                            discoveryDocs: DISCOVERY_DOCS
                        });
                        console.log('GAPI client initialised.');

                        // Check for existing token (e.g., from previous session)
                        const savedToken = localStorage.getItem('gapi_token');
                        if (savedToken) {
                            const token = JSON.parse(savedToken);
                            // Basic check if token exists; add expiry check if needed
                            if (token?.access_token /* && !isTokenExpired(token) */) {
                                gapi.client.setToken(token);
                                console.log("Using saved token.");
                                await tokenObtained(token); // Process the existing token
                            } else {
                                localStorage.removeItem('gapi_token'); // Remove invalid token
                                console.log("Saved token invalid or expired.");
                                updateAuthUI();
                                showAppContent();
                            }
                        } else {
                             console.log("No saved token found.");
                             updateAuthUI(); // Update UI for logged-out state
                             showAppContent(); // Show content now that API init is done
                        }
                    } catch (error) {
                        handleApiInitError(error); // Handle GAPI client init errors
                    }
                });
            } catch (error) {
                handleApiInitError(error); // Handle Token Client init errors
            }
        }

        function handleApiInitError(error) {
            console.error('API Initialisation Error:', error);
            showImprovedNotification('error', 'API Load Error', `Failed to load Google services: ${error.message}`);
            updateAuthUI(); // Update UI to reflect potential issues (e.g., disable buttons)
            showAppContent(); // Ensure content is visible even if API fails
        }

        // Placeholder for a proper token expiry check if needed
        function isTokenExpired(token) {
            // Implement logic to check token.expires_in or similar field
            return false;
        }

        function handleAuthClick() {
            if (tokenClient) {
                showImprovedNotification('info', 'Signing In', 'Opening Google Sign-In...');
                // Prompt the user to select an account and grant access.
                tokenClient.requestAccessToken({ prompt: 'select_account' });
            } else {
                console.error('Token client not initialised.');
                showImprovedNotification('error', 'Authentication Error', 'Authentication service is not ready. Please try again later.');
            }
        }

        // Callback function after user grants or denies access
        function handleTokenResponse(resp) {
            if (resp.error) {
                console.error('Token response error:', resp);
                let msg = `Authentication failed: ${resp.error}`;
                if (resp.error === 'popup_closed_by_user') msg = 'Sign-in cancelled by user.';
                if (resp.error === 'access_denied') msg = 'Access denied. Please grant permission to proceed.';
                showImprovedNotification('error', 'Authentication Error', msg);
                updateAuthUI();
                showAppContent(); // Ensure content is visible
                return;
            }
            console.log('Access token received.');
            localStorage.setItem('gapi_token', JSON.stringify(resp)); // Save token
            gapi.client.setToken(resp); // Set token for GAPI client
            tokenObtained(resp); // Proceed with obtained token
        }

        // Called after a token is successfully obtained (new or saved)
        async function tokenObtained(token) {
            console.log("Token available, proceeding...");
            isSignedIn = true;
            await fetchUserInfo(); // Get user profile details
            updateAuthUI(); // Update UI to logged-in state
            showAppContent(); // Ensure content is visible

            // Check if there's a saved exam state for this user
            const loadedState = JSON.parse(localStorage.getItem(appStateKey) || '{}');
            if (currentUser &&
                loadedState.currentUserEmail === currentUser.email &&
                loadedState.examEndTime &&
                Date.now() < loadedState.examEndTime) {
                console.log("Attempting to restore active exam session.");
                restoreAppState(loadedState); // Try to restore the previous session
            } else if (loadedState.currentUserEmail) {
                console.log("Saved state is invalid or expired for the current user.");
                localStorage.removeItem(appStateKey); // Clear invalid/old state
                saveAppState(); // Save a clean initial state if needed
            }
        }

        async function fetchUserInfo() {
            if (!gapi.client.getToken()?.access_token) {
                console.warn("fetchUserInfo called without an access token.");
                return;
            }
            console.log('Fetching user information...');
            try {
                // Use the Google User Info endpoint
                const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                    headers: {
                        'Authorization': `Bearer ${gapi.client.getToken().access_token}`
                    }
                });
                if (!response.ok) {
                    // Handle specific errors like 401 Unauthorized (token expired/revoked)
                    if (response.status === 401) {
                        console.warn("User Info fetch failed (401 - Unauthorized). Signing out.");
                        handleSignoutClick(); // Force sign out if token is invalid
                        return;
                    }
                    throw new Error(`(${response.status}) ${await response.text()}`);
                }
                const userInfo = await response.json();
                currentUser = {
                    id: userInfo.sub,
                    name: userInfo.name || 'N/A',
                    email: userInfo.email || 'N/A',
                    picture: userInfo.picture || ''
                };
                console.log('User details fetched:', currentUser.email);

                // Update UI elements with user info
                if (studentNameInput) studentNameInput.value = currentUser.name;
                if (studentEmailInput) studentEmailInput.value = currentUser.email;
                if (userAvatar) userAvatar.src = currentUser.picture;
                if (userName) userName.textContent = currentUser.name;

                // Check admin status
                isAdmin = ADMIN_EMAILS.includes(currentUser.email);
                document.body.classList.toggle('is-admin', isAdmin);

                // Enable PIN input now that user is signed in
                if (examPinInput) examPinInput.disabled = false;
                // Re-evaluate load button state
                if (loadExamBtn) {
                    loadExamBtn.disabled = examPinInput.value.trim() === '' || !isOnline;
                }
            } catch (e) {
                console.error('Fetch user info error:', e);
                showImprovedNotification('error', 'User Info Error', `Could not get user details: ${e.message}. Please try signing in again.`);
                currentUser = null; // Clear user info on error
                updateAuthUI(); // Update UI to reflect error state
            }
        }

        function handleSignoutClick() {
            console.log("Signing out...");
            const token = gapi.client.getToken();
            if (token?.access_token) {
                try {
                    // Revoke the token on Google's side
                    google.accounts.oauth2.revoke(token.access_token, () => console.log('Token revoked successfully.'));
                } catch (e) {
                    console.warn("Error revoking token:", e);
                }
                gapi.client.setToken(''); // Clear token from GAPI client
            }
            localStorage.removeItem('gapi_token'); // Clear saved token
            localStorage.removeItem(appStateKey); // Clear saved exam state

            // Reset application state variables
            isSignedIn = false;
            isAdmin = false;
            currentUser = null;
            examDetails = null;
            studentPINEntered = '';
            studentExamIdEntered = '';
            stopTimer(); // Stop any active exam timer

            resetExamState(); // Reset UI to initial state
            updateAuthUI(); // Update UI to logged-out state
            showImprovedNotification('info', 'Signed Out', 'You have been signed out.');
        }


        // === UI State & Reset ===
        // === UI State & Reset ===
function resetExamState() {
    console.log("Resetting UI to initial state.");
    // Hide modules related to active exam
    examStartModule?.classList.add('hidden');
    examDetailsModule?.classList.add('hidden');
    examQuestionsModule?.classList.add('hidden');
    submissionConfirmationModule?.classList.add('hidden');
    studentExamIdGroup?.classList.add('hidden'); // Hide Student ID input

    // Show the initial sign-in prompt if it exists
    signinPromptModule?.classList.remove('hidden');

    // Reset input fields
    if (examPinInput) {
        examPinInput.value = '';
        examPinInput.disabled = true; // Disable until signed in
    }
    if (studentExamIdInput) studentExamIdInput.value = '';
    if (studentNameInput) studentNameInput.value = '';
    if (studentEmailInput) studentEmailInput.value = '';

    // Reset buttons to initial state
    if (loadExamBtn) {
        loadExamBtn.disabled = true;
        loadExamBtn.classList.remove('hidden');
        loadExamBtn.innerHTML = '<i class="fas fa-download"></i> Load Exam Details';
    }
    if (startExamBtn) startExamBtn.disabled = true;
    if (startExamBtnAlt) {
        startExamBtnAlt.classList.add('hidden');
        startExamBtnAlt.disabled = true;
    }
     if (submitExamBtn) { // Ensure submit button is reset correctly
         submitExamBtn.disabled = true;
         submitExamBtn.innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)';
     }

    // Reset header/details display
    const na = 'N/A';
    if (examCodeDisplay) examCodeDisplay.textContent = na;
    if (examDurationDisplay) examDurationDisplay.textContent = na;
    if (examStartTimeDisplay) examStartTimeDisplay.textContent = na;
    if (examNameHeader) examNameHeader.textContent = 'Please sign in to load the exam';
    if (examNameDetail) examNameDetail.textContent = '';
    if (examCourseCodeDetail) examCourseCodeDetail.textContent = '';
    if (examModeDetail) examModeDetail.textContent = '';
    if (examDurationDetail) examDurationDetail.textContent = '';
    if (examStartTimeDetail) examStartTimeDetail.textContent = '';

    // Clear questions area and timer
    if (examQuestionsArea) examQuestionsArea.innerHTML = '<p>Exam questions will appear here...</p>';
    stopTimer();
    if (timerDisplay) timerDisplay.textContent = '--:--';
    // Reset confirmation counts
    totalQuestions = 0;
    confirmedQuestionsCount = 0;
}


        function updateAuthUI() {
            console.log('Updating Auth UI - SignedIn:', isSignedIn, 'CurrentUser:', !!currentUser);
            document.body.classList.toggle('is-admin', isAdmin);

            if (isSignedIn && currentUser) {
                // Logged-in state
                console.log('Showing logged-in UI.');
                loginContainer.style.display = 'none';
                userContainer.style.display = 'flex';
                signinPromptModule.classList.add('hidden'); // Hide sign-in prompt

                 // Show exam start module only if no exam is active/loaded yet
                 if (examStartModule && !examDetails && examQuestionsModule.classList.contains('hidden')) {
                     examStartModule.classList.remove('hidden');
                 }

                if (examPinInput) examPinInput.disabled = false; // Enable PIN input
                if (loadExamBtn) { // Enable load button if PIN is entered and online
                    loadExamBtn.disabled = examPinInput.value.trim() === '' || !isOnline;
                }

                // Populate user details fields
                if (studentNameInput) studentNameInput.value = currentUser.name || 'N/A';
                if (studentEmailInput) studentEmailInput.value = currentUser.email || 'N/A';
                if (userName) userName.textContent = currentUser.name || '';
                if (userAvatar) userAvatar.src = currentUser.picture || '';
            } else {
                // Logged-out state
                console.log('Showing logged-out UI.');
                loginContainer.style.display = 'flex';
                userContainer.style.display = 'none';
                resetExamState(); // Reset everything to initial logged-out view
                signinPromptModule.classList.remove('hidden'); // Ensure sign-in prompt is visible
            }
        }

        // === Google Sheets Interaction ===

        // Fetch data from a specified range
        async function getSheetData(spreadsheetId, range) {
            if (!isSignedIn || !gapi?.client?.sheets) {
                showImprovedNotification('error', 'API Error', 'Not signed in or Sheets API not ready.');
                return null;
            }
            if (!isOnline) {
                showImprovedNotification('warning', 'Offline', 'Cannot fetch data while offline.');
                return null;
            }
            console.log(`Workspaceing data from: ${spreadsheetId}, Range: ${range}`);
            setSyncing(true); // Indicate network activity
            try {
                const response = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId,
                    range
                });
                console.log(`Successfully fetched data for ${range}.`);
                return response.result.values || []; // Return data rows or empty array
            } catch (err) {
                console.error(`Error fetching ${range}:`, err);
                const errorDetails = err.result?.error;
                showImprovedNotification('error', 'Sheet Read Error', `Could not fetch data: ${errorDetails?.message || err.message} (Code: ${errorDetails?.status})`);
                return null; // Indicate failure
            } finally {
                setSyncing(false); // End network activity indication
            }
        }

        // Append new rows to a sheet
        async function appendSheetData(spreadsheetId, sheetName, values) {
            if (!isSignedIn || !gapi?.client?.sheets) {
                showImprovedNotification('error', 'API Error', 'Not signed in or Sheets API not ready.');
                return false;
            }
            // Check if write scope is granted (essential for append)
            if (!SCOPES.includes("https://www.googleapis.com/auth/spreadsheets")) {
                console.warn("Attempted write operation with read-only scope. Data:", values);
                showImprovedNotification('warning', 'Read-Only Mode', 'Cannot save attempt (read-only permissions). Please ensure correct authorization.');
                return false; // Append requires write permission
            }
            if (!isOnline) {
                showImprovedNotification('warning', 'Offline', 'Cannot save data while offline.');
                return false;
            }
            console.log(`Appending data to Sheet: ${spreadsheetId}, Sheet: ${sheetName}`);
            setSyncing(true);
            try {
                const response = await gapi.client.sheets.spreadsheets.values.append({
                    spreadsheetId,
                    range: sheetName, // Append to the end of the specified sheet
                    valueInputOption: 'USER_ENTERED', // Interpret data as if user typed it
                    insertDataOption: 'INSERT_ROWS', // Insert new rows for the data
                    resource: { values } // The data to append (array of rows)
                });
                console.log('Append operation successful:', response.result);
                return true; // Indicate success
            } catch (err) {
                console.error(`Error appending to ${sheetName}:`, err);
                const errorDetails = err.result?.error;
                showImprovedNotification('error', `Sheet Write Error`, `Could not save data: ${errorDetails?.message || err.message} (Code: ${errorDetails?.status})`);
                return false; // Indicate failure
            } finally {
                setSyncing(false);
            }
        }

         // Update existing cells in a sheet
        async function updateSheetData(spreadsheetId, range, values) {
             if (!isSignedIn || !gapi?.client?.sheets) {
                 showImprovedNotification('error', 'API Error', 'Not signed in or Sheets API not ready for update.');
                 return false;
             }
             // Check for write scope
             if (!SCOPES.includes("https://www.googleapis.com/auth/spreadsheets")) {
                 console.warn("Read-only scope. Cannot update data. Range:", range, "Data:", values);
                 showImprovedNotification('warning', 'Read-Only Mode', 'Cannot update attempt (read-only permissions).');
                 return false; // Update requires write permission
             }
             if (!isOnline) {
                 showImprovedNotification('warning', 'Offline', 'Cannot update data while offline.');
                 return false;
             }
             console.log(`Updating Sheet: ${spreadsheetId}, Range: ${range}`);
             setSyncing(true);
             try {
                 const response = await gapi.client.sheets.spreadsheets.values.update({
                     spreadsheetId: spreadsheetId,
                     range: range, // The specific cell range to update (e.g., 'Attempts!G5:I5')
                     valueInputOption: 'USER_ENTERED', // Interpret data as if user typed it
                     resource: {
                          values: values // Data to write (array of rows matching the range)
                     }
                 });
                 console.log('Update operation successful:', response.result);
                 return true; // Indicate success
             } catch (err) {
                 console.error(`Error updating ${range}:`, err);
                 const errorDetails = err.result?.error;
                 showImprovedNotification('error', `Sheet Update Error`, `Could not update data: ${errorDetails?.message || err.message} (Code: ${errorDetails?.status})`);
                 return false; // Indicate failure
             } finally {
                 setSyncing(false);
             }
         }

        // === Exam Logic ===

        // Triggered when the "Load Exam Details" button is clicked
        async function handleLoadExam() {
            studentPINEntered = examPinInput.value.trim();
            if (!studentPINEntered) {
                showImprovedNotification('warning', 'Missing PIN', 'Please Get your Exam ID from the attendance sheet.');
                return;
            }
            // Disable button and show loading state
            loadExamBtn.disabled = true;
            loadExamBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';

            await fetchExamDetails(studentPINEntered); // Fetch details from the sheet

            // Re-enable button and restore text
            loadExamBtn.disabled = false; // Re-enable regardless of success/failure for retry
            loadExamBtn.innerHTML = '<i class="fas fa-download"></i> Load Exam Details';

            // Enable/disable start buttons based on whether exam details were loaded
            if (startExamBtn) startExamBtn.disabled = !examDetails || !isOnline;
            if (startExamBtnAlt) startExamBtnAlt.disabled = !examDetails || !isOnline; // Initial state, ID check happens later
        }

        // Fetches exam configuration from the 'Exams' sheet based on PIN
        async function fetchExamDetails(pin) {
            showImprovedNotification('info', 'Fetching Exam', `Loading details for PIN: ${pin}...`);
            // Define the range to fetch all relevant columns from the Exams sheet
            const range = `${EXAM_DETAILS_SHEET_NAME}!A:H`; // PIN, Code, Name, Duration, StartDate, StartTime, Mode, Questions
            const data = await getSheetData(EXAM_SPREADSHEET_ID, range);

            examDetails = null; // Reset previous details
            examEndTime = null; // Reset end time

            if (data === null) { // Check if getSheetData failed (e.g., offline, API error)
                if (loadExamBtn) loadExamBtn.disabled = !isOnline; // Re-enable load button if online
                return;
            }

            if (data.length > 1) { // Check if there's data beyond the header row
                const header = data[0].map(h => String(h).trim().toLowerCase()); // Process header row
                // Find column indices (robust against column order changes)
                const indices = {
                    pin: header.indexOf('pin'),
                    code: header.indexOf('code'),
                    name: header.indexOf('name'),
                    duration: header.indexOf('duration'),
                    startDate: header.indexOf('startdate'),
                    startTime: header.indexOf('starttime'),
                    mode: header.indexOf('mode'),
                    questions: header.indexOf('questions')
                };

                // Validate that all required columns were found
                const missingHeaders = Object.entries(indices).filter(([key, value]) => value === -1).map(([key]) => key);
                if (missingHeaders.length > 0) {
                    console.error(`Missing required columns in '${EXAM_DETAILS_SHEET_NAME}' sheet: ${missingHeaders.join(', ')}. Found headers:`, header);
                    showImprovedNotification('error', 'Sheet Format Error', `The "${EXAM_DETAILS_SHEET_NAME}" sheet is missing required columns: ${missingHeaders.join(', ')}.`);
                    if (loadExamBtn) loadExamBtn.disabled = !isOnline;
                    return;
                }

                // Find the row matching the entered PIN
                const examRow = data.slice(1).find(row => row[indices.pin] === pin);

                if (examRow) {
                    // Extract and validate data from the row
                    const duration = parseInt(examRow[indices.duration], 10);
                    const startDateStr = String(examRow[indices.startDate] || '').trim();
                    const startTimeStr = String(examRow[indices.startTime] || '').trim();
                    const mode = String(examRow[indices.mode] || 'Quiz').trim().toLowerCase(); // Default to 'quiz' if empty
                    const questionsJson = String(examRow[indices.questions] || '[]').trim(); // Get questions JSON string

                    // Validate duration
                    if (isNaN(duration) || duration <= 0) {
                        showImprovedNotification('error', 'Invalid Exam Data', 'The exam duration specified in the sheet is invalid.');
                        if (loadExamBtn) loadExamBtn.disabled = !isOnline;
                        return;
                    }
                    // Validate date/time format (ISO-like standards preferred)
                    if (!/^\d{4}-\d{2}-\d{2}$/.test(startDateStr) || !/^\d{2}:\d{2}:\d{2}$/.test(startTimeStr)) {
                        showImprovedNotification('error', 'Invalid Date/Time Format', `Invalid Date ('${startDateStr}') or Time ('${startTimeStr}') format in the sheet. Please use YYYY-MM-DD and HH:MM:SS.`);
                        if (loadExamBtn) loadExamBtn.disabled = !isOnline;
                        return;
                    }

                     // Attempt to parse questions JSON early to catch errors
                     try {
                         const parsedQuestions = JSON.parse(questionsJson);
                         if (!Array.isArray(parsedQuestions)) {
                             throw new Error("Questions data is not a valid JSON array.");
                         }
                         // Optionally, validate structure of each question object here
                     } catch (e) {
                          console.error("Error parsing questions JSON:", e, "JSON string:", questionsJson);
                          showImprovedNotification('error', 'Invalid Questions Data', `The questions data for this exam is malformed or empty. Please check the '${EXAM_DETAILS_SHEET_NAME}' sheet. Error: ${e.message}`);
                          if (loadExamBtn) loadExamBtn.disabled = !isOnline;
                          return;
                      }


                    // Calculate the absolute end time based on start time and duration
                    try {
                        const startDateTimeStr = `${startDateStr}T${startTimeStr}`; // Combine date and time
                        const startTimeFromSheet = new Date(startDateTimeStr).getTime(); // Get timestamp
                        if (isNaN(startTimeFromSheet)) throw new Error("Cannot parse start date/time from sheet.");
                        const durationMillis = duration * 60 * 1000; // Convert duration minutes to ms
                        examEndTime = startTimeFromSheet + durationMillis; // Calculate end timestamp
                        console.log(`[TIMER CALC] StartDate: ${startDateStr}, StartTime: ${startTimeStr}, Parsed Start TS: ${startTimeFromSheet}, Duration(ms): ${durationMillis}, Calculated End TS: ${examEndTime} (${new Date(examEndTime).toLocaleString()})`);
                    } catch (e) {
                        console.error("Error calculating exam end time:", e);
                        showImprovedNotification('error', 'Calculation Error', 'Could not calculate the exam end time from the sheet data.');
                        if (loadExamBtn) loadExamBtn.disabled = !isOnline;
                        return;
                    }

                    // Store the loaded exam details
                    examDetails = {
                        PIN: pin,
                        Code: examRow[indices.code],
                        Name: examRow[indices.name],
                        Duration: duration,
                        StartDate: startDateStr,
                        StartTime: startTimeStr,
                        Mode: mode,
                        Questions: questionsJson, // Store the raw JSON string
                        OriginalOrderMap: null // Will be populated when questions are displayed
                    };
                    console.log("Exam details loaded successfully:", examDetails);

                    displayExamDetailsHeader(); // Update header info
                    showImprovedNotification('success', 'Exam Loaded', `Details for "${examDetails.Name}" loaded successfully.`);

                    // Adjust UI based on exam mode
                    if (examDetails.Mode === 'exam') {
                        console.log("Exam Mode detected: Showing Student Exam ID input.");
                        examStartModule.classList.remove('hidden'); // Ensure start module is visible
                        studentExamIdGroup.classList.remove('hidden'); // Show ID input field
                        studentExamIdInput.value = ''; // Clear any previous ID
                        examDetailsModule.classList.add('hidden'); // Hide the details-only module
                        startExamBtnAlt.classList.remove('hidden'); // Show the Exam mode start button
                        startExamBtn.classList.add('hidden'); // Hide the Quiz mode start button
                        startExamBtn.disabled = true; // Disable Quiz mode start button
                        loadExamBtn.classList.add('hidden'); // Hide load button now
                        validateStudentExamIdInput(); // Initial validation for the (empty) ID input
                    } else { // Quiz Mode
                        console.log("Quiz Mode detected: Showing Exam Information module.");
                        studentExamIdGroup.classList.add('hidden'); // Hide ID input
                        studentExamIdInput.value = '';
                        studentExamIdEntered = ''; // Clear any stored ID
                        examStartModule.classList.add('hidden'); // Hide the start module
                        displayExamDetailsFull(); // Populate the full details view
                        examDetailsModule.classList.remove('hidden'); // Show the details module
                        startExamBtnAlt.classList.add('hidden'); // Hide Exam mode start button
                        startExamBtn.classList.remove('hidden'); // Show Quiz mode start button
                        startExamBtn.disabled = !isOnline; // Enable Quiz start button if online
                        loadExamBtn.disabled = true; // Disable load button
                        loadExamBtn.classList.remove('hidden'); // Keep load button visible but disabled
                    }
                    saveAppState(); // Save the loaded state
                } else {
                    // PIN not found in the sheet
                    showImprovedNotification('error', 'Invalid PIN', 'The entered Exam PIN was not found.');
                    examDetailsModule.classList.add('hidden'); // Hide details module
                    examStartModule.classList.remove('hidden'); // Ensure start module is visible for retry
                    if (loadExamBtn) loadExamBtn.disabled = !isOnline; // Re-enable load if online
                }
            } else {
                // No data rows found in the sheet
                showImprovedNotification('error', 'No Exams Found', 'No exam configurations found in the sheet.');
                examDetailsModule.classList.add('hidden');
                examStartModule.classList.remove('hidden');
                if (loadExamBtn) loadExamBtn.disabled = !isOnline;
            }
        }


        // Finds the first attempt record matching criteria and specific status
        // Returns { rowNumber, rowData } or null
         async function findAttemptRecord(email, pin, studentExamId, mode, targetStatus) {
             if ((mode === 'quiz' && !email) || !pin || (mode === 'exam' && !studentExamId)) {
                 console.error("Missing identifiers for finding attempt record. Mode:", mode, "Email:", !!email, "PIN:", !!pin, "ExamID:", !!studentExamId);
                 // Avoid showing notification here, let calling function handle context
                 return null;
             }

             // Fetch columns needed for identification + Status column
             // A=Timestamp, B=Name, C=Email, D=PIN, E=CourseCode, F=StudentExamID, G=Status
             const range = `${EXAM_ATTEMPTS_SHEET_NAME}!A:G`;
             console.log(`Searching for attempt record in ${range} with status '${targetStatus}'... Criteria: PIN=${pin}, Mode=${mode}` + (mode==='exam' ? `, ExamID=${studentExamId}` : `, Email=${email}`));
             const data = await getSheetData(EXAM_SPREADSHEET_ID, range);

             if (data === null || data.length <= 1) { // Check if fetch failed or only header exists
                 console.log("No attempt data found or fetch failed.");
                 return null;
             }

             // Iterate through rows (skip header row at index 0)
             for (let i = 1; i < data.length; i++) {
                 const row = data[i];
                 // Check if row has enough columns (A-G = 7 columns)
                 if (row && row.length >= 7) {
                     const sheetEmail = String(row[2] || '').trim().toLowerCase(); // Col C (Index 2)
                     const sheetPin = String(row[3] || '').trim().toLowerCase();   // Col D (Index 3)
                     const sheetStudentExamId = String(row[5] || '').trim();       // Col F (Index 5)
                     const sheetStatus = String(row[6] || '').trim().toLowerCase(); // Col G (Index 6)

                     let match = false;
                     // Check criteria based on mode
                     if (mode === 'quiz' &&
                         sheetEmail === email.toLowerCase() &&
                         sheetPin === pin.toLowerCase()) {
                         match = true;
                     } else if (mode === 'exam' &&
                                sheetStudentExamId === studentExamId && // Match exact student ID
                                sheetPin === pin.toLowerCase()) {
                         match = true;
                     }

                     // If identification criteria match, check the status
                     if (match && sheetStatus === targetStatus.toLowerCase()) {
                         const rowNumber = i + 1; // Sheet rows are 1-based, loop index i is 0-based after header
                         console.log(`Found matching record with status '${targetStatus}' at row ${rowNumber} (data index ${i}).`);
                         return {
                             rowNumber: rowNumber,
                             rowData: row // Return the fetched row data (Cols A-G)
                         };
                     }
                 } else {
                     // Log if a row seems malformed (optional)
                     // console.warn(`Skipping malformed row at index ${i + 1}:`, row);
                 }
             }

             console.log(`No record found matching criteria with status '${targetStatus}'.`);
             return null; // No matching record found
         }

// Checks if all questions are confirmed and updates the main submit button
function checkAllConfirmed() {
    // Only proceed if the questions area is visible and we know the total count
    if (!examQuestionsArea || examQuestionsModule.classList.contains('hidden') || totalQuestions <= 0) {
        if(submitExamBtn) {
            submitExamBtn.disabled = true;
            submitExamBtn.innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)';
        }
        return;
    }

    const allConfirmed = confirmedQuestionsCount === totalQuestions;
    console.log(`Confirmed <span class="math-inline">\{confirmedQuestionsCount\}/</span>{totalQuestions} questions. All confirmed: ${allConfirmed}`);

    if (submitExamBtn) {
        // Enable button only if all questions are confirmed AND user is online
        submitExamBtn.disabled = !allConfirmed || !isOnline;

        // Update button text for clarity
        if (allConfirmed && isOnline) {
            submitExamBtn.innerHTML = '<i class="fas fa-check-circle"></i> Submit Exam Now';
        } else if (!isOnline) {
             submitExamBtn.innerHTML = '<i class="fas fa-wifi"></i> Submit Exam (Offline)';
         } else {
                 submitExamBtn.innerHTML = `<i class="fas fa-lock"></i> Submit Exam (<span class="math-inline">${confirmedQuestionsCount}/${totalQuestions}</span> Confirmed)`;
         }
    }
}

        // Validates the 5-character input for Student Exam ID in Exam mode
        function validateStudentExamIdInput() {
            const startButtonToUse = startExamBtnAlt; // Use the Exam mode start button
            // Ensure button, input, and exam details (in exam mode) exist
            if (!startButtonToUse || !studentExamIdInput || !examDetails || examDetails.Mode !== 'exam') return;

            const idValue = studentExamIdInput.value.trim();
            const isValid = idValue.length === 5; // Simple length check

            // Enable/disable the Exam mode start button based on validity and online status
            startButtonToUse.disabled = !isValid || !isOnline;

            // Visual feedback for the input field
            studentExamIdInput.style.borderColor = (isValid || idValue === '') ? '#ccc' : 'red'; // Red border if invalid and not empty
        }

        // Updates the header section with basic exam details
        function displayExamDetailsHeader() {
            if (!examDetails) return;
            if (examCodeDisplay) examCodeDisplay.textContent = examDetails.Code || 'N/A';
            if (examDurationDisplay) examDurationDisplay.textContent = `${examDetails.Duration} minutes`;
            const startTimeString = `${examDetails.StartDate || ''} ${examDetails.StartTime || ''}`.trim();
            if (examStartTimeDisplay) examStartTimeDisplay.textContent = startTimeString || 'N/A';
            if (examNameHeader) examNameHeader.textContent = examDetails.Name || 'Exam Loaded';
        }

        // Populates the dedicated "Exam Information" module (Quiz mode)
        function displayExamDetailsFull() {
            if (!examDetails) return;
            if (examNameDetail) examNameDetail.textContent = examDetails.Name || 'N/A';
            if (examCourseCodeDetail) examCourseCodeDetail.textContent = examDetails.Code || 'N/A';
            // Capitalize mode for display
            const displayMode = examDetails.Mode ? (examDetails.Mode.charAt(0).toUpperCase() + examDetails.Mode.slice(1)) : 'N/A';
            if (examModeDetail) examModeDetail.textContent = displayMode;
            if (examDurationDetail) examDurationDetail.textContent = `${examDetails.Duration} minutes`;
            const startTimeString = `${examDetails.StartDate || ''} ${examDetails.StartTime || ''}`.trim();
            if (examStartTimeDetail) examStartTimeDetail.textContent = startTimeString || 'N/A';
        }


         // Checks if a 'submit' record already exists for this attempt
        async function checkIfAttemptExists(email, pin, studentExamId, mode) {
             // Use findAttemptRecord to look specifically for a record with 'submit' status
             console.log("Checking for existing 'submit' record...");
             const existingSubmitRecordInfo = await findAttemptRecord(
                 email,
                 pin,
                 studentExamId,
                 mode,
                 'submit' // Target status
             );

             if (existingSubmitRecordInfo) {
                 console.log("Found an existing 'submit' record.");
                 return true; // A submitted record exists
             } else {
                 console.log("No existing 'submit' record found.");
                 return false; // No submitted record found
             }
         }

// Triggered when "Start Exam" button (Quiz or Exam mode) is clicked
async function handleStartExam() {
    if (!examDetails || !currentUser) {
        showImprovedNotification('error', 'Start Error', 'Cannot start the exam. User or exam details are missing.');
        return;
    }

    const currentMode = examDetails.Mode.toLowerCase();
    let currentStudentExamId = '';

    // Validate and store Student Exam ID if in Exam mode
    if (currentMode === 'exam') {
         currentStudentExamId = studentExamIdInput.value.trim();
         if (currentStudentExamId.length !== 5) {
             showImprovedNotification('error', 'Invalid ID', 'Please enter the 5-character Student Exam ID.');
             studentExamIdInput.focus(); // Focus the input for correction
             return;
         }
         studentExamIdEntered = currentStudentExamId; // Store the validated ID for later use (submission)
    } else {
         studentExamIdEntered = ''; // Ensure it's clear for Quiz mode
    }

    console.log("Performing pre-start checks...");

    // 1. Check if already SUBMITTED
    const alreadySubmitted = await checkIfAttemptExists(
        currentUser.email,
        examDetails.PIN,
        studentExamIdEntered, // Use the ID entered/validated just now
        currentMode
    );
    if (alreadySubmitted) {
        showImprovedNotification('error', 'Already Submitted', `This exam (${examDetails.PIN}) has already been submitted and cannot be retaken.`, 0); // 0 duration = persistent
        // Optionally disable start buttons again or reset UI further
        if (startExamBtn) startExamBtn.disabled = true;
        if (startExamBtnAlt) startExamBtnAlt.disabled = true;
        return;
    }

    // 2. Check Exam Timing (Start availability and Deadline)
    try {
        const startDateTimeStr = `${examDetails.StartDate}T${examDetails.StartTime}`;
        const startTime = new Date(startDateTimeStr).getTime();
        if (isNaN(startTime)) throw new Error("Invalid start date/time format in sheet.");

        // Check if exam hasn't started yet
        if (Date.now() < startTime) {
            showImprovedNotification('error', 'Exam Not Yet Available', `This exam is scheduled to start at ${new Date(startTime).toLocaleString()}. Please wait.`);
            return;
        }

        // Check if exam end time is valid and hasn't passed
        if (!examEndTime || isNaN(examEndTime)) {
           console.error("Exam end time calculation failed earlier.");
           showImprovedNotification('error', 'Configuration Error', 'Could not determine the exam end time. Cannot start.');
           return;
         }
         if (Date.now() >= examEndTime) {
             showImprovedNotification('error', 'Exam Deadline Passed', `The deadline (${new Date(examEndTime).toLocaleString()}) for starting or resuming this exam has passed.`, 0);
             return;
         }

    } catch (e) {
        console.warn("Exam timing check error:", e);
        showImprovedNotification('warning', 'Timing Check Warning', `Could not fully verify exam timing: ${e.message}. Proceeding cautiously.`);
        // Allow proceeding but log the warning
    }


    // --- Record 'start' or find existing 'start' ---
    // We need to ensure only one 'start' record exists per attempt.
     console.log("Checking for existing 'start' record...");
     const existingStartRecordInfo = await findAttemptRecord(
         currentUser.email,
         examDetails.PIN,
         studentExamIdEntered, // Use the entered/validated ID
         currentMode,
         'start' // Look specifically for 'start' status
     );

     if (!existingStartRecordInfo) {
         // Only record 'start' if no 'start' record exists yet for this attempt
         console.log("No existing 'start' record found. Recording exam start...");
         const startRecorded = await recordExamAttempt('start'); // Record the start event
         if (!startRecorded) {
             showImprovedNotification('error', 'Start Record Failed', 'Could not record the exam start online. Please check connection and try again.', 0);
             return; // Prevent starting if the initial record fails
         }
     } else {
         console.log(`Existing 'start' record found at row ${existingStartRecordInfo.rowNumber}. Resuming session, not adding duplicate 'start' record.`);
         // Optionally load previous answers if implementing resume functionality
     }
     // --- End 'start' record check ---


    // Proceed to show questions and start the timer
    console.log(`Starting ${currentMode} mode. PIN: ${examDetails.PIN}` + (currentMode === 'exam' ? `, Student Exam ID: ${studentExamIdEntered}` : ''));

    // Reset confirmation count for the new session
    confirmedQuestionsCount = 0;

    // Update UI: Hide setup modules, show questions module
    examStartModule.classList.add('hidden');
    examDetailsModule.classList.add('hidden');
    examQuestionsModule.classList.remove('hidden');
    submissionConfirmationModule.classList.add('hidden'); // Ensure confirmation is hidden

    displayQuestions(examDetails.Questions); // Parse and display questions
    startTimer(); // Start or restart the countdown timer
    saveAppState(); // Save the active exam state
    // Initial check of button state after questions displayed
    checkAllConfirmed();
}

// Parses the JSON string and displays questions in the UI
function displayQuestions(questionsJsonString) {
    console.log("Parsing and displaying exam questions...");
    examQuestionsArea.innerHTML = ''; // Clear previous questions
    totalQuestions = 0; // Reset count for this display run
    try {
        let questionsArray = [];
        // Robust JSON parsing
        try {
            questionsArray = JSON.parse(questionsJsonString);
            if (!Array.isArray(questionsArray)) {
                throw new Error("Parsed questions data is not an array.");
            }
        } catch (parseError) {
             // Fallback if JSON is invalid
             console.warn("Could not parse questions JSON. Displaying as single block.", parseError);
             questionsArray = [{ type: "long_answer", prompt: "Exam Instructions / Questions", content: questionsJsonString }];
        }

        totalQuestions = questionsArray.length; // Store the total number of questions
        console.log(`Total questions loaded: ${totalQuestions}`);

         // **Randomize Question Order**
         const originalIndices = questionsArray.map((_, index) => index);
         for (let i = originalIndices.length - 1; i > 0; i--) {
             const j = Math.floor(Math.random() * (i + 1));
             [originalIndices[i], originalIndices[j]] = [originalIndices[j], originalIndices[i]];
         }
         console.log("Shuffled display order (indices):", originalIndices);

         // Store Original Order Map for submission
         examDetails.OriginalOrderMap = {};
         questionsArray.forEach((q, index) => { examDetails.OriginalOrderMap[index] = q; });

        // **Display questions in the shuffled order**
        originalIndices.forEach((originalIndex, displayIndex) => {
            const q = questionsArray[originalIndex];
            const displayQNum = displayIndex + 1;
            const originalQNum = originalIndex + 1;
            const questionId = `q-${originalQNum}`; // Unique ID for the question container div
            const answerId = `ans-${originalQNum}`;
            const answerName = `ans-${originalQNum}`;

            const questionDiv = document.createElement('div');
            questionDiv.className = 'question form-group'; // Add 'form-group' if needed for styling
            questionDiv.id = questionId;
            questionDiv.dataset.originalIndex = originalIndex;

            let inputHtml = '';
            const promptText = q.prompt || `Question ${displayQNum}`;
            let questionContentHtml = '<div class="question-content">';

            switch (q.type) {
                case 'short_answer':
                    questionContentHtml += `<input type="text" id="${answerId}" name="${answerName}" class="form-control" placeholder="Enter your answer">`;
                    break;
                case 'long_answer':
                    questionContentHtml += `<textarea id="${answerId}" name="${answerName}" class="form-control" rows="5" placeholder="Enter your detailed answer">${q.content || ''}</textarea>`;
                    break;
                case 'code':
                    const langHint = q.language ? `(${q.language})` : '';
                    questionContentHtml += `<textarea id="${answerId}" name="${answerName}" class="form-control" rows="8" placeholder="Enter your code here ${langHint}" style="font-family: monospace; white-space: pre; overflow-wrap: normal; overflow-x: scroll;"></textarea>`;
                    // Generic note about length limits
                    questionContentHtml += `<small class="length-limit-note">Note: Very long code submissions might have length limitations.</small>`;
                    break;
                case 'attachment':
                     const allowedTypes = q.allowed_types || []; const acceptAttr = allowedTypes.join(',');
                     const maxSizeMB = q.max_size_mb; const maxBytes = maxSizeMB ? maxSizeMB * 1024 * 1024 : null;
                     questionContentHtml += `<input type="file" id="${answerId}" name="${answerName}" class="form-control" accept="${acceptAttr}" ${maxBytes ? `data-max-size="${maxBytes}"` : ''} data-allowed-types='${JSON.stringify(allowedTypes)}'> <small class="file-helper-text">Allowed: ${acceptAttr || 'any'}${maxSizeMB ? `, Max: ${maxSizeMB}MB` : ''}</small>`;
                     setTimeout(() => addAttachmentValidation(answerId), 0);
                     break;
                case 'multiple_select':
                     questionContentHtml += `<div class="checkbox-group" id="${answerId}">`;
                     if (Array.isArray(q.options)) {
                         q.options.forEach((option, optIndex) => {
                             const optionId = `${answerId}-opt${optIndex}`;
                             // Use 'form-control-checkbox' for consistency if needed by confirm/edit logic
                             questionContentHtml += `<div class="checkbox-item"><input type="checkbox" id="${optionId}" name="${answerName}" value="${option}" class="form-control-checkbox"><label for="${optionId}">${option}</label></div>`;
                         });
                     } else { questionContentHtml += `<p style="color:red;">Error: Options missing.</p>`; }
                     questionContentHtml += `</div>`;
                     break;
                default:
                     questionContentHtml += `<p style="color:red;">Unsupported type: ${q.type}</p><p>${q.content || ''}</p>`;
            }
            questionContentHtml += '</div>'; // End question-content

            // Add Confirm/Edit Buttons
            const actionsHtml = `<div class="question-actions">
                                  <button type="button" class="btn-confirm btn-orange btn-sm" onclick="confirmAnswer('${questionId}')"><i class="fas fa-check"></i> Confirm</button>
                                  <button type="button" class="btn-edit btn-grey btn-sm" onclick="editAnswer('${questionId}')"><i class="fas fa-pencil-alt"></i> Edit</button>
                               </div>`;

            // Assemble the full question block
            // Ensure the prompt label targets the primary input ID where appropriate
            const labelTargetId = (q.type === 'multiple_select' || q.type === 'attachment') ? questionId : answerId; // Target group or main input
            questionDiv.innerHTML = `<label for="${labelTargetId}">${promptText}</label>${questionContentHtml}${actionsHtml}`;
            examQuestionsArea.appendChild(questionDiv);
        });

    } catch (e) {
        console.error("Error processing or displaying questions:", e);
        examQuestionsArea.innerHTML = `<p style="color:red;">Error loading questions: ${e.message}.</p>`;
        showImprovedNotification('error', 'Question Display Error', `Could not display questions: ${e.message}`);
        if (submitExamBtn) submitExamBtn.disabled = true;
        totalQuestions = 0; // Ensure count is 0 on error
    }
    checkAllConfirmed(); // Initial check after displaying questions or on error
}


 // Confirms an answer
function confirmAnswer(questionId) {
    const questionDiv = document.getElementById(questionId);
    // Ignore if not found or already confirmed to prevent double counting
    if (!questionDiv || questionDiv.classList.contains('confirmed')) return;

    questionDiv.classList.add('confirmed');
    confirmedQuestionsCount++; // Increment count *only when confirming*

    // Disable all relevant input elements within this question
    const inputs = questionDiv.querySelectorAll('.form-control, .form-control-checkbox');
    inputs.forEach(input => { input.disabled = true; });

    console.log(`Confirmed answer for question: ${questionId}`);
    checkAllConfirmed(); // Update overall submit button status
}

// Enables editing for an answer
function editAnswer(questionId) {
    const questionDiv = document.getElementById(questionId);
     // Ignore if not found or not currently confirmed to prevent incorrect decrement
     if (!questionDiv || !questionDiv.classList.contains('confirmed')) return;

    questionDiv.classList.remove('confirmed');
    confirmedQuestionsCount--; // Decrement count *only when un-confirming*

    // Re-enable all relevant input elements
    const inputs = questionDiv.querySelectorAll('.form-control, .form-control-checkbox');
    inputs.forEach(input => { input.disabled = false; });

    console.log(`Enabled editing for question: ${questionId}`);
    checkAllConfirmed(); // Update overall submit button status
}



        // Adds validation listeners to file input elements
        function addAttachmentValidation(inputId) {
            const fileInput = document.getElementById(inputId);
            if (!fileInput || fileInput.type !== 'file') return;

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return; // No file selected

                const maxSize = parseInt(fileInput.getAttribute('data-max-size'), 10);
                const allowedTypes = JSON.parse(fileInput.getAttribute('data-allowed-types') || '[]');

                // Check file size
                if (maxSize && file.size > maxSize) {
                    const maxSizeMB = (maxSize / (1024 * 1024)).toFixed(1);
                    showImprovedNotification('error', 'File Too Large', `The file "${file.name}" (${(file.size / (1024 * 1024)).toFixed(1)}MB) exceeds the maximum allowed size of ${maxSizeMB}MB.`);
                    fileInput.value = ''; // Clear the invalid selection
                    return;
                }

                // Check file type
                if (allowedTypes.length > 0 && !allowedTypes.includes(file.type) && !allowedTypes.includes('.' + file.name.split('.').pop())) {
                    // Check both MIME type and extension as a fallback
                     showImprovedNotification('error', 'Invalid File Type', `The file type of "${file.name}" (${file.type || 'unknown'}) is not allowed. Allowed types: ${allowedTypes.join(', ')}`);
                     fileInput.value = ''; // Clear the invalid selection
                     return;
                 }

                // File is valid (passed checks)
                showImprovedNotification('success', 'File Selected', `Selected file: "${file.name}" (${(file.size / 1024).toFixed(1)}KB)`);
            });
        }

        // Starts the countdown timer
        function startTimer() {
            if (examTimerInterval) { // Prevent multiple timers
                console.warn("Timer is already running.");
                return;
            }
            // Ensure examEndTime is valid and in the future
            if (!examEndTime || isNaN(examEndTime) || examEndTime <= Date.now()) {
                console.error("Cannot start timer: Invalid or past exam end time.", examEndTime);
                timerDisplay.textContent = "Error";
                // Consider auto-submitting or showing an error message if deadline passed
                if (examEndTime && examEndTime <= Date.now()) {
                    showImprovedNotification('error', 'Deadline Passed', 'The time for this exam has already expired.', 0);
                    handleSubmitExam(true); // Auto-submit if deadline is already passed when starting timer
                }
                return;
            }
            console.log(`Timer starting. Target end time: ${new Date(examEndTime).toLocaleString()}`);
            updateTimerDisplay(); // Initial display update
            examTimerInterval = setInterval(updateTimerDisplay, 1000); // Update every second
        }

        // Updates the timer display every second
        function updateTimerDisplay() {
            if (!examEndTime) { // Should not happen if startTimer validated, but good safety check
                console.warn("Timer update called without a valid end time.");
                stopTimer();
                timerDisplay.textContent = "--:--";
                return;
            }

            const now = Date.now();
            const timeLeft = Math.max(0, examEndTime - now); // Time remaining in milliseconds

            // Calculate minutes and seconds
            const minutes = Math.floor(timeLeft / (1000 * 60));
            const seconds = Math.floor((timeLeft / 1000) % 60);

            // Format and display the time
            timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

            // Check if time is up
            if (timeLeft <= 0) {
                console.log("Exam time has expired!");
                stopTimer(); // Stop the interval
                showImprovedNotification('warning', "Time's Up!", 'The exam time has expired. Submitting automatically.', 0);
                handleSubmitExam(true); // Trigger automatic submission
            }
        }

        // Stops the countdown timer interval
        function stopTimer() {
            if (examTimerInterval) {
                clearInterval(examTimerInterval);
                examTimerInterval = null; // Clear the interval ID
                console.log("Timer stopped.");
            }
        }

        // Collects browser/device fingerprint data (basic)
// --- Modify this function ---
function getFingerprintData() { // No 'async' needed now

    // Call the WebGL helper function
    const webglFp = getWebglFingerprint();

    const data = {
        // --- Category 1: Basic Browser & Config ---
        ua: navigator.userAgent || 'N/A',
        lang: navigator.language || 'N/A',
        vendor: navigator.vendor || 'N/A',
        cookieEnabled: navigator.cookieEnabled || false,
        doNotTrack: navigator.doNotTrack || 'unknown',
        // Note: Plugins/MimeTypes require mapping/sorting as shown previously if needed
        plugins: Array.from(navigator.plugins || []).map(p => ({ name: p.name, filename: p.filename })).sort((a,b) => a.name.localeCompare(b.name)),
        mimeTypes: Array.from(navigator.mimeTypes || []).map(m => ({ type: m.type, description: m.description })).sort((a,b) => a.type.localeCompare(b.type)),

        // --- Category 2: Hardware / OS ---
        platform: navigator.platform || 'N/A',
        cores: navigator.hardwareConcurrency || undefined,
        memory: navigator.deviceMemory || undefined,
        maxTouchPoints: navigator.maxTouchPoints || 0,

        // --- Category 3: Screen & Display ---
        screenRes: `${screen.width || 0}x${screen.height || 0}x${screen.colorDepth || 0}`,
        availScreenRes: `${screen.availWidth || 0}x${screen.availHeight || 0}`,
        windowInnerSize: `${window.innerWidth || 0}x${window.innerHeight || 0}`,
        timezoneOffset: new Date().getTimezoneOffset(),

        // --- Category 4: GPU Info (from WebGL) ---
        webglAvailable: webglFp.available, // Was WebGL context available?
        webglVendor: webglFp.vendor,       // GPU Vendor string
        webglRenderer: webglFp.renderer,   // GPU Renderer string (often the model)

        // --- Timestamp ---
        ts: Date.now()
    };

    console.log("Collected Fingerprint Data:", data);
    return JSON.stringify(data); // Return as JSON string
}
		
		// Add this helper function if you haven't already
function getWebglFingerprint() {
    try {
        const canvas = document.createElement('canvas');
        // Try both standard and experimental contexts
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) {
            return { available: false, vendor: 'N/A', renderer: 'N/A' }; // WebGL not supported
        }
        // Get debug extension to potentially unmask renderer/vendor info
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        const vendor = gl.getParameter(debugInfo ? debugInfo.UNMASKED_VENDOR_WEBGL : gl.VENDOR);
        const renderer = gl.getParameter(debugInfo ? debugInfo.UNMASKED_RENDERER_WEBGL : gl.RENDERER);

        return {
            available: true,
            vendor: vendor || 'unknown',
            renderer: renderer || 'unknown'
        };
    } catch (e) {
        console.warn("WebGL fingerprinting failed:", e);
        return { available: false, vendor: 'error', renderer: 'error', errorMsg: e.message };
    }
}

        // Triggers a download of JSON data as a file
        function downloadJsonBackup(data, filename) {
            try {
                const jsonString = JSON.stringify(data, null, 2); // Pretty-print JSON
                const blob = new Blob([jsonString], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename; // Set the download filename
                document.body.appendChild(link); // Append link to body
                link.click(); // Programmatically click the link to trigger download
                document.body.removeChild(link); // Remove link from body
                URL.revokeObjectURL(url); // Release the object URL
                console.log("JSON backup download initiated:", filename);
                showImprovedNotification('info', 'Backup Saved', 'A JSON backup file of your submission has been downloaded.');
            } catch (e) {
                console.error("Error creating or triggering JSON backup download:", e);
                showImprovedNotification('error', 'Backup Error', 'Could not create the backup file. Please manually copy your answers if needed.');
            }
        }

// Handles the final exam submission process
async function handleSubmitExam(isAutoSubmit = false) {
    const timeIsUp = examEndTime && Date.now() >= examEndTime;
     if (timeIsUp && !isAutoSubmit) {
         console.warn("Manual submit clicked after deadline. Treating as auto-submit.");
         showImprovedNotification('warning', 'Deadline Passed', 'Time expired. Submitting automatically.');
         isAutoSubmit = true;
     }

    stopTimer(); // Stop the timer immediately

    // Disable submit button and show submitting state (always)
    submitExamBtn.disabled = true;
    submitExamBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';

    // --- Mandatory Confirmation Check for MANUAL submit ---
    if (!isAutoSubmit) {
        if (confirmedQuestionsCount !== totalQuestions) {
            showImprovedNotification('error', 'Not All Confirmed', `Please confirm all ${totalQuestions} questions before submitting. You have confirmed ${confirmedQuestionsCount}.`, 5000);
             // Do not re-enable timer here, just update button state
            checkAllConfirmed(); // This will keep it disabled but update text
            return; // Stop submission
        }
        // If all confirmed manually, ask for final user confirmation
        if (!confirm("You have confirmed all answers. Are you absolutely sure you want to submit your exam?\nThis action cannot be undone.")) {
             checkAllConfirmed(); // Re-enable button if online/all confirmed
             // Restart timer only if time still remains
             if (examEndTime && Date.now() < examEndTime) { startTimer(); }
             return; // Abort submission
         }
    }
    // --- End Manual Confirmation Check ---

    console.log("Processing submission..." + (isAutoSubmit ? " (Auto)" : " (Manual - All Confirmed)"));
    const answers = {}; // Object to hold answers
    const fingerprint = getFingerprintData(); // Get fingerprint (make sure this function exists and is synchronous)

    // Collect Answers - respecting ORIGINAL order AND confirmation status for auto-submit
    if (!examDetails || !examDetails.OriginalOrderMap || totalQuestions <= 0) {
        showImprovedNotification('error', 'Submission Error', 'Cannot collect answers. Exam data or question count is invalid.', 0);
        // Leave button disabled as something is wrong
        return;
    }

    const originalIndices = Object.keys(examDetails.OriginalOrderMap).map(Number).sort((a, b) => a - b);

    originalIndices.forEach(originalIndex => {
        const originalQNum = originalIndex + 1;
        const questionData = examDetails.OriginalOrderMap[originalIndex];
        const answerName = `ans-${originalQNum}`;
        const questionDivId = `q-${originalQNum}`;
        const questionDiv = document.getElementById(questionDivId);
        // Check confirmation status *reliably*
        const isConfirmed = questionDiv ? questionDiv.classList.contains('confirmed') : false;

        // For AUTO submit, ONLY collect CONFIRMED answers.
        // For MANUAL submit, collect ALL (we already checked they are all confirmed).
        if (isAutoSubmit && !isConfirmed) {
            answers[answerName] = "[NOT CONFIRMED]"; // Mark unconfirmed answers explicitly
            console.log(`Auto-submit: Answer for ${answerName} was not confirmed.`);
        } else {
            // Collect answer normally (manual submit OR confirmed auto-submit)
            const formElementsWithName = examForm.elements[answerName];
            if (formElementsWithName) {
                switch (questionData.type) {
                    case 'attachment':
                        const fileInput = formElementsWithName;
                        answers[answerName] = (fileInput.files && fileInput.files.length > 0)
                            ? `FILE_UPLOADED:${fileInput.files[0].name}` // Placeholder
                            : '';
                        break;
                    case 'multiple_select':
                        const checkboxes = Array.isArray(formElementsWithName) ? formElementsWithName : [formElementsWithName];
                        answers[answerName] = checkboxes.filter(cb => cb.checked).map(cb => cb.value);
                        break;
                    default: // short_answer, long_answer, code
                        // Ensure element has a 'value' property (e.g., not a fieldset)
                        answers[answerName] = (typeof formElementsWithName.value !== 'undefined') ? formElementsWithName.value : 'ERROR_NO_VALUE_PROP';
                        break;
                }
            } else {
                console.warn(`Could not find form element for answer: ${answerName}`);
                answers[answerName] = 'ERROR_ELEMENT_NOT_FOUND';
            }
        }
    });


    const answersJson = JSON.stringify(answers);
    console.log("Collected Answers for Submission:", answersJson);

    // --- Create Backup Data ---
     const backupData = {
         submissionTimestamp: new Date().toISOString(),
         examDetails: { PIN: examDetails?.PIN, Name: examDetails?.Name, Mode: examDetails?.Mode, Code: examDetails?.Code },
         studentInfo: { pinEntered: studentPINEntered, studentExamId: examDetails?.Mode === 'exam' ? studentExamIdEntered : undefined, name: currentUser?.name, email: currentUser?.email },
         answers: answers, // Keep raw answers object
         fingerprint: JSON.parse(fingerprint), // Keep parsed object
         submittedLate: timeIsUp,
         autoSubmitted: isAutoSubmit, // Flag if it was an auto-submit
         confirmedCountOnSubmit: confirmedQuestionsCount, // Record how many were confirmed
         totalQuestionsOnSubmit: totalQuestions // Record total questions
     };
     const backupFilename = `exam_backup_${examDetails?.PIN || 'unknown'}_${(currentUser?.email || studentExamIdEntered || 'anon').replace(/@.*/, '')}_${Date.now()}.json`;
     downloadJsonBackup(backupData, backupFilename);


    // --- Update or Append Logic ---
    let submissionSuccess = false;
    if (!currentUser || !examDetails) { /* Error handling */ return; }
    const currentMode = examDetails.Mode.toLowerCase();
    console.log("Looking for existing 'start' record to update...");
    const startRecordInfo = await findAttemptRecord( currentUser.email, examDetails.PIN, studentExamIdEntered, currentMode, 'start' );
    if (startRecordInfo) {
         const rowToUpdate = startRecordInfo.rowNumber; console.log(`Found 'start' record at row ${rowToUpdate}. Updating...`);
         const updateRange = `${EXAM_ATTEMPTS_SHEET_NAME}!G${rowToUpdate}:I${rowToUpdate}`;
         const updateValues = [[ 'submit', answersJson, fingerprint ]];
         submissionSuccess = await updateSheetData(EXAM_SPREADSHEET_ID, updateRange, updateValues);
         if (!submissionSuccess) { showImprovedNotification('error', 'Submission Failed', 'Failed to update attempt record online (backup downloaded).', 0); }
    } else {
         console.warn("No 'start' record found. Appending 'submit' record as fallback.");
         showImprovedNotification('warning','Submission Warning','Could not find start record. Creating new submission entry.');
         submissionSuccess = await recordExamAttempt('submit', answers, fingerprint); // Pass answers OBJECT
         if (!submissionSuccess) { showImprovedNotification('error', 'Submission Failed', 'Failed to save new attempt record online (backup downloaded).', 0); }
    }

    // --- Final UI Update ---
    if (submissionSuccess) {
        showImprovedNotification('success', 'Exam Submitted Successfully!', `Your submission (${isAutoSubmit ? confirmedQuestionsCount + '/' + totalQuestions + ' confirmed answers' : 'all answers confirmed'}) has been recorded.`, 0);
        examQuestionsModule.classList.add('hidden');
        submissionConfirmationModule.classList.remove('hidden');
        localStorage.removeItem(appStateKey);
        // Reset state variables fully
        examDetails = null; studentPINEntered = ''; studentExamIdEntered = ''; examEndTime = null; totalQuestions = 0; confirmedQuestionsCount = 0;
    } else {
         console.error("Online submission failed after backup.");
         // Error notifications already shown
         // Re-enable button ONLY if manual submit failed, allowing retry
         if (!isAutoSubmit) {
             checkAllConfirmed(); // Update button state (will likely remain disabled if offline)
         } else {
             showImprovedNotification('error', 'Auto-Submit Failed', 'Could not automatically save submission online. Backup downloaded.', 0);
             // Keep button disabled
         }
    }
}


        // Records an attempt by APPENDING a new row (used for 'start' or fallback 'submit')
         async function recordExamAttempt(status, answersObject = null, fingerprintString = null) {
             if (!currentUser || !examDetails || !studentPINEntered) {
                 console.error("Cannot record attempt: Missing user, exam details, or PIN.");
                 return false; // Cannot proceed
             }

             const timestamp = new Date().toISOString(); // ISO 8601 format timestamp
             const isQuizMode = examDetails.Mode.toLowerCase() === 'quiz';

             // Use fingerprint passed in, or generate if called for 'start' status and none provided
             const finalFingerprintJson = fingerprintString ? fingerprintString : (status === 'start' ? getFingerprintData() : '{}');
             // Use answers passed in (should be null/empty for 'start'), stringify if provided
             const finalAnswersJson = answersObject ? JSON.stringify(answersObject) : '';

             // Prepare the row data according to the 'Attempts' sheet columns
             // Columns: Timestamp, Name, Email, PIN, CourseCode, StudentExamID, Status, Answers, Fingerprint
             const dataRow = [
                 timestamp,                                          // Col A: Timestamp
                 isQuizMode ? String(currentUser.name) : '',         // Col B: Name (only for Quiz)
                 isQuizMode ? String(currentUser.email) : '',        // Col C: Email (only for Quiz)
                 String(studentPINEntered),                          // Col D: PIN (always included)
                 String(examDetails.Code),                           // Col E: Course Code
                 isQuizMode ? '' : String(studentExamIdEntered),     // Col F: StudentExamID (only for Exam, use stored ID)
                 String(status),                                     // Col G: Status ('start' or 'submit')
                 finalAnswersJson,                                   // Col H: Answers (JSON string, empty for 'start')
                 finalFingerprintJson                                // Col I: Fingerprint (JSON string)
             ];

             console.log(`Attempting to append attempt record with status '${status}':`, dataRow);

             // Use the appendSheetData helper function
             const success = await appendSheetData(
                 EXAM_SPREADSHEET_ID,
                 EXAM_ATTEMPTS_SHEET_NAME,
                 [dataRow] // Pass the single row as an array of rows
             );

             if (success) {
                 console.log(`Successfully appended attempt record with status '${status}'.`);
             } else {
                 console.error(`Failed to append attempt record with status '${status}'.`);
                 // Notification is handled within appendSheetData
             }
             return success; // Return success status
         }

// Updates online status and related UI elements
function updateOnlineStatus() {
    isOnline = navigator.onLine;
    console.log('Connection Status:', isOnline ? 'Online' : 'Offline');
    const statusIcon = syncStatus?.querySelector('i');

    if (isOnline) {
        syncStatus.className = 'sync-status online';
        if (statusIcon) statusIcon.style.color = 'var(--success-color)';
        if (syncText) syncText.textContent = 'Online';
    } else {
        syncStatus.className = 'sync-status offline';
        if (statusIcon) statusIcon.style.color = 'var(--warning-color)';
        if (syncText) syncText.textContent = 'Offline';
         if (!isInitializing) {
            showImprovedNotification('warning', 'Offline', 'You are currently offline. Saving and submission are disabled.', 5000);
         }
    }

    if (statusIcon && !isSyncing) {
        statusIcon.className = 'fas fa-circle';
    }

    // Update button states based on online status
    if (loadExamBtn) {
         loadExamBtn.disabled = !isOnline || !isSignedIn || (examPinInput && examPinInput.value.trim() === '');
     }
     let startDisabled = !isOnline || !isSignedIn || !examDetails;
     const isExamModeActive = examDetails && examDetails.Mode === 'exam';
     if (isExamModeActive) {
         startDisabled = startDisabled || (studentExamIdInput && studentExamIdInput.value.trim().length !== 5);
         if (startExamBtnAlt) startExamBtnAlt.disabled = startDisabled;
         if (startExamBtn) startExamBtn.disabled = true;
     } else {
         if (startExamBtn) startExamBtn.disabled = startDisabled;
         if (startExamBtnAlt && examDetails) startExamBtnAlt.classList.add('hidden');
    }

    // Let checkAllConfirmed handle the submit button state considering online status
    checkAllConfirmed();

    if (isInitializing && (typeof gapi !== 'undefined')) {
        isInitializing = false;
        console.log("Initialisation process complete.");
    }
}

        // Updates the sync status indicator UI
        function setSyncing(syncing) {
            isSyncing = syncing;
            console.log("Network Syncing:", isSyncing);
            const statusIcon = syncStatus?.querySelector('i');
            if (statusIcon) {
                if (syncing) {
                    statusIcon.className = 'fas fa-spinner fa-spin'; // Spinning icon
                    statusIcon.style.color = 'var(--info-color)'; // Use info color for syncing
                    if (syncText) syncText.textContent = 'Syncing...';
                } else {
                    // Revert to online/offline status display
                    updateOnlineStatus();
                }
            }
        }

        // Displays dismissible notifications at the bottom-right
        function showImprovedNotification(type, title, message, duration = 5000) {
            const container = notificationArea;
            if (!container) {
                console.error("Notification container element not found in the DOM.");
                return; // Cannot display notification
            }

            // Create notification element
            const notification = document.createElement('div');
            notification.className = `in-page-notification in-page-notification-${type}`; // Base + type class

            // Determine icon based on type
            let iconClass;
            switch (type) {
                case 'success': iconClass = 'fa-check-circle'; break;
                case 'error':   iconClass = 'fa-times-circle'; break;
                case 'warning': iconClass = 'fa-exclamation-triangle'; break;
                default:        iconClass = 'fa-info-circle'; // Default to info
            }

            // Set inner HTML with icon, title, message, and close button
            notification.innerHTML = `<i class="fas ${iconClass} fa-icon"></i>
                                      <div class="notification-content"><strong>${title}</strong><br>${message.replace(/\n/g, '<br>')}</div>
                                      <button type="button" class="notification-close" aria-label="Close">&times;</button>`;

            container.appendChild(notification); // Add to the DOM

            // Get close button and add click listener for manual dismissal
            const closeBtn = notification.querySelector('.notification-close');
            const removeNotification = () => {
                notification.classList.add('removing'); // Add class to trigger slide-out animation
                // Remove the element after the animation completes
                setTimeout(() => {
                    // Check if parentNode still exists before removing
                    if (notification.parentNode) {
                         notification.parentNode.removeChild(notification);
                    }
                }, 300); // Match timeout to CSS animation duration
            };

            closeBtn?.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                removeNotification();
            });

            // Auto-dismiss after duration (if duration > 0)
            if (duration > 0) {
                setTimeout(removeNotification, duration);
            }
        }

        // === State Persistence ===

        // Saves the current relevant state to localStorage
        function saveAppState() {
             // Only save state if an exam is actively loaded or in progress
            if (!examDetails || (examQuestionsModule && examQuestionsModule.classList.contains('hidden') && !submissionConfirmationModule.classList.contains('hidden'))) {
                 // Don't save if no exam loaded, or if exam is finished (confirmation shown)
                 // If questions module is hidden but confirmation is also hidden, it means we are in setup phase, safe to save.
                 if (examQuestionsModule && examQuestionsModule.classList.contains('hidden') && submissionConfirmationModule.classList.contains('hidden')) {
                     // Proceed to save setup state (PIN entered etc.)
                 } else {
                    console.log("Not saving state: Exam not active or already submitted.");
                    // Consider explicitly clearing state if submission occurred but wasn't cleared?
                    // localStorage.removeItem(appStateKey);
                    return;
                 }
             }

            try {
                const state = {
                    // Auth info
                    isSignedIn: isSignedIn,
                    currentUserEmail: currentUser?.email, // Save email to match state to user

                    // Exam progress info
                    examDetails: examDetails, // Includes PIN, Mode, Questions JSON, OriginalOrderMap etc.
                    studentPINEntered: studentPINEntered, // PIN used to load this exam
                    studentExamIdEntered: studentExamIdEntered, // Student ID if Exam mode
                    examEndTime: examEndTime, // Crucial for resuming timer
                    // Potentially save current answers periodically here if needed (more complex)
                    // currentAnswers: collectCurrentAnswers() // Example placeholder
                };
                localStorage.setItem(appStateKey, JSON.stringify(state));
                console.log("Application state saved to localStorage.");
            } catch (e) {
                console.error("Error saving application state to localStorage:", e);
                // Handle potential storage limits or errors
            }
        }

        // Loads state from localStorage on initial page load
        function loadAppState() {
            const savedStateString = localStorage.getItem(appStateKey);
            if (!savedStateString) {
                console.log("No saved application state found in localStorage.");
                return; // Nothing to load
            }
            try {
                const state = JSON.parse(savedStateString);
                console.log("Found saved application state:", state);
                // **Important:** Don't automatically apply the state here.
                // The `tokenObtained` function will check this loaded state against the
                // *currently signed-in user* before deciding whether to restore it.
                // This prevents loading User A's state if User B signs in.
                // We just load it here so it's available for that check later.
            } catch (e) {
                console.error("Error parsing saved application state from localStorage:", e);
                localStorage.removeItem(appStateKey); // Clear corrupted state
            }
        }

        // Restores the application UI and state based on loaded data (called after user signs in and state matches)
        function restoreAppState(state) {
            console.log("Restoring application state...");

            // Restore key state variables
            examDetails = state.examDetails;
            studentPINEntered = state.studentPINEntered;
            studentExamIdEntered = state.studentExamIdEntered;
            examEndTime = state.examEndTime;

             // Validate restored end time
             if (!examEndTime || isNaN(examEndTime) || Date.now() >= examEndTime) {
                 console.warn("Restored exam state has expired or end time is invalid. Clearing state.");
                 localStorage.removeItem(appStateKey); // Clear expired state
                 resetExamState(); // Reset UI
                 showImprovedNotification('warning', 'Session Expired', 'Your previous exam session has expired.', 0);
                 return; // Stop restoration
             }


             showImprovedNotification('info', 'Exam Session Restored', 'Resuming your previous exam session.', 5000);

             // --- Rebuild UI to match the restored state ---
             // Hide setup modules
             signinPromptModule.classList.add('hidden');
             examStartModule.classList.add('hidden');
             examDetailsModule.classList.add('hidden');
             submissionConfirmationModule.classList.add('hidden');

             // Show questions module
             examQuestionsModule.classList.remove('hidden');

             // Display header info
             displayExamDetailsHeader();

             // Display the questions (will handle randomization based on stored map if needed)
             // Ensure the OriginalOrderMap exists before displaying
             if (examDetails && examDetails.Questions && examDetails.OriginalOrderMap) {
                 displayQuestions(examDetails.Questions);
                 // **TODO (Optional but Recommended):** Implement logic here to refill answers
                 // based on `state.currentAnswers` if you added periodic saving.
                 // Example: populateRestoredAnswers(state.currentAnswers);
             } else {
                  console.error("Cannot restore questions display: Missing Questions or Order Map in saved state.");
                   showImprovedNotification('error', 'Restore Failed', 'Could not restore exam questions. State might be corrupted.', 0);
                   localStorage.removeItem(appStateKey);
                   resetExamState();
                   return;
             }


             // Restart the timer
             startTimer();

             // Ensure submit button is enabled (subject to online status)
             if (submitExamBtn) submitExamBtn.disabled = !isOnline;

             console.log("Application state restored successfully.");
         }

    </script>
</body>
</html>