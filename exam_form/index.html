<!DOCTYPE html>
<html lang="en-GB"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Exam Portal</title>
    <link rel="icon" type="image/png" href="https://bredliplaku.github.io/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        /* --- CSS --- */
        :root {
            --primary-color: #3949ab;
            --primary-dark: #1a237e;
            --success-color: #43a047;
            --warning-color: #fb8c00;
            --info-color: #2196F3;
            --danger-color: #f44336;
            --text-light: #fff;
            --confirmed-bg: #f8f8f8;
            --confirmed-text: #dcdcdc; /* Very light grey */
            --confirmed-opacity: 0.3; /* Lower opacity */
        }
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body, html {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            background: #ffffff;
            color: #333;
        }
        .container {
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
        }
        .app-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }
        .app-loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loading-spinner {
            border: 5px solid rgba(57, 73, 171, 0.2);
            border-top: 5px solid #3949ab;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0%   { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .content-hidden {
            visibility: hidden;
            opacity: 0;
        }
        .content-visible {
            visibility: visible;
            opacity: 1;
            transition: opacity 0.5s ease-in;
        }
        .app-header {
            background: linear-gradient(135deg, #3949ab, #1a237e);
            color: white;
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2.0em;
            display: flex;
            align-items: center;
        }
        h1 i {
            margin-right: 10px;
        }
        h2 {
            margin: 0 0 2px 0;
            font-weight: 400;
            font-size: 1.0em;
        }
        .app-info {
            display: flex;
            flex-wrap: wrap;
            margin-top: 15px;
            gap: 10px;
        }
        .info-item {
            background-color: rgba(255,255,255,0.1);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9em;
            line-height: 30px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        .module {
            background-color: #fff;
            border-radius: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            overflow: hidden;
        }
        .module-header {
            background-color: #3949ab;
            color: white;
            padding: 15px;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .module-title {
            font-size: 1.1em;
            display: flex;
            align-items: center;
        }
        .module-title i {
            margin-right: 10px;
        }
        .module-content {
            padding: 20px;
        }
        .not-signed-in-message {
            text-align: center;
            padding: 20px;
            margin-top: 15px;
            border-radius: 15px;
            background-color: rgba(57, 73, 171, 0.1);
            color: #333;
        }
        button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background-color: var(--primary-color);
            color: var(--text-light);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            transition: background-color 0.3s, transform 0.3s, opacity 0.3s;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 0;
            cursor: pointer;
        }
        button:hover:not(:disabled) { /* Add :not(:disabled) */
            background-color: var(--primary-dark);
            transform: scale(1.05);
        }
        button:disabled {
            background-color: #aaa;
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .btn-green {
            background-color: var(--success-color);
        }
        .btn-blue {
            background-color: var(--info-color);
        }
        .btn-orange {
             background-color: var(--warning-color);
        }
        .btn-grey {
             background-color: #6c757d; /* Bootstrap secondary grey */
        }
        .btn-sm {
            padding: 6px 12px;
            font-size: 0.85em;
            border-radius: 15px;
        }
        .in-page-notifications {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            width: 350px;
            max-width: 90%;
            pointer-events: none;
        }
        .in-page-notification {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: slide-in 0.3s ease-out forwards;
            overflow: hidden;
            display: flex;
            align-items: center;
            opacity: 1;
            transition: transform 0.3s ease-in, opacity 0.3s ease-in;
            pointer-events: auto;
        }
        .in-page-notification.removing {
            opacity: 0;
            transform: translateX(100%);
        }
        @keyframes slide-in {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .in-page-notification i.fa-icon {
            margin-right: 10px;
            font-size: 1.2em;
            flex-shrink: 0;
        }
        .notification-content {
            flex-grow: 1;
        }
        .notification-close {
            background: none;
            border: none;
            font-size: 20px;
            line-height: 1;
            color: inherit;
            opacity: 0.7;
            padding: 0 5px;
            margin-left: 10px;
            cursor: pointer;
        }
        .notification-close:hover {
            opacity: 1;
        }
        .in-page-notification-info {
            background-color: #e3f2fd;
            color: #0d47a1;
        }
        .in-page-notification-warning {
            background-color: #fff3e0;
            color: #e65100;
        }
        .in-page-notification-error {
            background-color: #ffebee;
            color: #b71c1c;
        }
        .in-page-notification-success {
            background-color: #e8f5e9;
            color: #1b5e20;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .form-control {
            width: 100%;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
            transition: opacity 0.3s, background-color 0.3s, color 0.3s; /* Added color transition */
            /* Default state */
            background-color: #fff;
            color: #333;
            opacity: 1;
        }
        input:disabled, textarea:disabled, input[type="checkbox"]:disabled + label {
            /* Basic disabled style - overridden by .confirmed styles */
            background-color: #eee;
            cursor: not-allowed;
            opacity: 0.7;
        }
        textarea.form-control {
            min-height: 100px;
        }
        .footer {
            margin-top: 40px;
            text-align: center;
            padding: 20px 0;
            color: var(--primary-dark);
            border-top: 1px solid #eee;
        }
        .auth-container {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
        }
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
        }
        .sync-auth-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .sync-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .sync-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9em;
        }
        .sync-status.online i {
            color: var(--success-color);
        }
        .sync-status.offline i {
            color: var(--warning-color);
        }
        #exam-details-display p {
            margin: 8px 0;
        }
        #exam-details-display strong {
            color: var(--primary-dark);
            margin-right: 5px;
        }
        #exam-questions-area {
            margin-top: 20px;
            padding: 20px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 10px;
        }
        #exam-questions-area .question {
            margin-bottom: 25px;
            padding: 20px;
            border-bottom: 1px dashed #ddd;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
            transition: background-color 0.3s; /* Transition for background */
        }
        #exam-questions-area .question:last-child {
            border-bottom: none;
        }
        #exam-questions-area label { /* Question prompt label */
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
        }
        #exam-questions-area .question-content {
             margin-bottom: 15px;
        }
        #exam-questions-area .question-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: flex-end;
        }

        /* --- Enhanced Styling for Confirmed State --- */
        .question.confirmed {
             background-color: #fdfdfd; /* Slightly off-white background for the whole block */
        }

        /* Style inputs/textareas/checkbox items when confirmed */
        .question.confirmed .form-control,
        .question.confirmed .checkbox-item {
            opacity: var(--confirmed-opacity) !important; /* Use important if necessary, lower opacity */
            background-color: var(--confirmed-bg) !important; /* Light background */
            color: var(--confirmed-text) !important; /* Very light text color */
            pointer-events: none !important; /* Disable interaction */
            cursor: default !important; /* Change cursor */
            border-color: #e0e0e0 !important; /* Lighter border */
        }

        /* Ensure labels next to checkboxes are also affected */
        .question.confirmed .checkbox-item label {
             color: var(--confirmed-text) !important;
             cursor: default !important;
        }

         /* Ensure checkbox itself looks disabled */
         .question.confirmed .form-control-checkbox {
             cursor: default !important;
         }

        /* Hide edit button by default */
        .btn-edit { display: none; }
        /* Show edit button when confirmed */
        .question.confirmed .btn-edit { display: inline-flex; }
        /* Hide confirm button when confirmed */
        .question.confirmed .btn-confirm { display: none; }

        /* Multiple Select Checkbox Styling */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            transition: opacity 0.3s, background-color 0.3s, color 0.3s;
            padding: 5px;
            border-radius: 4px;
        }
        .checkbox-item input[type="checkbox"] { /* Specific class */
            margin-right: 8px;
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
         .checkbox-item label { /* Label specific to checkbox items */
             margin-bottom: 0;
             font-weight: normal;
             cursor: pointer;
             flex-grow: 1;
             transition: color 0.3s;
         }

        #submit-exam-btn {
            margin-top: 30px;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
        }
        .hidden {
            display: none !important;
        }
        #timer-display {
            font-weight: bold;
        }
        .confirmation-message {
            text-align: center;
            font-weight: bold;
            color: var(--success-color);
            padding: 30px;
            font-size: 1.2em;
        }
        .file-helper-text {
            display: block;
            margin-top: 5px;
            color: #666;
            font-size: 0.85em;
        }
        /* Small text for length limitation note */
        .length-limit-note {
            display: block;
            margin-top: 5px;
            color: #757575; /* Slightly muted color */
            font-size: 0.8em;
            font-style: italic;
        }
        @media (max-width: 768px) {
            .sync-auth-container {
                flex-direction: column-reverse;
                align-items: flex-end;
                gap: 10px;
                border-bottom: none;
            }
            .auth-container,
            .sync-container {
                width: 100%;
                justify-content: flex-end;
            }
            .in-page-notifications {
                width: 90%;
                left: 50%;
                transform: translateX(-50%);
            }
        }
    </style>
</head>
<body class="content-hidden">
    <div id="app-loading" class="app-loading">
        <img src="https://raw.githubusercontent.com/bredliplaku/bredliplaku.github.io/refs/heads/main/loading.gif" alt="Loading..." style="width: 150px; height: 150px;">
        <div style="margin-top: 10px; font-size: 14px; color: #666;">Loading Exam Portal...</div>
    </div>
    <div class="container" id="main-container">
        <div class="sync-auth-container">
            <div class="sync-container">
                 <div id="sync-status" class="sync-status offline">
                    <i class="fas fa-circle"></i>
                    <span id="sync-text">Offline</span>
                </div>
            </div>
            <div class="auth-container">
                 <div id="login-container">
                    <button id="login-btn" class="btn-blue">
                        <i class="fas fa-sign-in-alt"></i> Sign in
                    </button>
                </div>
                <div id="user-container" style="display: none">
                    <div class="user-info">
                        <img id="user-avatar" class="user-avatar" src="" alt="Avatar">
                        <span id="user-name"></span>
                         <button id="logout-btn" class="btn-sm">
                            <i class="fas fa-sign-out-alt"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <div class="app-header">
            <h1><i class="fas fa-file-alt"></i> Exam Portal</h1>
            <h2 id="exam-name-header">Please sign in to load the exam</h2>
            <div class="app-info">
                <span class="info-item">
                     <i class="fas fa-barcode"></i> Course:
                    <span id="exam-code-display">N/A</span>
                </span>
                <span class="info-item">
                    <i class="fas fa-stopwatch"></i> Duration:
                     <span id="exam-duration-display">N/A</span>
                </span>
                <span class="info-item">
                    <i class="fas fa-calendar-alt"></i> Available From:
                    <span id="exam-start-time-display">N/A</span>
                 </span>
            </div>
        </div>
        <div id="in-page-notification-area" class="in-page-notifications"></div>
        <div id="signin-prompt-module" class="module">
            <div class="module-content not-signed-in-message">
                <h3><i class="fas fa-info-circle"></i> Welcome</h3>
                <p>Sign in with your University Google Account.</p>
            </div>
        </div>
        <div id="exam-start-module" class="module hidden">
            <div class="module-header">
                <span class="module-title">
                    <i class="fas fa-user-check"></i> Student Details &amp; Exam Access
                </span>
            </div>
            <div class="module-content">
                <div class="form-group">
                    <label for="student-name">Name:</label>
                     <input type="text" id="student-name" class="form-control" disabled>
                </div>
                <div class="form-group">
                    <label for="student-email">Email:</label>
                    <input type="email" id="student-email" class="form-control" disabled>
                </div>
                  <div class="form-group">
                    <label for="exam-pin-input">Exam PIN:</label>
                    <input type="text" id="exam-pin-input" class="form-control" placeholder="Enter the Exam PIN provided">
                </div>
                <div id="student-exam-id-group" class="form-group hidden">
                    <label for="student-exam-id-input">Student Exam ID (Confidential - 5 characters):</label>
                    <input type="text" id="student-exam-id-input" class="form-control" placeholder="Enter 5-character ID" maxlength="5">
                </div>
                <button id="load-exam-btn" class="btn-blue" disabled>
                     <i class="fas fa-download"></i> Load Exam Details
                </button>
                <button id="start-exam-btn-alt" class="btn-green hidden" disabled>
                    <i class="fas fa-play"></i> Start Exam
                </button>
             </div>
        </div>
        <div id="exam-details-module" class="module hidden">
            <div class="module-header">
                <span class="module-title">
                    <i class="fas fa-info-circle"></i> Exam Information
                </span>
             </div>
            <div class="module-content" id="exam-details-display">
                <p>
                    <strong>Exam Name:</strong>
                    <span id="exam-name-detail"></span>
                </p>
                 <p>
                    <strong>Course Code:</strong>
                    <span id="exam-course-code-detail"></span>
                </p>
                <p>
                      <strong>Mode:</strong>
                    <span id="exam-mode-detail"></span>
                </p>
                <p>
                    <strong>Duration:</strong>
                    <span id="exam-duration-detail"></span>
                 </p>
                <p>
                    <strong>Available From:</strong>
                    <span id="exam-start-time-detail"></span>
                </p>
                 <button id="start-exam-btn" class="btn-green" disabled>
                    <i class="fas fa-play"></i> Start Exam
                </button>
            </div>
        </div>
        <div id="exam-questions-module" class="module hidden">
            <div class="module-header">
                 <span class="module-title">
                    <i class="fas fa-question-circle"></i> Exam Questions
                </span>
                <span class="info-item" style="background-color: var(--danger-color); color: white;">
                    <i class="fas fa-stopwatch"></i> Time Left:
                    <span id="timer-display">--:--</span>
                </span>
            </div>
            <div class="module-content">
                 <form id="exam-form">
                    <div id="exam-questions-area">
                        <p>Loading questions...</p>
                    </div>
                    <button type="button" id="submit-exam-btn" class="btn-green" disabled> <i class="fas fa-check-circle"></i> Submit Exam (Confirm All First)
                    </button>
                </form>
            </div>
        </div>
        <div id="submission-confirmation-module" class="module hidden">
              <div class="module-content confirmation-message">
                <i class="fas fa-check-circle fa-3x" style="color: var(--success-color); margin-bottom: 15px;"></i><br>
                Exam Submitted Successfully!
            </div>
        </div>
        <footer class="footer">
            <div class="social-links"></div>
            <p style="font-size:0.7em">
                <i class="far fa-copyright"></i> 2023-<span id="currentYear"></span> Your University/Dept. All Rights Reserved.
             </p>
        </footer>
    </div>

    <script>
        // === Configuration ===
        const ADMIN_EMAILS = ['bplaku@epoka.edu.al'];
        const CLIENT_ID = '740588046540-npg0crodtcuinveu6bua9rd6c3hb2s1m.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyD295FTtMHvXxZablRf0f-FR-IQ2dQRPQE'; // Replace with your actual API Key
        const EXAM_SPREADSHEET_ID = '14SgW9V3ZLYDqqoAutkvHEuLvcogpJ2hMEj_qj72wmEw';
        const EXAM_DETAILS_SHEET_NAME = 'Exams'; // Columns: PIN, Code, Name, Duration, StartDate (YYYY-MM-DD), StartTime (HH:MM:SS), Mode, Questions (JSON)
        const EXAM_ATTEMPTS_SHEET_NAME = 'Attempts'; // Columns: Timestamp, Name, Email, PIN, CourseCode, StudentExamID, Status, Answers (JSON), Fingerprint (JSON)

        const DISCOVERY_DOCS = ["https://sheets.googleapis.com/$discovery/rest?version=v4"];
        const SCOPES = "https://www.googleapis.com/auth/spreadsheets https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile";

        // === App State ===
        let isAdmin = false;
        let isSignedIn = false;
        let currentUser = null;
        let tokenClient = null;
        let isOnline = navigator.onLine;
        let isSyncing = false;
        let isInitializing = true;
        let examDetails = null;
        let studentPINEntered = '';
        let studentExamIdEntered = '';
        let examTimerInterval = null;
        let examEndTime = null;
        const appStateKey = 'examAppState';
        let totalQuestions = 0; // To track total number of questions displayed

        // === DOM Elements ===
        const loadingIndicator      = document.getElementById('app-loading');
        const mainContainer         = document.getElementById('main-container');
        const syncStatus            = document.getElementById('sync-status');
        const syncText              = document.getElementById('sync-text');
        const loginBtn              = document.getElementById('login-btn');
        const logoutBtn             = document.getElementById('logout-btn');
        const loginContainer        = document.getElementById('login-container');
        const userContainer         = document.getElementById('user-container');
        const userName              = document.getElementById('user-name');
        const userAvatar            = document.getElementById('user-avatar');
        const notificationArea      = document.getElementById('in-page-notification-area');
        const examNameHeader        = document.getElementById('exam-name-header');
        const examCodeDisplay       = document.getElementById('exam-code-display');
        const examDurationDisplay   = document.getElementById('exam-duration-display');
        const examStartTimeDisplay  = document.getElementById('exam-start-time-display');
        const signinPromptModule    = document.getElementById('signin-prompt-module');
        const examStartModule       = document.getElementById('exam-start-module');
        const studentNameInput      = document.getElementById('student-name');
        const studentEmailInput     = document.getElementById('student-email');
        const examPinInput          = document.getElementById('exam-pin-input');
        const studentExamIdGroup    = document.getElementById('student-exam-id-group');
        const studentExamIdInput    = document.getElementById('student-exam-id-input');
        const loadExamBtn           = document.getElementById('load-exam-btn');
        const examDetailsModule     = document.getElementById('exam-details-module');
        const examDetailsDisplay    = document.getElementById('exam-details-display');
        const examNameDetail        = document.getElementById('exam-name-detail');
        const examCourseCodeDetail  = document.getElementById('exam-course-code-detail');
        const examModeDetail        = document.getElementById('exam-mode-detail');
        const examDurationDetail    = document.getElementById('exam-duration-detail');
        const examStartTimeDetail   = document.getElementById('exam-start-time-detail');
        const startExamBtn          = document.getElementById('start-exam-btn');
        const startExamBtnAlt       = document.getElementById('start-exam-btn-alt');
        const examQuestionsModule   = document.getElementById('exam-questions-module');
        const examForm              = document.getElementById('exam-form');
        const examQuestionsArea     = document.getElementById('exam-questions-area');
        const submitExamBtn         = document.getElementById('submit-exam-btn');
        const timerDisplay          = document.getElementById('timer-display');
        const submissionConfirmationModule = document.getElementById('submission-confirmation-module');

        // === Initialisation ===
        window.addEventListener('load', init);

        function init() {
            console.log("Initialising...");
            document.body.classList.remove('content-hidden');
            mainContainer.classList.add('content-visible');
            updateYear();
            setupEventListeners();
            loadAppState();
            updateOnlineStatus();
            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);

            setTimeout(() => {
                if (typeof gapi !== 'undefined' && typeof google !== 'undefined') {
                    initGoogleApi();
                } else {
                    handleApiInitError(new Error("Google API objects not loaded"));
                }
            }, 500);
        }

        function setupEventListeners() {
            loginBtn?.addEventListener('click', handleAuthClick);
            logoutBtn?.addEventListener('click', handleSignoutClick);
            loadExamBtn?.addEventListener('click', handleLoadExam);
            startExamBtn?.addEventListener('click', handleStartExam);
            startExamBtnAlt?.addEventListener('click', handleStartExam);
            submitExamBtn?.addEventListener('click', () => handleSubmitExam(false));

            examPinInput?.addEventListener('input', () => {
                if (loadExamBtn) {
                    loadExamBtn.disabled = examPinInput.value.trim() === '' || !isSignedIn || !isOnline;
                }
            });
            studentExamIdInput?.addEventListener('input', validateStudentExamIdInput);

            // Initial button states
            if (loadExamBtn) loadExamBtn.disabled = true;
            if (startExamBtn) startExamBtn.disabled = true;
            if (startExamBtnAlt) startExamBtnAlt.classList.add('hidden');
            if (submitExamBtn) { // Keep submit button disabled initially
                 submitExamBtn.disabled = true;
                 submitExamBtn.innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)';
             }
        }

        function showAppContent() {
            loadingIndicator?.classList.add('hidden');
            mainContainer?.classList.add('content-visible');
            console.log("App content shown.");
        }

        function updateYear() {
            const el = document.getElementById('currentYear');
            if (el) {
                el.textContent = new Date().getFullYear();
            }
        }

        // === Google API & Auth ===
        function initGoogleApi() {
            console.log('Initialising Google API...');
            try {
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CLIENT_ID,
                    scope: SCOPES,
                    callback: handleTokenResponse
                });

                gapi.load('client', async () => {
                    try {
                        await gapi.client.init({
                            apiKey: API_KEY,
                            discoveryDocs: DISCOVERY_DOCS
                        });
                        console.log('GAPI client initialised.');

                        const savedToken = localStorage.getItem('gapi_token');
                        if (savedToken) {
                            const token = JSON.parse(savedToken);
                            if (token?.access_token /* && !isTokenExpired(token) */) {
                                gapi.client.setToken(token);
                                console.log("Using saved token.");
                                await tokenObtained(token);
                            } else {
                                localStorage.removeItem('gapi_token');
                                console.log("Saved token invalid or expired.");
                                updateAuthUI();
                                showAppContent();
                            }
                        } else {
                             console.log("No saved token found.");
                             updateAuthUI();
                             showAppContent();
                        }
                    } catch (error) {
                        handleApiInitError(error);
                    }
                });
            } catch (error) {
                handleApiInitError(error);
            }
        }

        function handleApiInitError(error) {
            console.error('API Initialisation Error:', error);
            showImprovedNotification('error', 'API Load Error', `Failed to load Google services: ${error.message}`);
            updateAuthUI();
            showAppContent();
        }

        function isTokenExpired(token) {
            return false;
        }

        function handleAuthClick() {
            if (tokenClient) {
                showImprovedNotification('info', 'Signing In', 'Opening Google Sign-In...');
                tokenClient.requestAccessToken({ prompt: 'select_account' });
            } else {
                console.error('Token client not initialised.');
                showImprovedNotification('error', 'Authentication Error', 'Authentication service is not ready. Please try again later.');
            }
        }

        function handleTokenResponse(resp) {
            if (resp.error) {
                console.error('Token response error:', resp);
                let msg = `Authentication failed: ${resp.error}`;
                if (resp.error === 'popup_closed_by_user') msg = 'Sign-in cancelled by user.';
                if (resp.error === 'access_denied') msg = 'Access denied. Please grant permission to proceed.';
                showImprovedNotification('error', 'Authentication Error', msg);
                updateAuthUI();
                showAppContent();
                return;
            }
            console.log('Access token received.');
            localStorage.setItem('gapi_token', JSON.stringify(resp));
            gapi.client.setToken(resp);
            tokenObtained(resp);
        }

        async function tokenObtained(token) {
            console.log("Token available, proceeding...");
            isSignedIn = true;
            await fetchUserInfo();
            updateAuthUI();
            showAppContent();

            const loadedState = JSON.parse(localStorage.getItem(appStateKey) || '{}');
            if (currentUser &&
                loadedState.currentUserEmail === currentUser.email &&
                loadedState.examEndTime &&
                Date.now() < loadedState.examEndTime) {
                console.log("Attempting to restore active exam session.");
                restoreAppState(loadedState);
            } else if (loadedState.currentUserEmail) {
                console.log("Saved state is invalid or expired for the current user.");
                localStorage.removeItem(appStateKey);
                saveAppState();
            }
        }

        async function fetchUserInfo() {
            if (!gapi.client.getToken()?.access_token) {
                console.warn("fetchUserInfo called without an access token.");
                return;
            }
            console.log('Fetching user information...');
            try {
                const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                    headers: {
                        'Authorization': `Bearer ${gapi.client.getToken().access_token}`
                    }
                });
                if (!response.ok) {
                    if (response.status === 401) {
                        console.warn("User Info fetch failed (401 - Unauthorized). Signing out.");
                        handleSignoutClick();
                        return;
                    }
                    throw new Error(`(${response.status}) ${await response.text()}`);
                }
                const userInfo = await response.json();
                currentUser = {
                    id: userInfo.sub,
                    name: userInfo.name || 'N/A',
                    email: userInfo.email || 'N/A',
                    picture: userInfo.picture || ''
                };
                console.log('User details fetched:', currentUser.email);

                if (studentNameInput) studentNameInput.value = currentUser.name;
                if (studentEmailInput) studentEmailInput.value = currentUser.email;
                if (userAvatar) userAvatar.src = currentUser.picture;
                if (userName) userName.textContent = currentUser.name;

                isAdmin = ADMIN_EMAILS.includes(currentUser.email);
                document.body.classList.toggle('is-admin', isAdmin);

                if (examPinInput) examPinInput.disabled = false;
                if (loadExamBtn) {
                    loadExamBtn.disabled = examPinInput.value.trim() === '' || !isOnline;
                }
            } catch (e) {
                console.error('Fetch user info error:', e);
                showImprovedNotification('error', 'User Info Error', `Could not get user details: ${e.message}. Please try signing in again.`);
                currentUser = null;
                updateAuthUI();
            }
        }

        function handleSignoutClick() {
            console.log("Signing out...");
            const token = gapi.client.getToken();
            if (token?.access_token) {
                try {
                    google.accounts.oauth2.revoke(token.access_token, () => console.log('Token revoked successfully.'));
                } catch (e) {
                    console.warn("Error revoking token:", e);
                }
                gapi.client.setToken('');
            }
            localStorage.removeItem('gapi_token');
            localStorage.removeItem(appStateKey);

            isSignedIn = false;
            isAdmin = false;
            currentUser = null;
            examDetails = null;
            studentPINEntered = '';
            studentExamIdEntered = '';
            stopTimer();
            totalQuestions = 0; // Reset question count

            resetExamState();
            updateAuthUI();
            showImprovedNotification('info', 'Signed Out', 'You have been signed out.');
        }


        // === UI State & Reset ===
        function resetExamState() {
            console.log("Resetting UI to initial state.");
            examStartModule?.classList.add('hidden');
            examDetailsModule?.classList.add('hidden');
            examQuestionsModule?.classList.add('hidden');
            submissionConfirmationModule?.classList.add('hidden');
            studentExamIdGroup?.classList.add('hidden');

            signinPromptModule?.classList.remove('hidden');

            if (examPinInput) {
                examPinInput.value = '';
                examPinInput.disabled = true;
            }
            if (studentExamIdInput) studentExamIdInput.value = '';
            if (studentNameInput) studentNameInput.value = '';
            if (studentEmailInput) studentEmailInput.value = '';

            if (loadExamBtn) {
                loadExamBtn.disabled = true;
                loadExamBtn.classList.remove('hidden');
                loadExamBtn.innerHTML = '<i class="fas fa-download"></i> Load Exam Details';
            }
            if (startExamBtn) startExamBtn.disabled = true;
            if (startExamBtnAlt) {
                startExamBtnAlt.classList.add('hidden');
                startExamBtnAlt.disabled = true;
            }
             if (submitExamBtn) { // Ensure submit button is reset correctly
                 submitExamBtn.disabled = true;
                 submitExamBtn.innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)';
             }

            const na = 'N/A';
            if (examCodeDisplay) examCodeDisplay.textContent = na;
            if (examDurationDisplay) examDurationDisplay.textContent = na;
            if (examStartTimeDisplay) examStartTimeDisplay.textContent = na;
            if (examNameHeader) examNameHeader.textContent = 'Please sign in to load the exam';
            if (examNameDetail) examNameDetail.textContent = '';
            if (examCourseCodeDetail) examCourseCodeDetail.textContent = '';
            if (examModeDetail) examModeDetail.textContent = '';
            if (examDurationDetail) examDurationDetail.textContent = '';
            if (examStartTimeDetail) examStartTimeDetail.textContent = '';

            if (examQuestionsArea) examQuestionsArea.innerHTML = '<p>Exam questions will appear here...</p>';
            stopTimer();
            if (timerDisplay) timerDisplay.textContent = '--:--';
            totalQuestions = 0; // Reset question count
        }

        function updateAuthUI() {
            console.log('Updating Auth UI - SignedIn:', isSignedIn, 'CurrentUser:', !!currentUser);
            document.body.classList.toggle('is-admin', isAdmin);

            if (isSignedIn && currentUser) {
                console.log('Showing logged-in UI.');
                loginContainer.style.display = 'none';
                userContainer.style.display = 'flex';
                signinPromptModule.classList.add('hidden');

                 if (examStartModule && !examDetails && examQuestionsModule.classList.contains('hidden')) {
                     examStartModule.classList.remove('hidden');
                 }

                if (examPinInput) examPinInput.disabled = false;
                if (loadExamBtn) {
                    loadExamBtn.disabled = examPinInput.value.trim() === '' || !isOnline;
                }

                if (studentNameInput) studentNameInput.value = currentUser.name || 'N/A';
                if (studentEmailInput) studentEmailInput.value = currentUser.email || 'N/A';
                if (userName) userName.textContent = currentUser.name || '';
                if (userAvatar) userAvatar.src = currentUser.picture || '';
            } else {
                console.log('Showing logged-out UI.');
                loginContainer.style.display = 'flex';
                userContainer.style.display = 'none';
                resetExamState();
                signinPromptModule.classList.remove('hidden');
            }
             checkAllConfirmed(); // Update submit button state after auth changes
        }

        // === Google Sheets Interaction === (Keep as is, or modify if switching to backend)
        async function getSheetData(spreadsheetId, range) {
            // ... (previous implementation)
             if (!isSignedIn || !gapi?.client?.sheets) {
                 showImprovedNotification('error', 'API Error', 'Not signed in or Sheets API not ready.');
                 return null;
             }
             if (!isOnline) {
                 showImprovedNotification('warning', 'Offline', 'Cannot fetch data while offline.');
                 return null;
             }
             console.log(`Workspaceing data from: ${spreadsheetId}, Range: ${range}`);
             setSyncing(true);
             try {
                 const response = await gapi.client.sheets.spreadsheets.values.get({
                     spreadsheetId,
                     range
                 });
                 console.log(`Successfully fetched data for ${range}.`);
                 return response.result.values || [];
             } catch (err) {
                 console.error(`Error fetching ${range}:`, err);
                 const errorDetails = err.result?.error;
                 showImprovedNotification('error', 'Sheet Read Error', `Could not fetch data: ${errorDetails?.message || err.message} (Code: ${errorDetails?.status})`);
                 return null;
             } finally {
                 setSyncing(false);
             }
        }
        async function appendSheetData(spreadsheetId, sheetName, values) {
            // ... (previous implementation)
             if (!isSignedIn || !gapi?.client?.sheets) {
                 showImprovedNotification('error', 'API Error', 'Not signed in or Sheets API not ready.');
                 return false;
             }
             if (!SCOPES.includes("https://www.googleapis.com/auth/spreadsheets")) {
                 console.warn("Attempted write operation with read-only scope. Data:", values);
                 showImprovedNotification('warning', 'Read-Only Mode', 'Cannot save attempt (read-only permissions). Please ensure correct authorization.');
                 return false;
             }
             if (!isOnline) {
                 showImprovedNotification('warning', 'Offline', 'Cannot save data while offline.');
                 return false;
             }
             console.log(`Appending data to Sheet: ${spreadsheetId}, Sheet: ${sheetName}`);
             setSyncing(true);
             try {
                 const response = await gapi.client.sheets.spreadsheets.values.append({
                     spreadsheetId,
                     range: sheetName,
                     valueInputOption: 'USER_ENTERED',
                     insertDataOption: 'INSERT_ROWS',
                     resource: { values }
                 });
                 console.log('Append operation successful:', response.result);
                 return true;
             } catch (err) {
                 console.error(`Error appending to ${sheetName}:`, err);
                 const errorDetails = err.result?.error;
                 showImprovedNotification('error', `Sheet Write Error`, `Could not save data: ${errorDetails?.message || err.message} (Code: ${errorDetails?.status})`);
                 return false;
             } finally {
                 setSyncing(false);
             }
        }
        async function updateSheetData(spreadsheetId, range, values) {
             // ... (previous implementation)
             if (!isSignedIn || !gapi?.client?.sheets) {
                 showImprovedNotification('error', 'API Error', 'Not signed in or Sheets API not ready for update.');
                 return false;
             }
             if (!SCOPES.includes("https://www.googleapis.com/auth/spreadsheets")) {
                 console.warn("Read-only scope. Cannot update data. Range:", range, "Data:", values);
                 showImprovedNotification('warning', 'Read-Only Mode', 'Cannot update attempt (read-only permissions).');
                 return false;
             }
             if (!isOnline) {
                 showImprovedNotification('warning', 'Offline', 'Cannot update data while offline.');
                 return false;
             }
             console.log(`Updating Sheet: ${spreadsheetId}, Range: ${range}`);
             setSyncing(true);
             try {
                 const response = await gapi.client.sheets.spreadsheets.values.update({
                     spreadsheetId: spreadsheetId,
                     range: range,
                     valueInputOption: 'USER_ENTERED',
                     resource: {
                          values: values
                     }
                 });
                 console.log('Update operation successful:', response.result);
                 return true;
             } catch (err) {
                 console.error(`Error updating ${range}:`, err);
                 const errorDetails = err.result?.error;
                 showImprovedNotification('error', `Sheet Update Error`, `Could not update data: ${errorDetails?.message || err.message} (Code: ${errorDetails?.status})`);
                 return false;
             } finally {
                 setSyncing(false);
             }
         }


        // === Exam Logic ===
        async function handleLoadExam() {
            // ... (previous implementation - check PIN, fetch details)
             studentPINEntered = examPinInput.value.trim();
             if (!studentPINEntered) {
                 showImprovedNotification('warning', 'Missing PIN', 'Please enter the Exam PIN provided.');
                 return;
             }
             loadExamBtn.disabled = true;
             loadExamBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
             await fetchExamDetails(studentPINEntered);
             loadExamBtn.disabled = false;
             loadExamBtn.innerHTML = '<i class="fas fa-download"></i> Load Exam Details';
             if (startExamBtn) startExamBtn.disabled = !examDetails || !isOnline;
             if (startExamBtnAlt) startExamBtnAlt.disabled = !examDetails || !isOnline;
        }

        async function fetchExamDetails(pin) {
             // ... (previous implementation - find row, parse details, calculate end time)
             showImprovedNotification('info', 'Fetching Exam', `Loading details for PIN: ${pin}...`);
             const range = `${EXAM_DETAILS_SHEET_NAME}!A:H`;
             const data = await getSheetData(EXAM_SPREADSHEET_ID, range);
             examDetails = null;
             examEndTime = null;
             totalQuestions = 0; // Reset question count on new load

             if (data === null) {
                 if (loadExamBtn) loadExamBtn.disabled = !isOnline;
                 return;
             }

             if (data.length > 1) {
                 const header = data[0].map(h => String(h).trim().toLowerCase());
                 const indices = { pin: header.indexOf('pin'), code: header.indexOf('code'), name: header.indexOf('name'), duration: header.indexOf('duration'), startDate: header.indexOf('startdate'), startTime: header.indexOf('starttime'), mode: header.indexOf('mode'), questions: header.indexOf('questions') };
                 const missingHeaders = Object.entries(indices).filter(([key, value]) => value === -1).map(([key]) => key);
                 if (missingHeaders.length > 0) {
                     console.error(`Missing required columns in '${EXAM_DETAILS_SHEET_NAME}' sheet: ${missingHeaders.join(', ')}. Found headers:`, header);
                     showImprovedNotification('error', 'Sheet Format Error', `The "${EXAM_DETAILS_SHEET_NAME}" sheet is missing required columns: ${missingHeaders.join(', ')}.`);
                     if (loadExamBtn) loadExamBtn.disabled = !isOnline;
                     return;
                 }

                 const examRow = data.slice(1).find(row => row[indices.pin] === pin);
                 if (examRow) {
                     const duration = parseInt(examRow[indices.duration], 10);
                     const startDateStr = String(examRow[indices.startDate] || '').trim();
                     const startTimeStr = String(examRow[indices.startTime] || '').trim();
                     const mode = String(examRow[indices.mode] || 'Quiz').trim().toLowerCase();
                     const questionsJson = String(examRow[indices.questions] || '[]').trim();

                     if (isNaN(duration) || duration <= 0) { /* Validation */ }
                     if (!/^\d{4}-\d{2}-\d{2}$/.test(startDateStr) || !/^\d{2}:\d{2}:\d{2}$/.test(startTimeStr)) { /* Validation */ }

                     let parsedQuestions = [];
                     try {
                         parsedQuestions = JSON.parse(questionsJson);
                         if (!Array.isArray(parsedQuestions)) throw new Error("Questions data is not a valid JSON array.");
                         totalQuestions = parsedQuestions.length; // Store total question count
                     } catch (e) {
                          console.error("Error parsing questions JSON:", e, "JSON string:", questionsJson);
                          showImprovedNotification('error', 'Invalid Questions Data', `Could not load questions: ${e.message}`);
                          if (loadExamBtn) loadExamBtn.disabled = !isOnline;
                          return;
                      }

                     try { /* Calculate examEndTime */ } catch (e) { /* Handle time calculation error */ }

                     examDetails = { PIN: pin, Code: examRow[indices.code], Name: examRow[indices.name], Duration: duration, StartDate: startDateStr, StartTime: startTimeStr, Mode: mode, Questions: questionsJson, OriginalOrderMap: null };
                     console.log("Exam details loaded:", examDetails, "Total Questions:", totalQuestions);
                     displayExamDetailsHeader();
                     showImprovedNotification('success', 'Exam Loaded', `"${examDetails.Name}" loaded.`);

                     if (examDetails.Mode === 'exam') { /* UI update for Exam mode */ } else { /* UI update for Quiz mode */ }
                     saveAppState();
                     checkAllConfirmed(); // Update submit button state after loading
                 } else { /* PIN not found */ }
             } else { /* No exams found */ }
        }

         async function findAttemptRecord(email, pin, studentExamId, mode, targetStatus) {
             // ... (previous implementation)
              if ((mode === 'quiz' && !email) || !pin || (mode === 'exam' && !studentExamId)) {
                  console.error("Missing identifiers for finding attempt record. Mode:", mode, "Email:", !!email, "PIN:", !!pin, "ExamID:", !!studentExamId);
                  return null;
              }
              const range = `${EXAM_ATTEMPTS_SHEET_NAME}!A:G`;
              console.log(`Searching for attempt record in ${range} with status '${targetStatus}'... Criteria: PIN=${pin}, Mode=${mode}` + (mode==='exam' ? `, ExamID=${studentExamId}` : `, Email=${email}`));
              const data = await getSheetData(EXAM_SPREADSHEET_ID, range);
              if (data === null || data.length <= 1) {
                  console.log("No attempt data found or fetch failed.");
                  return null;
              }
              for (let i = 1; i < data.length; i++) {
                  const row = data[i];
                  if (row && row.length >= 7) {
                      const sheetEmail = String(row[2] || '').trim().toLowerCase();
                      const sheetPin = String(row[3] || '').trim().toLowerCase();
                      const sheetStudentExamId = String(row[5] || '').trim();
                      const sheetStatus = String(row[6] || '').trim().toLowerCase();
                      let match = false;
                      if (mode === 'quiz' && sheetEmail === email.toLowerCase() && sheetPin === pin.toLowerCase()) { match = true; }
                      else if (mode === 'exam' && sheetStudentExamId === studentExamId && sheetPin === pin.toLowerCase()) { match = true; }
                      if (match && sheetStatus === targetStatus.toLowerCase()) {
                          const rowNumber = i + 1;
                          console.log(`Found matching record with status '${targetStatus}' at row ${rowNumber} (data index ${i}).`);
                          return { rowNumber: rowNumber, rowData: row };
                      }
                  }
              }
              console.log(`No record found matching criteria with status '${targetStatus}'.`);
              return null;
         }

        function validateStudentExamIdInput() {
             // ... (previous implementation)
             const startButtonToUse = startExamBtnAlt;
             if (!startButtonToUse || !studentExamIdInput || !examDetails || examDetails.Mode !== 'exam') return;
             const idValue = studentExamIdInput.value.trim();
             const isValid = idValue.length === 5;
             startButtonToUse.disabled = !isValid || !isOnline;
             studentExamIdInput.style.borderColor = (isValid || idValue === '') ? '#ccc' : 'red';
        }
        function displayExamDetailsHeader() {
            // ... (previous implementation)
             if (!examDetails) return;
             if (examCodeDisplay) examCodeDisplay.textContent = examDetails.Code || 'N/A';
             if (examDurationDisplay) examDurationDisplay.textContent = `${examDetails.Duration} minutes`;
             const startTimeString = `${examDetails.StartDate || ''} ${examDetails.StartTime || ''}`.trim();
             if (examStartTimeDisplay) examStartTimeDisplay.textContent = startTimeString || 'N/A';
             if (examNameHeader) examNameHeader.textContent = examDetails.Name || 'Exam Loaded';
        }
        function displayExamDetailsFull() {
            // ... (previous implementation)
             if (!examDetails) return;
             if (examNameDetail) examNameDetail.textContent = examDetails.Name || 'N/A';
             if (examCourseCodeDetail) examCourseCodeDetail.textContent = examDetails.Code || 'N/A';
             const displayMode = examDetails.Mode ? (examDetails.Mode.charAt(0).toUpperCase() + examDetails.Mode.slice(1)) : 'N/A';
             if (examModeDetail) examModeDetail.textContent = displayMode;
             if (examDurationDetail) examDurationDetail.textContent = `${examDetails.Duration} minutes`;
             const startTimeString = `${examDetails.StartDate || ''} ${examDetails.StartTime || ''}`.trim();
             if (examStartTimeDetail) examStartTimeDetail.textContent = startTimeString || 'N/A';
        }
         async function checkIfAttemptExists(email, pin, studentExamId, mode) {
             // ... (previous implementation using findAttemptRecord)
              console.log("Checking for existing 'submit' record...");
              const existingSubmitRecordInfo = await findAttemptRecord( email, pin, studentExamId, mode, 'submit' );
              if (existingSubmitRecordInfo) { console.log("Found an existing 'submit' record."); return true; }
              else { console.log("No existing 'submit' record found."); return false; }
         }
        async function handleStartExam() {
            // ... (previous implementation - checks, start recording, UI changes)
             if (!examDetails || !currentUser) { /* Error handling */ return; }
             const currentMode = examDetails.Mode.toLowerCase();
             let currentStudentExamId = '';
             if (currentMode === 'exam') { /* Validate and store ID */ } else { studentExamIdEntered = ''; }
             console.log("Performing pre-start checks...");
             const alreadySubmitted = await checkIfAttemptExists( currentUser.email, examDetails.PIN, studentExamIdEntered, currentMode );
             if (alreadySubmitted) { /* Handle already submitted */ return; }
             try { /* Check timing */ } catch (e) { /* Handle timing error */ }
             if (!examEndTime || isNaN(examEndTime) || Date.now() >= examEndTime) { /* Handle invalid/passed end time */ return; }

             console.log("Checking for existing 'start' record...");
             const existingStartRecordInfo = await findAttemptRecord( currentUser.email, examDetails.PIN, studentExamIdEntered, currentMode, 'start' );
             if (!existingStartRecordInfo) {
                 console.log("No existing 'start' record found. Recording exam start...");
                 const startRecorded = await recordExamAttempt('start');
                 if (!startRecorded) { /* Handle start record failure */ return; }
             } else {
                 console.log(`Existing 'start' record found at row ${existingStartRecordInfo.rowNumber}. Resuming session...`);
             }

             console.log(`Starting ${currentMode} mode...`);
             examStartModule.classList.add('hidden');
             examDetailsModule.classList.add('hidden');
             examQuestionsModule.classList.remove('hidden');
             submissionConfirmationModule.classList.add('hidden');
             submitExamBtn.disabled = true; // Start disabled, checkAllConfirmed will enable if needed

             displayQuestions(examDetails.Questions);
             startTimer();
             saveAppState();
             checkAllConfirmed(); // Check confirmation status after displaying questions
        }

        // Parses JSON and displays questions (with randomization and confirm/edit buttons)
        function displayQuestions(questionsJsonString) {
            console.log("Parsing and displaying exam questions...");
            examQuestionsArea.innerHTML = '';
            totalQuestions = 0; // Reset count for display
            try {
                let questionsArray = [];
                try {
                    questionsArray = JSON.parse(questionsJsonString);
                    if (!Array.isArray(questionsArray)) throw new Error("Parsed questions data is not an array.");
                } catch (parseError) {
                     console.warn("Could not parse questions JSON. Displaying as single block.", parseError);
                     questionsArray = [{ type: "long_answer", prompt: "Exam Instructions / Questions", content: questionsJsonString }];
                }

                totalQuestions = questionsArray.length; // Update total count
                console.log(`Total questions to display: ${totalQuestions}`);

                 // Randomize Order
                 const originalIndices = questionsArray.map((_, index) => index);
                 for (let i = originalIndices.length - 1; i > 0; i--) {
                     const j = Math.floor(Math.random() * (i + 1));
                     [originalIndices[i], originalIndices[j]] = [originalIndices[j], originalIndices[i]];
                 }
                 console.log("Shuffled display order (indices):", originalIndices);

                 // Store Original Order Map for submission
                 examDetails.OriginalOrderMap = {};
                 questionsArray.forEach((q, index) => { examDetails.OriginalOrderMap[index] = q; });

                // Display questions in shuffled order
                originalIndices.forEach((originalIndex, displayIndex) => {
                    const q = questionsArray[originalIndex];
                    const displayQNum = displayIndex + 1;
                    const originalQNum = originalIndex + 1;
                    const questionId = `q-${originalQNum}`;
                    const answerId = `ans-${originalQNum}`;
                    const answerName = `ans-${originalQNum}`;

                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'question form-group';
                    questionDiv.id = questionId;
                    questionDiv.dataset.originalIndex = originalIndex;

                    let inputHtml = '';
                    const promptText = q.prompt || `Question ${displayQNum}`;
                    let questionContentHtml = '<div class="question-content">';

                    switch (q.type) {
                        // ... (cases for short_answer, long_answer, attachment, multiple_select)
                         case 'short_answer':
                             questionContentHtml += `<input type="text" id="${answerId}" name="${answerName}" class="form-control" placeholder="Enter your answer">`;
                             break;
                         case 'long_answer':
                             questionContentHtml += `<textarea id="${answerId}" name="${answerName}" class="form-control" rows="5" placeholder="Enter your detailed answer">${q.content || ''}</textarea>`;
                             break;
                        case 'code':
                            const langHint = q.language ? `(${q.language})` : '';
                            questionContentHtml += `<textarea id="${answerId}" name="${answerName}" class="form-control" rows="8" placeholder="Enter your code here ${langHint}" style="font-family: monospace; white-space: pre; overflow-wrap: normal; overflow-x: scroll;"></textarea>`;
                             // Updated note
                             questionContentHtml += `<small class="length-limit-note">Note: Very long code submissions might have length limitations.</small>`;
                            break;
                         case 'attachment':
                              const allowedTypes = q.allowed_types || []; const acceptAttr = allowedTypes.join(',');
                              const maxSizeMB = q.max_size_mb; const maxBytes = maxSizeMB ? maxSizeMB * 1024 * 1024 : null;
                              questionContentHtml += `<input type="file" id="${answerId}" name="${answerName}" class="form-control" accept="${acceptAttr}" ${maxBytes ? `data-max-size="${maxBytes}"` : ''} data-allowed-types='${JSON.stringify(allowedTypes)}'> <small class="file-helper-text">Allowed: ${acceptAttr || 'any'}${maxSizeMB ? `, Max: ${maxSizeMB}MB` : ''}</small>`;
                              setTimeout(() => addAttachmentValidation(answerId), 0);
                              break;
                         case 'multiple_select':
                              questionContentHtml += `<div class="checkbox-group" id="${answerId}">`;
                              if (Array.isArray(q.options)) {
                                  q.options.forEach((option, optIndex) => {
                                      const optionId = `${answerId}-opt${optIndex}`;
                                      questionContentHtml += `<div class="checkbox-item"><input type="checkbox" id="${optionId}" name="${answerName}" value="${option}" class="form-control-checkbox"><label for="${optionId}">${option}</label></div>`;
                                  });
                              } else { questionContentHtml += `<p style="color:red;">Error: Options missing.</p>`; }
                              questionContentHtml += `</div>`;
                              break;
                        default:
                             questionContentHtml += `<p style="color:red;">Unsupported type: ${q.type}</p><p>${q.content || ''}</p>`;
                    }
                    questionContentHtml += '</div>'; // End question-content

                    const actionsHtml = `<div class="question-actions">
                                          <button type="button" class="btn-confirm btn-orange btn-sm" onclick="confirmAnswer('${questionId}')"><i class="fas fa-check"></i> Confirm</button>
                                          <button type="button" class="btn-edit btn-grey btn-sm" onclick="editAnswer('${questionId}')"><i class="fas fa-pencil-alt"></i> Edit</button>
                                       </div>`;

                    questionDiv.innerHTML = `<label>${promptText}</label>${questionContentHtml}${actionsHtml}`;
                    examQuestionsArea.appendChild(questionDiv);
                });

            } catch (e) {
                console.error("Error processing or displaying questions:", e);
                examQuestionsArea.innerHTML = `<p style="color:red;">Error loading questions: ${e.message}.</p>`;
                showImprovedNotification('error', 'Question Display Error', `Could not display questions: ${e.message}`);
                if (submitExamBtn) submitExamBtn.disabled = true;
                totalQuestions = 0; // Ensure count is 0 on error
            }
             checkAllConfirmed(); // Check confirmation status after display attempt
        }

        // Confirm an answer, disable inputs, check if all are confirmed
        function confirmAnswer(questionId) {
            const questionDiv = document.getElementById(questionId);
            if (!questionDiv || questionDiv.classList.contains('confirmed')) return; // Ignore if not found or already confirmed

            questionDiv.classList.add('confirmed');

            const inputs = questionDiv.querySelectorAll('.form-control, .form-control-checkbox');
            inputs.forEach(input => { input.disabled = true; });

            console.log(`Confirmed answer for question: ${questionId}`);
            checkAllConfirmed(); // Update overall submit button status
        }

        // Enable editing for an answer, re-enable inputs, check confirmation status
        function editAnswer(questionId) {
            const questionDiv = document.getElementById(questionId);
            if (!questionDiv || !questionDiv.classList.contains('confirmed')) return; // Ignore if not found or not confirmed

            questionDiv.classList.remove('confirmed');

            const inputs = questionDiv.querySelectorAll('.form-control, .form-control-checkbox');
            inputs.forEach(input => { input.disabled = false; });

            console.log(`Enabled editing for question: ${questionId}`);
            checkAllConfirmed(); // Update overall submit button status
        }

        // Check if all displayed questions are confirmed and update submit button
        function checkAllConfirmed() {
            if (!examQuestionsArea || totalQuestions <= 0) {
                 if(submitExamBtn) submitExamBtn.disabled = true; // Ensure disabled if no questions or area missing
                 return;
            }
            const confirmedQuestions = examQuestionsArea.querySelectorAll('.question.confirmed').length;
            const allConfirmed = confirmedQuestions === totalQuestions;

            console.log(`Confirmed ${confirmedQuestions}/${totalQuestions} questions. All confirmed: ${allConfirmed}`);

            if (submitExamBtn) {
                submitExamBtn.disabled = !allConfirmed || !isOnline; // Enable only if all confirmed AND online
                 if (allConfirmed && isOnline) {
                    submitExamBtn.innerHTML = '<i class="fas fa-check-circle"></i> Submit Exam Now';
                    submitExamBtn.classList.remove('btn-locked'); // Optional: change style
                 } else {
                    submitExamBtn.innerHTML = `<i class="fas ${allConfirmed ? 'fa-wifi' : 'fa-lock'}"></i> Submit Exam (${allConfirmed ? 'Offline' : confirmedQuestions + '/' + totalQuestions + ' Confirmed'})`;
                    submitExamBtn.classList.add('btn-locked'); // Optional: change style
                 }
            }
        }


        function addAttachmentValidation(inputId) {
            // ... (previous implementation)
            const fileInput = document.getElementById(inputId);
            if (!fileInput || fileInput.type !== 'file') return;
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0]; if (!file) return;
                const max = parseInt(fileInput.getAttribute('data-max-size'), 10);
                const types = JSON.parse(fileInput.getAttribute('data-allowed-types') || '[]');
                if (max && file.size > max) { showImprovedNotification('error', 'File Too Large', `"${file.name}" exceeds ${(max / (1024 * 1024)).toFixed(1)}MB`); fileInput.value = ''; return; }
                if (types.length > 0 && !types.includes(file.type) && !types.includes('.' + file.name.split('.').pop())) { showImprovedNotification('error', 'Invalid Type', `"${file.name}" type (${file.type || 'unknown'}) not allowed.`); fileInput.value = ''; return; }
                showImprovedNotification('success', 'File Selected', `"${file.name}" (${(file.size / 1024).toFixed(1)}KB)`);
            });
        }

        function startTimer() {
            // ... (previous implementation)
             if (examTimerInterval) { return; }
             if (!examEndTime || isNaN(examEndTime) || examEndTime <= Date.now()) {
                 console.error("Invalid or past examEndTime:", examEndTime); timerDisplay.textContent = "Error";
                 if (examEndTime && examEndTime <= Date.now()) { handleSubmitExam(true); }
                 return;
             }
             console.log(`Timer started. Counting down to: ${new Date(examEndTime).toLocaleString()}`);
             updateTimerDisplay();
             examTimerInterval = setInterval(updateTimerDisplay, 1000);
        }
        function updateTimerDisplay() {
            // ... (previous implementation)
            if (!examEndTime) { stopTimer(); timerDisplay.textContent = "--:--"; return; }
            const now = Date.now(); const timeLeft = Math.max(0, examEndTime - now);
            const minutes = Math.floor(timeLeft / (1000 * 60)); const seconds = Math.floor((timeLeft / 1000) % 60);
            timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            if (timeLeft <= 0) { console.log("Time's up!"); stopTimer(); showImprovedNotification('warning', 'Time Up!', 'Submitting automatically.', 0); handleSubmitExam(true); }
        }
        function stopTimer() {
            // ... (previous implementation)
            if (examTimerInterval) { clearInterval(examTimerInterval); examTimerInterval = null; console.log("Timer stopped."); }
        }
        function getFingerprintData() {
            // ... (previous implementation)
             const data = { ua: navigator.userAgent||'N/A', lang: navigator.language||'N/A', platform: navigator.platform||'N/A', vendor: navigator.vendor||'N/A', cores: navigator.hardwareConcurrency||undefined, memory: navigator.deviceMemory||undefined, screenRes: `${screen.width||0}x${screen.height||0}x${screen.colorDepth||0}`, availScreenRes: `${screen.availWidth||0}x${screen.availHeight||0}`, windowInnerSize: `${window.innerWidth||0}x${window.innerHeight||0}`, timezoneOffset: new Date().getTimezoneOffset(), timestamp: Date.now() };
             console.log("Generated Fingerprint Data:", data); return JSON.stringify(data);
        }
        function downloadJsonBackup(data, filename) {
            // ... (previous implementation)
             try {
                 const jsonString = JSON.stringify(data, null, 2); const blob = new Blob([jsonString], { type: "application/json" });
                 const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = filename;
                 document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                 console.log("JSON backup download initiated:", filename); showImprovedNotification('info', 'Backup Saved', 'A JSON backup file has been downloaded.');
             } catch (e) { console.error("Error creating JSON backup:", e); showImprovedNotification('error', 'Backup Error', 'Could not create backup file.'); }
        }

        // Handles final exam submission (manual or auto)
        async function handleSubmitExam(isAutoSubmit = false) {
            const timeIsUp = examEndTime && Date.now() >= examEndTime;
             if (timeIsUp && !isAutoSubmit) {
                 console.warn("Manual submit clicked after deadline. Treating as auto-submit.");
                 showImprovedNotification('warning', 'Deadline Passed', 'Time expired. Submitting automatically.');
                 isAutoSubmit = true;
             }

            stopTimer();
            submitExamBtn.disabled = true;
            submitExamBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';

             // --- Mandatory Confirmation Check for MANUAL submit ---
             if (!isAutoSubmit) {
                 const confirmedCount = examQuestionsArea.querySelectorAll('.question.confirmed').length;
                 if (confirmedCount !== totalQuestions) {
                     showImprovedNotification('error', 'Not All Confirmed', `Please confirm all ${totalQuestions} questions before submitting. You have confirmed ${confirmedCount}.`, 5000);
                     submitExamBtn.disabled = !isOnline; // Re-enable if online
                     checkAllConfirmed(); // Update button text/state
                     // Restart timer only if time hasn't actually run out
                     if (examEndTime && Date.now() < examEndTime) { startTimer(); }
                     return; // Stop submission
                 }
                 // If all confirmed manually, ask for final confirmation
                 if (!confirm("You have confirmed all answers. Are you absolutely sure you want to submit your exam?")) {
                     submitExamBtn.disabled = !isOnline;
                     checkAllConfirmed(); // Update button text/state
                     if (examEndTime && Date.now() < examEndTime) { startTimer(); }
                     return; // Abort submission
                 }
             }
             // --- End Manual Confirmation Check ---

            console.log("Processing submission..." + (isAutoSubmit ? " (Auto)" : " (Manual)"));
            const answers = {};
            const fingerprint = getFingerprintData();

             // Collect Answers - respecting ORIGINAL order AND confirmation status
             if (!examDetails || !examDetails.OriginalOrderMap) { /* Error handling */ return; }

             const originalIndices = Object.keys(examDetails.OriginalOrderMap).map(Number).sort((a, b) => a - b);

             originalIndices.forEach(originalIndex => {
                 const originalQNum = originalIndex + 1;
                 const questionData = examDetails.OriginalOrderMap[originalIndex];
                 const answerName = `ans-${originalQNum}`;
                 const questionDivId = `q-${originalQNum}`;
                 const questionDiv = document.getElementById(questionDivId);
                 const isConfirmed = questionDiv && questionDiv.classList.contains('confirmed');

                 // For AUTO submit, only collect confirmed answers. For MANUAL, collect all (already checked if all are confirmed).
                 if (isAutoSubmit && !isConfirmed) {
                     answers[answerName] = "[NOT CONFIRMED]"; // Mark unconfirmed answers on auto-submit
                     console.log(`Skipping unconfirmed answer for ${answerName} on auto-submit.`);
                 } else {
                     // Collect answer normally (or mark if element not found)
                     const formElementsWithName = examForm.elements[answerName];
                     if (formElementsWithName) {
                         switch (questionData.type) {
                             case 'attachment':
                                 // ... (file handling placeholder)
                                 const fileInput = formElementsWithName;
                                 if (fileInput.files && fileInput.files.length > 0) { answers[answerName] = `FILE_UPLOADED:${fileInput.files[0].name}`; }
                                 else { answers[answerName] = ''; }
                                 break;
                             case 'multiple_select':
                                 // ... (checkbox handling)
                                 const checkboxes = Array.isArray(formElementsWithName) ? formElementsWithName : [formElementsWithName];
                                 const selectedValues = []; checkboxes.forEach(cb => { if (cb.checked) { selectedValues.push(cb.value); } });
                                 answers[answerName] = selectedValues;
                                 break;
                             default: // short_answer, long_answer, code
                                 answers[answerName] = formElementsWithName.value;
                                 break;
                         }
                     } else {
                         console.warn(`Could not find form element for answer: ${answerName}`);
                         answers[answerName] = 'ERROR_ELEMENT_NOT_FOUND';
                     }
                 }
             });

            const answersJson = JSON.stringify(answers);
            console.log("Collected Answers for Submission:", answersJson);

            // --- Create Backup Data --- (Include submittedLate flag)
             const backupData = {
                 submissionTimestamp: new Date().toISOString(),
                 examDetails: { PIN: examDetails?.PIN, Name: examDetails?.Name, Mode: examDetails?.Mode, Code: examDetails?.Code },
                 studentInfo: { pinEntered: studentPINEntered, studentExamId: examDetails?.Mode === 'exam' ? studentExamIdEntered : undefined, name: currentUser?.name, email: currentUser?.email },
                 answers: answers,
                 fingerprint: JSON.parse(fingerprint),
                 submittedLate: timeIsUp, // Flag if time was up when submission started
                 submittedAnswers: answersJson // Include the exact JSON string being sent
             };
             const backupFilename = `exam_backup_${examDetails?.PIN || 'unknown'}_${(currentUser?.email || studentExamIdEntered || 'anon').replace(/@.*/, '')}_${Date.now()}.json`;
             downloadJsonBackup(backupData, backupFilename);

            // --- Update or Append Logic --- (No change needed here, logic remains the same)
            let submissionSuccess = false;
            if (!currentUser || !examDetails) { /* Error handling */ return; }
            const currentMode = examDetails.Mode.toLowerCase();
            console.log("Looking for existing 'start' record to update...");
            const startRecordInfo = await findAttemptRecord( currentUser.email, examDetails.PIN, studentExamIdEntered, currentMode, 'start' );
            if (startRecordInfo) {
                 const rowToUpdate = startRecordInfo.rowNumber; console.log(`Found 'start' record at row ${rowToUpdate}. Updating...`);
                 const updateRange = `${EXAM_ATTEMPTS_SHEET_NAME}!G${rowToUpdate}:I${rowToUpdate}`;
                 const updateValues = [[ 'submit', answersJson, fingerprint ]];
                 submissionSuccess = await updateSheetData(EXAM_SPREADSHEET_ID, updateRange, updateValues);
                 if (!submissionSuccess) { showImprovedNotification('error', 'Submission Failed', 'Failed to update attempt record online (backup downloaded).', 0); }
            } else {
                 console.warn("No 'start' record found. Appending 'submit' record as fallback.");
                 showImprovedNotification('warning','Submission Warning','Could not find start record. Creating new submission entry.');
                 submissionSuccess = await recordExamAttempt('submit', answers, fingerprint); // Pass answers OBJECT
                 if (!submissionSuccess) { showImprovedNotification('error', 'Submission Failed', 'Failed to save new attempt record online (backup downloaded).', 0); }
            }

            // --- Final UI Update ---
            if (submissionSuccess) {
                showImprovedNotification('success', 'Exam Submitted Successfully!', 'Your submission has been recorded.', 0);
                examQuestionsModule.classList.add('hidden');
                submissionConfirmationModule.classList.remove('hidden');
                localStorage.removeItem(appStateKey);
                examDetails = null; studentPINEntered = ''; studentExamIdEntered = ''; examEndTime = null; totalQuestions = 0;
            } else {
                 console.error("Online submission failed after backup.");
                 if (!isAutoSubmit) {
                     submitExamBtn.disabled = !isOnline; checkAllConfirmed(); // Allow retry if manual
                 } else {
                     showImprovedNotification('error', 'Auto-Submit Failed', 'Could not save submission online. Backup downloaded.', 0);
                 }
            }
        }

        async function recordExamAttempt(status, answersObject = null, fingerprintString = null) {
            // ... (previous implementation - append row to sheet)
             if (!currentUser || !examDetails || !studentPINEntered) { console.error("Missing data for recording attempt."); return false; }
             const timestamp = new Date().toISOString(); const isQuizMode = examDetails.Mode.toLowerCase() === 'quiz';
             const finalFingerprintJson = fingerprintString ? fingerprintString : (status === 'start' ? getFingerprintData() : '{}');
             const finalAnswersJson = answersObject ? JSON.stringify(answersObject) : ''; // Stringify the passed object
             const dataRow = [ timestamp, isQuizMode ? String(currentUser.name) : '', isQuizMode ? String(currentUser.email) : '', String(studentPINEntered), String(examDetails.Code), isQuizMode ? '' : String(studentExamIdEntered), String(status), finalAnswersJson, finalFingerprintJson ];
             console.log("Appending exam attempt:", dataRow);
             const success = await appendSheetData(EXAM_SPREADSHEET_ID, EXAM_ATTEMPTS_SHEET_NAME, [dataRow]);
             console.log(`Append sheet result for status '${status}':`, success); return success;
        }


        // === UI Updates (Sync/Online Status, Notifications) ===
        function updateOnlineStatus() {
            // ... (previous implementation - update icons/text)
             isOnline = navigator.onLine; console.log('Connection Status:', isOnline ? 'Online' : 'Offline');
             const statusIcon = syncStatus?.querySelector('i');
             if (isOnline) { syncStatus.className = 'sync-status online'; if (statusIcon) statusIcon.style.color = 'var(--success-color)'; if (syncText) syncText.textContent = 'Online'; }
             else { syncStatus.className = 'sync-status offline'; if (statusIcon) statusIcon.style.color = 'var(--warning-color)'; if (syncText) syncText.textContent = 'Offline'; if (!isInitializing) showImprovedNotification('warning', 'Offline', 'Functionality disabled.', 5000); }
             if (statusIcon && !isSyncing) { statusIcon.className = 'fas fa-circle'; }

             // Update button states considering online status
             if (loadExamBtn) { loadExamBtn.disabled = !isOnline || !isSignedIn || (examPinInput && examPinInput.value.trim() === ''); }
             let startDisabled = !isOnline || !isSignedIn || !examDetails;
             const isExamModeActive = examDetails && examDetails.Mode === 'exam';
             if (isExamModeActive) { startDisabled = startDisabled || (studentExamIdInput && studentExamIdInput.value.trim().length !== 5); if (startExamBtnAlt) startExamBtnAlt.disabled = startDisabled; if (startExamBtn) startExamBtn.disabled = true; }
             else { if (startExamBtn) startExamBtn.disabled = startDisabled; if (startExamBtnAlt && examDetails) startExamBtnAlt.classList.add('hidden'); }
             // Submit button state is handled primarily by checkAllConfirmed now, but ensure it's disabled if offline
             if (submitExamBtn && !isOnline) {
                  submitExamBtn.disabled = true;
                  submitExamBtn.innerHTML = '<i class="fas fa-wifi"></i> Submit Exam (Offline)';
              } else {
                 checkAllConfirmed(); // Re-evaluate based on confirmation status if online
              }


             if (isInitializing && (typeof gapi !== 'undefined')) { isInitializing = false; console.log("Initialisation complete."); }
        }
        function setSyncing(syncing) {
            // ... (previous implementation - update sync icon/text)
             isSyncing = syncing; console.log("Network Syncing:", isSyncing);
             const statusIcon = syncStatus?.querySelector('i');
             if (statusIcon) {
                 if (syncing) { statusIcon.className = 'fas fa-spinner fa-spin'; statusIcon.style.color = 'var(--info-color)'; if (syncText) syncText.textContent = 'Syncing...'; }
                 else { updateOnlineStatus(); }
             }
        }
        function showImprovedNotification(type, title, message, duration = 5000) {
            // ... (previous implementation - create and show notification)
             const container = notificationArea; if (!container) { console.error("Notification area not found"); return; }
             const notification = document.createElement('div'); notification.className = `in-page-notification in-page-notification-${type}`;
             let iconClass;
             switch (type) { case 'success': iconClass = 'fa-check-circle'; break; case 'error': iconClass = 'fa-times-circle'; break; case 'warning': iconClass = 'fa-exclamation-triangle'; break; default: iconClass = 'fa-info-circle'; }
             notification.innerHTML = `<i class="fas ${iconClass} fa-icon"></i><div class="notification-content"><strong>${title}</strong><br>${message.replace(/\n/g, '<br>')}</div><button type="button" class="notification-close" aria-label="Close">&times;</button>`;
             container.appendChild(notification);
             const closeBtn = notification.querySelector('.notification-close');
             const removeNotification = () => { notification.classList.add('removing'); setTimeout(() => { if (notification.parentNode) { notification.parentNode.removeChild(notification); } }, 300); };
             closeBtn?.addEventListener('click', (e) => { e.stopPropagation(); removeNotification(); });
             if (duration > 0) { setTimeout(removeNotification, duration); }
        }

        // === State Persistence ===
        function saveAppState() {
             // ... (previous implementation - save state to localStorage if exam active)
              if (!examDetails || (examQuestionsModule && examQuestionsModule.classList.contains('hidden') && !submissionConfirmationModule.classList.contains('hidden'))) {
                  if (examQuestionsModule && examQuestionsModule.classList.contains('hidden') && submissionConfirmationModule.classList.contains('hidden')) {}
                  else { console.log("Not saving state: Exam not active or submitted."); return; }
              }
              try {
                  const state = { isSignedIn: isSignedIn, currentUserEmail: currentUser?.email, examDetails: examDetails, studentPINEntered: studentPINEntered, studentExamIdEntered: studentExamIdEntered, examEndTime: examEndTime };
                  localStorage.setItem(appStateKey, JSON.stringify(state)); console.log("Application state saved.");
              } catch (e) { console.error("Error saving app state:", e); }
        }
        function loadAppState() {
             // ... (previous implementation - load state from localStorage)
              const savedStateString = localStorage.getItem(appStateKey); if (!savedStateString) { console.log("No saved state found."); return; }
              try { const state = JSON.parse(savedStateString); console.log("Found saved state:", state); }
              catch (e) { console.error("Error parsing saved state:", e); localStorage.removeItem(appStateKey); }
        }
        function restoreAppState(state) {
             // ... (previous implementation - restore UI and state if valid)
              console.log("Restoring application state...");
              examDetails = state.examDetails; studentPINEntered = state.studentPINEntered; studentExamIdEntered = state.studentExamIdEntered; examEndTime = state.examEndTime; totalQuestions = examDetails?.OriginalOrderMap ? Object.keys(examDetails.OriginalOrderMap).length : 0; // Restore question count
              if (!examEndTime || isNaN(examEndTime) || Date.now() >= examEndTime) { console.warn("Restored state expired. Clearing."); localStorage.removeItem(appStateKey); resetExamState(); showImprovedNotification('warning', 'Session Expired', 'Previous session expired.', 0); return; }
              showImprovedNotification('info', 'Exam Session Restored', 'Resuming previous session.', 5000);
              signinPromptModule.classList.add('hidden'); examStartModule.classList.add('hidden'); examDetailsModule.classList.add('hidden'); submissionConfirmationModule.classList.add('hidden');
              examQuestionsModule.classList.remove('hidden');
              displayExamDetailsHeader();
              if (examDetails && examDetails.Questions && examDetails.OriginalOrderMap) {
                  displayQuestions(examDetails.Questions);
                  // TODO: Restore answers if implemented
              } else { console.error("Cannot restore questions display."); showImprovedNotification('error', 'Restore Failed', 'Could not restore questions.', 0); localStorage.removeItem(appStateKey); resetExamState(); return; }
              startTimer();
              if (submitExamBtn) submitExamBtn.disabled = true; // Start disabled
              checkAllConfirmed(); // Check confirmation status immediately after restore
              console.log("Application state restored successfully.");
         }

    </script>
</body>
</html>