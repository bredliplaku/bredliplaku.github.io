<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Admin Portal - Exam Management</title>
    <link rel="icon" type="image/png" href="https://bredliplaku.github.io/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        /* --- CSS (Includes styles from previous version + new styles for builder) --- */
        :root {
            --primary-color: #3949ab; --primary-dark: #1a237e;
            --secondary-color: #ffa726; --background-color: #f4f7fc;
            --card-background: #ffffff; --text-color: #333333; --text-light: #ffffff;
            --success-color: #43a047; --warning-color: #fb8c00;
            --info-color: #2196F3; --danger-color: #f44336; --border-color: #e0e0e0;
        }
        *, *::before, *::after { box-sizing: border-box; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, opacity 0.3s ease, transform 0.3s ease; }
        body, html { margin: 0; padding: 0; font-family: 'Roboto', sans-serif; background: var(--background-color); color: var(--text-color); line-height: 1.6; }
        .container { max-width: 1300px; margin: 20px auto; padding: 20px; }
        .content-hidden { visibility: hidden; opacity: 0; }
        .content-visible { visibility: visible; opacity: 1; transition: opacity 0.5s ease-in; }
        .app-header { background: linear-gradient(135deg, var(--primary-color), var(--primary-dark)); color: var(--text-light); padding: 25px 30px; border-radius: 15px; margin-bottom: 30px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); display: flex; justify-content: space-between; align-items: center; }
        h1 { margin: 0; font-size: 1.8em; display: flex; align-items: center; font-weight: 500; }
        h1 i { margin-right: 12px; font-size: 1.2em; opacity: 0.9; }
        h2 { margin: 0 0 15px 0; font-weight: 500; font-size: 1.4em; color: var(--primary-dark); border-bottom: 2px solid var(--border-color); padding-bottom: 10px; display: flex; align-items: center; }
        h2 i { margin-right: 10px; color: var(--primary-color); }
        .module { background-color: var(--card-background); border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); margin-bottom: 30px; overflow: hidden; transition: transform 0.2s ease, box-shadow 0.2s ease; }
        .module-content { padding: 25px; }
        .prompt-message { text-align: center; padding: 40px 20px; margin-top: 15px; border-radius: 12px; background-color: var(--card-background); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); color: #555; }
        .prompt-message h3 { margin-top: 0; margin-bottom: 10px; color: var(--primary-dark); }
        .prompt-message i { font-size: 2.5em; color: var(--primary-color); margin-bottom: 15px; display: block; }
        .prompt-message.access-denied i { color: var(--danger-color); }
        button { display: inline-flex; align-items: center; justify-content: center; gap: 8px; background-color: var(--primary-color); color: var(--text-light); padding: 10px 22px; border-radius: 25px; font-size: 0.9em; font-weight: 500; transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border: 0; cursor: pointer; margin: 5px 2px; -webkit-user-select: none; -khtml-user-select: none; }
        button:hover:not(:disabled) { background-color: var(--primary-dark); transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        button:disabled { background-color: #ccc; color: #666; opacity: 0.7; cursor: not-allowed; transform: none; box-shadow: none; }
        button.btn-secondary { background-color: #6c757d; color: white; }
        button.btn-secondary:hover:not(:disabled) { background-color: #5a6268; }
        button.btn-success { background-color: var(--success-color); color: white; }
        button.btn-success:hover:not(:disabled) { background-color: #367c39; }
        button.btn-danger { background-color: var(--danger-color); color: white; }
        button.btn-danger:hover:not(:disabled) { background-color: #d32f2f; }
        button.btn-info { background-color: var(--info-color); color: white; }
        button.btn-info:hover:not(:disabled) { background-color: #1976D2; }
        button.btn-sm { padding: 6px 12px; font-size: 0.85em; border-radius: 20px; }
        button i { margin-right: 2px; }
        .in-page-notifications { position: fixed; bottom: 20px; right: 20px; z-index: 10000; width: 350px; max-width: 90%; pointer-events: none; }
        .in-page-notification { background-color: white; border-radius: 8px; padding: 15px; margin-bottom: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.15); animation: slide-in 0.3s ease-out forwards; overflow: hidden; display: flex; align-items: center; opacity: 1; transition: transform 0.3s ease-in, opacity 0.3s ease-in; pointer-events: auto; border-left: 5px solid; }
        .in-page-notification.removing { opacity: 0; transform: translateX(100%); }
        @keyframes slide-in { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .in-page-notification i.fa-icon { margin-right: 15px; font-size: 1.4em; flex-shrink: 0; }
        .notification-content { flex-grow: 1; }
        .notification-close { background: none; border: none; font-size: 20px; line-height: 1; color: inherit; opacity: 0.7; padding: 0 5px; margin-left: 10px; cursor: pointer; }
        .notification-close:hover { opacity: 1; }
        .in-page-notification-info { border-left-color: var(--info-color); color: #0c5460; background-color: #d1ecf1;}
        .in-page-notification-warning { border-left-color: var(--warning-color); color: #856404; background-color: #fff3cd;}
        .in-page-notification-error { border-left-color: var(--danger-color); color: #721c24; background-color: #f8d7da;}
        .in-page-notification-success { border-left-color: var(--success-color); color: #155724; background-color: #d4edda;}
        .footer { margin-top: 40px; text-align: center; padding: 20px 0; color: #666; border-top: 1px solid var(--border-color); font-size: 0.9em; }
        .sync-auth-container { display: flex; justify-content: flex-end; align-items: center; padding: 0 0 10px 0; margin-bottom: 15px; border-bottom: 1px solid var(--border-color); flex-wrap: wrap; gap: 15px; }
        .auth-container { display: flex; justify-content: flex-end; align-items: center; gap: 10px; }
        .user-info { display: flex; align-items: center; gap: 10px; }
        .user-avatar { width: 36px; height: 36px; border-radius: 50%; border: 2px solid rgba(0,0,0,0.1); }

        /* Table Styles */
        .data-table-container { overflow-x: auto; margin-top: 20px; border: 1px solid var(--border-color); border-radius: 8px; }
        table.data-table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
        table.data-table th, table.data-table td { border-bottom: 1px solid var(--border-color); padding: 12px 15px; text-align: left; vertical-align: middle; /* Changed vertical-align */ }
        table.data-table th { background-color: #f8f9fa; font-weight: 500; color: #444; cursor: pointer; position: relative; border-bottom-width: 2px; }
        table.data-table th .sort-icon { position: absolute; right: 8px; top: 50%; transform: translateY(-50%); font-size: 0.8em; color: #999; }
        table.data-table tbody tr { transition: background-color 0.15s ease; }
        table.data-table tbody tr:nth-child(even):not(.group-header) { background-color: #fdfdfd; }
        table.data-table tbody tr:hover:not(.group-header) { background-color: #f1f5ff; }
        table.data-table td { color: #555; }
        table.data-table td.actions-cell { white-space: nowrap; width: 1%; text-align: right; } /* Align actions right */
        table.data-table td.actions-cell button { margin: 1px 3px; }
        .formatted-content { max-height: 300px; /* Increased height */ overflow-y: auto; padding: 10px; background-color: #f8f9fa; border: 1px solid #eee; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.95em; }
        .formatted-content dl { margin: 0; padding: 0; }
        .formatted-content dt { font-weight: 500; color: var(--primary-dark); margin-top: 10px; font-size: 0.95em; }
        .formatted-content dd { margin-left: 15px; padding: 3px 0; white-space: pre-wrap; word-wrap: break-word; color: #444; }
        .formatted-content p { margin: 5px 0; }
        .formatted-content strong { color: #333; }
        .formatted-content pre { margin: 0; padding: 0; background: #eee; border-radius: 3px; padding: 8px; overflow-x: auto; } /* Style for preformatted code/JSON */
        .formatted-content .question-item { margin-bottom: 12px; padding-bottom: 10px; border-bottom: 1px dashed #ddd; }
        .formatted-content .question-item:last-child { border-bottom: none; }
        .formatted-content ul { margin: 5px 0 5px 20px; padding-left: 0; list-style: disc; } /* Style for lists (e.g., MC options) */
        .formatted-content li { margin-bottom: 4px; }
        .group-header td { background-color: var(--primary-color) !important; color: white; font-weight: 500; font-size: 1.05em; padding: 10px 15px; border-bottom: 2px solid var(--primary-dark); }

        /* Dialog Styles */
        .dialog-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 1000; display: flex; justify-content: center; align-items: center; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s 0.3s; /* Delay hiding */ padding: 20px; }
        .dialog-backdrop.visible { opacity: 1; visibility: visible; transition: opacity 0.3s ease, visibility 0s 0s; }
        .dialog { background-color: white; border-radius: 10px; padding: 25px 30px; width: 100%; /* Use full width within padding */ max-width: 900px; /* Increased width */ box-shadow: 0 5px 20px rgba(0,0,0,0.2); margin: 0; /* Removed margin */ max-height: calc(100vh - 40px); /* Use viewport height minus padding */ display: flex; flex-direction: column; /* Allow content to scroll */ transform: scale(0.95); transition: transform 0.3s ease; }
        .dialog-backdrop.visible .dialog { transform: scale(1); }
        .dialog-title { margin-top: 0; margin-bottom: 20px; font-size: 1.4em; color: var(--primary-dark); border-bottom: 1px solid var(--border-color); padding-bottom: 10px; flex-shrink: 0; /* Prevent title from shrinking */ }
        .dialog-content { overflow-y: auto; /* Make content area scrollable */ flex-grow: 1; /* Allow content to take available space */ }
        .form-group { margin-bottom: 18px; }
        .form-group label { display: block; margin-bottom: 6px; font-weight: 500; font-size: 0.95em; color: #444; }
        .form-control { width: 100%; padding: 10px 12px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 1em; box-sizing: border-box; }
        .form-control:focus { border-color: var(--primary-color); outline: none; box-shadow: 0 0 0 2px rgba(57, 73, 171, 0.2); }
        textarea.form-control { min-height: 80px; resize: vertical; }
        .dialog-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 25px; border-top: 1px solid var(--border-color); padding-top: 15px; flex-shrink: 0; /* Prevent actions from shrinking */}

        /* Question Builder Styles */
        #questions-builder { border: 1px solid var(--border-color); border-radius: 6px; padding: 20px; margin-top: 10px; background-color: #fafafa; /* Removed max-height for auto sizing */ }
        .question-block { background-color: #fff; border: 1px solid #ccc; border-radius: 8px; padding: 20px; margin-bottom: 15px; position: relative; }
        .question-block label { font-weight: normal; font-size: 0.9em; }
        .question-block .form-control { font-size: 0.95em; padding: 8px 10px; }
        .question-block-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 8px;}
        .question-block-header span { font-weight: 500; color: var(--primary-dark); }
        .question-block .form-group { margin-bottom: 12px; }
        .remove-question-btn { position: absolute; top: 8px; right: 8px; padding: 3px 8px; font-size: 0.8em; line-height: 1; min-width: auto; }
        .conditional-field { display: none; /* Hide by default */ margin-top: 12px; padding-left: 15px; border-left: 3px solid var(--info-color); }
        .conditional-field label { font-size: 0.85em; color: #555; }
        .add-question-btn-container { text-align: center; margin-top: 20px; }

        /* Grading Dialog Specific Styles */
        #grading-dialog { max-width: 950px; /* Wider for grading */ }
        #grading-questions-container { /* Removed fixed max-height */ border: 1px solid #eee; border-radius: 8px; padding: 15px; margin: 20px 0; }
        .question-grading-card { border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 15px; background-color: #f9f9f9; display: grid; grid-template-columns: 1fr auto; /* Columns for content and points */ gap: 15px; align-items: start; }
        .question-grading-card.correct { border-left: 4px solid var(--success-color); }
        .question-grading-card.incorrect { border-left: 4px solid var(--danger-color); }
        .question-grading-card.partial { border-left: 4px solid var(--warning-color); }
        .question-grading-card.ungraded { border-left: 4px solid #999; }
        .question-grading-main { grid-column: 1 / 2; } /* Content takes first column */
        .question-grading-controls { grid-column: 2 / 3; text-align: right; } /* Points/buttons take second */
        .question-prompt { font-weight: 500; margin-bottom: 10px; }
        .student-answer, .correct-answer { padding: 10px; border-radius: 6px; margin-bottom: 10px; }
        .student-answer { background-color: #f0f0f0; border: 1px solid #ddd; }
        .correct-answer { background-color: rgba(67, 160, 71, 0.1); border: 1px solid rgba(67, 160, 71, 0.2); }
        .question-points { margin-bottom: 10px; }
        .question-points label { margin-right: 5px; }
        .question-points input { width: 60px; display: inline-block; }
        .auto-graded-label { background-color: var(--info-color); color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; margin-left: 10px; display: inline-block; }
        .grading-button-group button { margin-left: 5px; margin-bottom: 5px; } /* Spacing for grading buttons */

        /* Content Popup Styles */
        #content-popup { max-width: 800px; }
        #content-popup-content { /* Removed fixed max-height */ }

        /* Responsive Adjustments */
        @media (max-width: 768px) { /* Keep previous responsive */
             .container { padding: 15px; } .app-header { flex-direction: column; align-items: flex-start; gap: 15px; padding: 20px; } h1 { font-size: 1.6em; } .sync-auth-container { justify-content: center; } .module-content { padding: 20px; } table.data-table { font-size: 0.85em; } table.data-table th, table.data-table td { padding: 8px 10px; } .formatted-content { max-height: 250px; /* Restore max-height for small screens */ font-size: 0.9em; } .in-page-notifications { width: 95%; bottom: 10px; right: 50%; transform: translateX(50%); } button { padding: 8px 18px; font-size: 0.85em; }
             .dialog { max-width: calc(100% - 30px); max-height: calc(100vh - 30px); padding: 20px; } /* Adjust dialog size */
             #questions-builder { padding: 15px; }
             .question-grading-card { grid-template-columns: 1fr; /* Stack content and controls */ }
             .question-grading-controls { grid-column: 1 / 2; text-align: left; margin-top: 10px; }
		}
    </style>
</head>
<body class="content-hidden">

    <div class="container" id="main-container">

        <div class="sync-auth-container">
            <div class="auth-container">
                <div id="login-container"><button id="admin-signin-btn" class="btn-secondary"><i class="fab fa-google"></i> Sign In</button></div>
                <div id="user-container" style="display: none">
                    <div class="user-info">
                        <img id="user-avatar" class="user-avatar" src="" alt="Avatar">
                        <span id="user-name" style="font-weight: 500;"></span>
                        <button id="admin-signout-btn" class="btn-sm btn-danger"><i class="fas fa-sign-out-alt"></i> Sign Out</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="app-header" id="admin-header" style="display: none;">
            <h1><i class="fas fa-user-shield"></i> Admin Portal</h1>
        </div>

        <div id="signin-prompt-module" class="module" style="display: none;">
            <div class="module-content prompt-message"><i class="fas fa-lock"></i><h3>Admin Access Required</h3><p>Please sign in with the authorised Google Account.</p></div>
        </div>
        <div id="access-denied-module" class="module" style="display: none;">
            <div class="module-content prompt-message access-denied"><i class="fas fa-ban"></i><h3>Access Denied</h3><p>The signed-in account (<span id="denied-user-email"></span>) is not authorised.</p></div>
        </div>

        <div id="admin-dashboard-module" style="display: none;">

            <div id="exams-module" class="module">
                 <div class="module-content">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
                        <h2><i class="fas fa-file-alt"></i> Manage Exams</h2>
                        <div>
                            <button id="add-exam-btn" class="btn-success"><i class="fas fa-plus"></i> Add New Exam</button>
                            <button id="refresh-exams-btn"><i class="fas fa-sync-alt"></i> Refresh Exams</button>
                        </div>
                    </div>
                     <div id="exams-loading" style="display: none; margin-top: 10px;"><i class="fas fa-spinner fa-spin"></i> Loading exams...</div>
                     <div class="data-table-container">
                        <table class="data-table" id="exams-table">
                            <thead>
                                <tr>
                                    <th data-column="0">PIN <span class="sort-icon"></span></th>
                                    <th data-column="2">Name <span class="sort-icon"></span></th>
                                    <th data-column="3">Duration <span class="sort-icon"></span></th>
                                    <th data-column="4">Start Date <span class="sort-icon"></span></th>
                                    <th data-column="5">Start Time <span class="sort-icon"></span></th>
                                    <th data-column="6">Mode <span class="sort-icon"></span></th>
                                    <th data-column="7">Questions</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="exams-table-body">
                                </tbody>
                        </table>
                     </div>
                 </div>
            </div>

            <div id="attempts-module" class="module">
                 <div class="module-content">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
                        <h2><i class="fas fa-tasks"></i> View Submissions</h2>
                        <button id="refresh-attempts-btn"><i class="fas fa-sync-alt"></i> Refresh Attempts</button>
                    </div>
                    <div id="attempts-loading" style="display: none; margin-top: 10px;"><i class="fas fa-spinner fa-spin"></i> Loading attempts...</div>
                    <div class="data-table-container">
                        <table class="data-table" id="attempts-table">
                            <thead>
                                <tr>
                                    <th data-column="0">Timestamp</th>
                                    <th data-column="1">Name</th>
                                    <th data-column="2">Email</th>
                                    <th data-column="3">PIN</th>
                                    <th data-column="4">Course</th>
                                    <th data-column="5">Student ID</th>
                                    <th data-column="6">Status</th>
                                    <th>Answers</th>
                                    <th>Fingerprint</th>
                                    <th>Grade</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="attempts-table-body">
                                </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <div id="exam-dialog-backdrop" class="dialog-backdrop">
            <div id="exam-dialog" class="dialog">
                <h3 id="exam-dialog-title" class="dialog-title">Add New Exam</h3>
                <div class="dialog-content"> <form id="exam-form">
                        <input type="hidden" id="exam-row-index" value=""> <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                            <div class="form-group"> <label for="exam-pin">Exam PIN:</label> <input type="text" id="exam-pin" class="form-control" required> </div>
                            <div class="form-group"> <label for="exam-code">Course Code:</label> <input type="text" id="exam-code" class="form-control" required> </div>
                            <div class="form-group"> <label for="exam-name">Exam Name:</label> <input type="text" id="exam-name" class="form-control" required> </div>
                            <div class="form-group"> <label for="exam-duration">Duration (min):</label> <input type="number" id="exam-duration" class="form-control" required min="1"> </div>
                            <div class="form-group"> <label for="exam-start-date">Available Date:</label> <input type="date" id="exam-start-date" class="form-control" required> </div>
                            <div class="form-group"> <label for="exam-start-time">Available Time (HH:MM):</label> <input type="time" id="exam-start-time" class="form-control" required> </div>
                            <div class="form-group"> <label for="exam-mode">Mode:</label> <select id="exam-mode" class="form-control" required> <option value="Quiz">Quiz</option> <option value="Exam">Exam (Requires Student ID)</option> </select> </div>
                        </div>
                        <div class="form-group">
                            <label style="font-weight: bold; font-size: 1.1em;">Questions:</label>
                            <div id="questions-builder">
                                <p style="text-align: center; color: #777;">No questions added yet.</p>
                            </div>
                            <div class="add-question-btn-container">
                                 <button type="button" id="add-question-btn" class="btn-secondary btn-sm"><i class="fas fa-plus"></i> Add Question</button>
                            </div>
                        </div>
                        </form>
                </div>
                 <div class="dialog-actions">
                    <button type="button" id="cancel-exam-dialog-btn" class="btn-secondary">Cancel</button>
                    <button type="button" id="save-exam-dialog-btn" class="btn-success">Save Exam</button> </div>
            </div>
        </div>

        <div id="grading-dialog-backdrop" class="dialog-backdrop">
            <div id="grading-dialog" class="dialog">
                <h3 id="grading-dialog-title" class="dialog-title">Grade Submission</h3>
                <div class="dialog-content"> <div id="grading-student-info" class="form-group">
                        <p><strong>Student:</strong> <span id="grading-student-name"></span></p>
                        <p><strong>Email:</strong> <span id="grading-student-email"></span></p>
                        <p><strong>Exam:</strong> <span id="grading-exam-name"></span> (<span id="grading-exam-pin"></span>)</p>
                        <p><strong>Submitted:</strong> <span id="grading-timestamp"></span></p>
                    </div>

                    <div class="form-group">
                        <label><strong>Total Score:</strong></label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="number" id="grading-total-score" class="form-control" style="width: 80px;" min="0" step="0.1"> /
                            <span id="grading-max-score">0</span> points
                            (<span id="grading-percentage">0%</span>)
                        </div>
                    </div>

                    <div id="grading-questions-container">
                        <p style="text-align: center; color: #777;">Loading questions and answers...</p>
                    </div>

                    <div class="form-group">
                        <label for="grading-feedback">Feedback to Student:</label>
                        <textarea id="grading-feedback" class="form-control" rows="3" placeholder="Add feedback for the student..."></textarea>
                    </div>
                </div>
                <div class="dialog-actions">
                    <button type="button" id="cancel-grading-dialog-btn" class="btn-secondary">Cancel</button>
                    <button type="button" id="run-autograder-btn" class="btn-info">
                        <i class="fas fa-magic"></i> Run Autograder
                    </button>
                    <button type="button" id="save-grading-dialog-btn" class="btn-success">Save Grades</button>
                </div>
            </div>
        </div>

        <div id="content-popup-backdrop" class="dialog-backdrop">
          <div id="content-popup" class="dialog">
            <h3 id="content-popup-title" class="dialog-title">Content Details</h3>
            <div id="content-popup-content" class="dialog-content formatted-content"> </div>
            <div class="dialog-actions">
              <button type="button" id="close-content-popup-btn" class="btn-secondary">Close</button>
            </div>
          </div>
        </div>

        <div id="in-page-notification-area" class="in-page-notifications"></div>

        <footer class="footer"><p><i class="far fa-copyright"></i> 2023-<span id="currentYear"></span> Exam Admin Portal.</p></footer>

    </div> <script>
        // === Configuration ===
        const ADMIN_EMAIL = 'bplaku@epoka.edu.al'; // Ensure this matches your admin account
        const CLIENT_ID = '740588046540-npg0crodtcuinveu6bua9rd6c3hb2s1m.apps.googleusercontent.com'; // Your Client ID
        const API_KEY = 'AIzaSyD295FTtMHvXxZablRf0f-FR-IQ2dQRPQE'; // Your API Key (restrict appropriately)
        const EXAM_SPREADSHEET_ID = '14SgW9V3ZLYDqqoAutkvHEuLvcogpJ2hMEj_qj72wmEw'; // Your Spreadsheet ID
        const EXAM_DETAILS_SHEET_NAME = 'Exams';
        const EXAM_ATTEMPTS_SHEET_NAME = 'Attempts';
        const DISCOVERY_DOCS = ["https://sheets.googleapis.com/$discovery/rest?version=v4"];
        const SCOPES = "https://www.googleapis.com/auth/spreadsheets https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile"; // READ/WRITE Scope

        // === App State ===
        let isAdminAllowed = false; let isSignedIn = false; let currentUser = null;
        let tokenClient = null; let gapiLoaded = false; let gsiLoaded = false;
        let isOnline = navigator.onLine; let isSyncing = false;
        let currentSortColumn = { table: null, index: -1, ascending: true };
        let allExamsData = []; // Holds { data: rowArray, originalIndex: number }

        // Grading State
		let currentGradingData = null; // Holds the attempt row data for grading
		let currentExamQuestions = null; // Holds parsed questions for the current grading exam
		let currentSubmissionAnswers = null; // Holds parsed answers for the current grading submission
		let currentGradeSheetRow = null; // Holds the sheet row number of the attempt being graded

        // === DOM Elements === (Get references to all needed elements)
        const mainContainer = document.getElementById('main-container');
        const loginContainer = document.getElementById('login-container');
        const userContainer = document.getElementById('user-container');
        const userName = document.getElementById('user-name');
        const userAvatar = document.getElementById('user-avatar');
        const adminSigninBtn = document.getElementById('admin-signin-btn');
        const adminSignoutBtn = document.getElementById('admin-signout-btn');
        const notificationArea = document.getElementById('in-page-notification-area');
        const signinPromptModule = document.getElementById('signin-prompt-module');
        const accessDeniedModule = document.getElementById('access-denied-module');
        const deniedUserEmail = document.getElementById('denied-user-email');
        const adminDashboardModule = document.getElementById('admin-dashboard-module');
        const adminHeader = document.getElementById('admin-header');
        const addExamBtn = document.getElementById('add-exam-btn');
        const refreshExamsBtn = document.getElementById('refresh-exams-btn');
        const examsLoading = document.getElementById('exams-loading');
        const examsTable = document.getElementById('exams-table');
        const examsTableBody = document.getElementById('exams-table-body');
        const refreshAttemptsBtn = document.getElementById('refresh-attempts-btn');
        const attemptsLoading = document.getElementById('attempts-loading');
        const attemptsTable = document.getElementById('attempts-table');
        const attemptsTableBody = document.getElementById('attempts-table-body');
        // Exam Dialog
        const examDialogBackdrop = document.getElementById('exam-dialog-backdrop');
        const examDialog = document.getElementById('exam-dialog');
        const examDialogTitle = document.getElementById('exam-dialog-title');
        const examForm = document.getElementById('exam-form');
        const cancelExamDialogBtn = document.getElementById('cancel-exam-dialog-btn');
        const saveExamDialogBtn = document.getElementById('save-exam-dialog-btn');
        const examRowIndexInput = document.getElementById('exam-row-index');
        const examPinInput = document.getElementById('exam-pin');
        const examCodeInput = document.getElementById('exam-code');
        const examNameInput = document.getElementById('exam-name');
        const examDurationInput = document.getElementById('exam-duration');
        const examStartDateInput = document.getElementById('exam-start-date');
        const examStartTimeInput = document.getElementById('exam-start-time');
        const examModeInput = document.getElementById('exam-mode');
        const questionsBuilderDiv = document.getElementById('questions-builder');
        const addQuestionBtn = document.getElementById('add-question-btn');
        // Grading Dialog
        const gradingDialogBackdrop = document.getElementById('grading-dialog-backdrop');
        const gradingDialog = document.getElementById('grading-dialog');
        const gradingDialogTitle = document.getElementById('grading-dialog-title');
        const gradingStudentName = document.getElementById('grading-student-name');
        const gradingStudentEmail = document.getElementById('grading-student-email');
        const gradingExamName = document.getElementById('grading-exam-name');
        const gradingExamPin = document.getElementById('grading-exam-pin');
        const gradingTimestamp = document.getElementById('grading-timestamp');
        const gradingTotalScoreInput = document.getElementById('grading-total-score');
        const gradingMaxScoreSpan = document.getElementById('grading-max-score');
        const gradingPercentageSpan = document.getElementById('grading-percentage');
        const gradingQuestionsContainer = document.getElementById('grading-questions-container');
        const gradingFeedbackInput = document.getElementById('grading-feedback');
        const cancelGradingDialogBtn = document.getElementById('cancel-grading-dialog-btn');
        const runAutograderBtn = document.getElementById('run-autograder-btn');
        const saveGradingDialogBtn = document.getElementById('save-grading-dialog-btn');
        // Content Popup
        const contentPopupBackdrop = document.getElementById('content-popup-backdrop');
        const contentPopup = document.getElementById('content-popup');
        const contentPopupTitle = document.getElementById('content-popup-title');
        const contentPopupContent = document.getElementById('content-popup-content');
        const closeContentPopupBtn = document.getElementById('close-content-popup-btn');


        // === Initialisation ===
        window.addEventListener('load', initAdmin);

        function initAdmin() {
            console.log("Initialising Admin Portal...");
            document.body.classList.remove('content-hidden');
            mainContainer.classList.add('content-visible');
            updateYear();
            setupEventListeners();
            updateOnlineStatus();
            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);
            checkApiLoads(); // Start checking if Google API scripts are loaded
        }

        function checkApiLoads() {
             // Check if GAPI client script is loaded
             if (typeof gapi !== 'undefined' && !gapiLoaded) {
                 gapiLoaded = true;
                 // Load the 'client' library component
                 gapi.load('client', initializeGapiClient);
             }
             // Check if Google Sign-In (GSI) script is loaded
             if (typeof google !== 'undefined' && !gsiLoaded) {
                 gsiLoaded = true;
                 initializeGsiClient();
             }
             // If either script isn't loaded yet, schedule another check
             if (!gapiLoaded || !gsiLoaded) {
                 setTimeout(checkApiLoads, 100); // Check again shortly
             } else {
                 console.log("Google API client and GSI scripts loaded.");
                 // Both scripts are ready
             }
        }

        function setupEventListeners() {
            // Auth buttons
            adminSigninBtn?.addEventListener('click', handleAuthClick);
            adminSignoutBtn?.addEventListener('click', handleAdminSignoutClick);

            // Exam controls
            addExamBtn?.addEventListener('click', showAddExamDialog);
            refreshExamsBtn?.addEventListener('click', loadExamsData);
            examsTableBody?.addEventListener('click', handleExamsTableActions); // Listener for edit/delete buttons in exams table

            // Attempt controls
            refreshAttemptsBtn?.addEventListener('click', loadAttemptsData);
            attemptsTableBody?.addEventListener('click', handleAttemptsTableActions); // Listener for grade/delete/view buttons in attempts table

            // Exam Dialog controls
            cancelExamDialogBtn?.addEventListener('click', closeExamDialog);
            saveExamDialogBtn?.addEventListener('click', handleSaveExam); // Changed from form 'submit' to button 'click'
            // examDialogBackdrop?.addEventListener('click', (e) => { // REMOVED: Close on backdrop click
            //     if (e.target === examDialogBackdrop) closeExamDialog();
            // });
            addQuestionBtn?.addEventListener('click', addQuestionBlock);
            // Use event delegation for dynamic elements inside the builder
            questionsBuilderDiv?.addEventListener('change', handleQuestionTypeChange);
            questionsBuilderDiv?.addEventListener('click', handleRemoveQuestion);

            // Grading Dialog controls
            cancelGradingDialogBtn?.addEventListener('click', closeGradingDialog);
            runAutograderBtn?.addEventListener('click', runAutograder);
            saveGradingDialogBtn?.addEventListener('click', saveGrades);
            gradingTotalScoreInput?.addEventListener('input', updateGradePercentage);
            // gradingDialogBackdrop?.addEventListener('click', (e) => { // REMOVED: Close on backdrop click
            //     if (e.target === gradingDialogBackdrop) closeGradingDialog();
            // });

            // Content Popup controls
            closeContentPopupBtn?.addEventListener('click', closeContentPopup);
            // contentPopupBackdrop?.addEventListener('click', (e) => { // REMOVED: Close on backdrop click
            //     if (e.target === contentPopupBackdrop) closeContentPopup();
            // });

            // Table sorting
            document.querySelectorAll('.data-table thead th[data-column]').forEach(th => {
                th.addEventListener('click', () => handleSortTable(th));
            });
        }

        function updateYear() {
            const el = document.getElementById('currentYear');
            if (el) {
                el.textContent = new Date().getFullYear();
            }
        }

        // === Google API & Auth ===
        async function initializeGapiClient() {
             console.log("Initialising GAPI client...");
             try {
                 // Initialize the client with API key and discovery docs for Sheets API
                 await gapi.client.init({
                     apiKey: API_KEY,
                     discoveryDocs: DISCOVERY_DOCS,
                 });
                 console.log("GAPI client initialised.");
                 checkAuthStatus(); // Check if user is already signed in with a stored token
             } catch (error) {
                 handleApiInitError(error, "GAPI Client Init");
             }
         }

        function initializeGsiClient() {
            console.log("Initialising GSI client (for OAuth2 tokens)...");
            try {
                // Initialize the token client used to request access tokens
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CLIENT_ID,
                    scope: SCOPES, // Define required permissions
                    callback: handleTokenResponse, // Function to call when token is received
                });
                console.log("GSI client initialised.");
            } catch (error) {
                handleApiInitError(error, "GSI Client Init");
            }
        }

        function handleApiInitError(error, context = "API Init") {
            console.error(`${context} Error:`, error);
            showImprovedNotification('error', `${context} Error`, `Failed to initialise Google services: ${error.message || 'Unknown error'}. Please refresh.`);
            updateAdminAuthUI(); // Update UI to reflect the error state
        }

        function checkAuthStatus() {
            const savedToken = localStorage.getItem('gapi_admin_token');
            if (savedToken) {
                try {
                    const token = JSON.parse(savedToken);
                    // Basic check if token exists and has an access_token property
                    if (token?.access_token /* && !isTokenExpired(token) */ ) { // Add expiry check if needed
                        console.log("Using stored token.");
                        gapi.client.setToken(token); // Set the token for GAPI client
                        handleAdminSignIn(token); // Proceed to sign-in logic with the token
                    } else {
                        throw new Error('Invalid stored token');
                    }
                } catch(e) {
                    console.warn("Removing invalid stored token.", e);
                    localStorage.removeItem('gapi_admin_token');
                    updateAdminAuthUI(); // Show logged-out UI
                }
            } else {
                console.log("No stored token found.");
                updateAdminAuthUI(); // Show logged-out UI
            }
        }

        function handleAuthClick() {
            if (tokenClient) {
                // Request an access token. Prompt user to select account if needed.
                tokenClient.requestAccessToken({ prompt: 'select_account' });
            } else {
                console.error('Token client not initialised.');
                showImprovedNotification('error', 'Authentication Error', 'Authentication service is not ready. Please try again later.');
            }
        }

        function handleTokenResponse(resp) {
            // Called by GSI after user interaction (grant/deny/cancel)
            if (resp.error) {
                console.error('Token response error:', resp);
                let msg = `Authentication failed: ${resp.error}`;
                if (resp.error === 'popup_closed_by_user') msg = 'Sign-in cancelled by user.';
                if (resp.error === 'access_denied') msg = 'Access denied. Please grant permission to proceed.';
                showImprovedNotification('error', 'Authentication Error', msg);
                handleAdminSignoutLogic(); // Treat errors as sign-out
                return;
            }
            console.log('Access token received.');
            localStorage.setItem('gapi_admin_token', JSON.stringify(resp)); // Store the new token
            gapi.client.setToken(resp); // Set token for GAPI
            handleAdminSignIn(resp); // Proceed with sign-in logic
        }

        async function handleAdminSignIn(token) {
            // Called after a token is obtained (new or stored)
            if (!gapi.client) {
                 console.error("GAPI client not ready during sign-in attempt.");
                 showImprovedNotification('error', 'Error', 'Google API Client not ready.');
                 return;
            }
            await fetchUserInfo(); // Get user details associated with the token

            isAdminAllowed = false; // Reset flag
            if (currentUser?.email?.toLowerCase() === ADMIN_EMAIL.toLowerCase()) {
                 console.log(`Admin access GRANTED for ${currentUser.email}`);
                 isAdminAllowed = true;
                 isSignedIn = true;
                 console.log("Admin logged in, auto-loading data...");
                 loadExamsData(); // Load initial data
                 loadAttemptsData();
            } else if (currentUser) {
                 console.warn(`Access DENIED for user: ${currentUser.email}`);
                 isAdminAllowed = false;
                 isSignedIn = true; // Signed in, but not admin
                 if (deniedUserEmail) deniedUserEmail.textContent = currentUser.email;
            } else {
                 // Failed to fetch user info, token might be invalid
                 console.error("Failed to fetch user info after obtaining token.");
                 isAdminAllowed = false;
                 isSignedIn = false;
            }
            updateAdminAuthUI(); // Update UI based on signed-in and admin status
         }

        async function fetchUserInfo() {
             // Get the current access token from the GAPI client
             const accessToken = gapi.client?.getToken()?.access_token;
             if (!accessToken) {
                 console.warn("fetchUserInfo called without an access token.");
                 currentUser = null; // No user info if no token
                 return;
             }
             console.log('Fetching user information...');
             try {
                 // Use standard fetch to call the Google UserInfo endpoint
                 const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                     headers: { 'Authorization': `Bearer ${accessToken}` }
                 });
                 if (!response.ok) {
                     // Handle specific errors like 401 Unauthorized (token expired/revoked)
                     if (response.status === 401) {
                         console.warn("User Info fetch failed (401 - Unauthorized). Token might be invalid/expired.");
                         handleAdminSignoutLogic(); // Sign out if token is bad
                         return;
                     }
                     throw new Error(`(${response.status}) ${await response.text()}`);
                 }
                 const userInfo = await response.json();
                 // Store relevant user details
                 currentUser = {
                     id: userInfo.sub,
                     name: userInfo.name || 'N/A',
                     email: userInfo.email || 'N/A',
                     picture: userInfo.picture || ''
                 };
                 console.log('User details fetched:', currentUser.email);
             } catch (e) {
                 console.error('Fetch user info error:', e);
                 showImprovedNotification('error', 'User Info Error', `Could not get user details: ${e.message}. Please try signing in again.`);
                 currentUser = null; // Clear user info on error
             }
         }

        function handleAdminSignoutClick() {
            handleAdminSignoutLogic();
            showImprovedNotification('info', 'Signed Out', 'You have been signed out.');
        }

        function handleAdminSignoutLogic() {
             const token = gapi.client?.getToken(); // Get current token from GAPI
             if (token?.access_token) {
                 try {
                     // Attempt to revoke the token on Google's side
                     google.accounts.oauth2.revoke(token.access_token, () => console.log('Admin token revoked.'));
                 } catch (e) {
                     console.warn("Token revoke error (might be normal if token already invalid):", e);
                 }
                 gapi.client.setToken(''); // Clear token from GAPI client instance
             }
             localStorage.removeItem('gapi_admin_token'); // Remove token from storage

             // Reset app state
             isSignedIn = false;
             isAdminAllowed = false;
             currentUser = null;
             allExamsData = [];
             // Clear UI elements
             updateAdminAuthUI();
             clearTableData();
         }

        // === UI State ===
        function updateAdminAuthUI() {
             console.log('Updating Admin Auth UI - SignedIn:', isSignedIn, 'IsAdmin:', isAdminAllowed);
             if (isSignedIn) {
                 // Show user info, hide login button
                 userContainer.style.display = 'flex';
                 loginContainer.style.display = 'none';
                 if (userName) userName.textContent = currentUser?.name || 'User';
                 if (userAvatar) userAvatar.src = currentUser?.picture || '';

                 if (isAdminAllowed) {
                     // Admin is logged in and authorized
                     signinPromptModule.style.display = 'none';
                     accessDeniedModule.style.display = 'none';
                     adminDashboardModule.style.display = 'block';
                     adminHeader.style.display = 'flex';
                     // Enable buttons based on online status
                     refreshExamsBtn.disabled = !isOnline;
                     refreshAttemptsBtn.disabled = !isOnline;
                     addExamBtn.disabled = !isOnline;
                 } else {
                     // User is logged in but NOT authorized
                     signinPromptModule.style.display = 'none';
                     adminDashboardModule.style.display = 'none';
                     adminHeader.style.display = 'none';
                     accessDeniedModule.style.display = 'block';
                     if (deniedUserEmail) deniedUserEmail.textContent = currentUser?.email || 'Unknown User';
                 }
             } else {
                 // User is not signed in
                 userContainer.style.display = 'none';
                 loginContainer.style.display = 'block';
                 signinPromptModule.style.display = 'block'; // Show the prompt to sign in
                 accessDeniedModule.style.display = 'none';
                 adminDashboardModule.style.display = 'none';
                 adminHeader.style.display = 'none';
                 // Disable buttons
                 refreshExamsBtn.disabled = true;
                 refreshAttemptsBtn.disabled = true;
                 addExamBtn.disabled = true;
             }
         }

        function clearTableData() {
             // Clear table bodies
             examsTableBody.innerHTML = '';
             attemptsTableBody.innerHTML = '';
             // Reset data arrays and sorting state
             allExamsData = [];
             currentSortColumn = { table: null, index: -1, ascending: true };
             // Clear sort icons in table headers
             document.querySelectorAll('.sort-icon').forEach(icon => icon.textContent = '');
         }

        // === Google Sheets Interaction ===
        async function getSheetData(spreadsheetId, range) {
             // Check permissions and API readiness
             if (!isSignedIn || !gapi?.client?.sheets) {
                 if(!isAdminAllowed && isSignedIn) {
                     showImprovedNotification('error', 'Access Denied', 'Your account cannot access Sheets data.');
                 } else {
                     showImprovedNotification('error', 'API Error', 'Not signed in or Sheets API not ready.');
                 }
                 return null; // Return null on error
             }
             // Check online status
             if (!isOnline) {
                 showImprovedNotification('warning', 'Offline', 'Cannot fetch Sheets data offline.');
                 return null;
             }

             console.log(`Admin fetching data from: ${spreadsheetId}, Range: ${range}`);
             setSyncing(true); // Show loading indicator
             try {
                 // Make the API call to get spreadsheet values
                 const response = await gapi.client.sheets.spreadsheets.values.get({
                     spreadsheetId,
                     range
                 });
                 console.log(`Admin fetched data for ${range}`);
                 return response.result.values || []; // Return array of rows or empty array
             } catch (err) {
                 console.error(`Admin error fetching ${range}:`, err);
                 const errorDetails = err.result?.error;
                 let message = `Could not fetch data: ${errorDetails?.message || err.message}`;
                 // Provide specific feedback for permission errors
                 if (errorDetails?.status === 'PERMISSION_DENIED') {
                     message = 'Permission denied. Ensure the admin account has editor access to the Sheet.';
                 } else if (errorDetails?.status === 'NOT_FOUND') {
                     message = `Sheet or range not found: ${range}`;
                 }
                 showImprovedNotification('error', 'Sheet Read Error', message);
                 return null; // Return null on failure
             } finally {
                 setSyncing(false); // Hide loading indicator
             }
         }

        async function appendSheetData(spreadsheetId, sheetName, values) {
            // Check permissions and API readiness
            if (!isAdminAllowed || !isSignedIn || !gapi?.client?.sheets) {
                showImprovedNotification('error', 'API/Auth Error', 'Not authorized or Sheets API not ready for append.');
                return false;
            }
            // Check if write scope was granted (though included in SCOPES, good practice)
            if (!SCOPES.includes("https://www.googleapis.com/auth/spreadsheets")) {
                console.warn("Write scope missing, though it should have been requested.");
                showImprovedNotification('warning', 'Permission Issue', 'Write scope missing for append operation.');
                return false;
            }
            // Check online status
            if (!isOnline) {
                showImprovedNotification('warning', 'Offline', 'Cannot append data while offline.');
                return false;
            }

            console.log(`Admin appending to Sheet: ${spreadsheetId}, Sheet: ${sheetName}`);
            setSyncing(true); // Show loading
            try {
                // Make the API call to append rows
                const response = await gapi.client.sheets.spreadsheets.values.append({
                    spreadsheetId,
                    range: sheetName, // Append to the end of the specified sheet
                    valueInputOption: 'USER_ENTERED', // Interpret values as if user typed them
                    insertDataOption: 'INSERT_ROWS', // Add new rows for the data
                    resource: { values } // The data to append (array of arrays)
                });
                console.log('Append success:', response.result);
                return true; // Indicate success
            } catch (err) {
                console.error(`Error appending to ${sheetName}:`, err);
                const errDetail = err.result?.error;
                let message = `Could not save data: ${errDetail?.message || err.message}`;
                 if (errDetail?.status === 'PERMISSION_DENIED') {
                     message = 'Permission denied. Ensure admin has editor access.';
                 }
                showImprovedNotification('error', `Sheet Write Error (${errDetail?.status || 'Unknown'})`, message);
                return false; // Indicate failure
            } finally {
                setSyncing(false); // Hide loading
            }
        }

        async function updateSheetData(spreadsheetId, range, values) {
            // Check permissions and API readiness
            if (!isAdminAllowed || !isSignedIn || !gapi?.client?.sheets) {
                showImprovedNotification('error', 'API/Auth Error', 'Not authorized or Sheets API not ready for update.');
                return false;
            }
             if (!SCOPES.includes("https://www.googleapis.com/auth/spreadsheets")) {
                console.warn("Write scope missing for update.");
                showImprovedNotification('warning', 'Permission Issue', 'Write scope missing for update operation.');
                return false;
            }
            if (!isOnline) {
                showImprovedNotification('warning', 'Offline', 'Cannot update data while offline.');
                return false;
            }

            console.log(`Admin updating Sheet: ${spreadsheetId}, Range: ${range}`);
            setSyncing(true);
            try {
                // Make the API call to update cell values
                const response = await gapi.client.sheets.spreadsheets.values.update({
                    spreadsheetId,
                    range, // The specific range to update (e.g., "Sheet1!A1:B2")
                    valueInputOption: 'USER_ENTERED', // Interpret values as if user typed them
                    resource: { values } // Data to write (array of arrays)
                });
                console.log('Update success:', response.result);
                return true;
            } catch (err) {
                console.error(`Error updating ${range}:`, err);
                const errDetail = err.result?.error;
                 let message = `Could not update data: ${errDetail?.message || err.message}`;
                 if (errDetail?.status === 'PERMISSION_DENIED') {
                     message = 'Permission denied. Ensure admin has editor access.';
                 }
                showImprovedNotification('error', `Sheet Write Error (${errDetail?.status || 'Unknown'})`, message);
                return false;
            } finally {
                setSyncing(false);
            }
        }

        async function clearSheetRows(spreadsheetId, sheetName, rowIndex, count = 1) {
             if (!isAdminAllowed || !isSignedIn || !gapi?.client?.sheets) {
                 showImprovedNotification('error', 'API/Auth Error', 'Not authorized or Sheets API not ready for clear.');
                 return false;
             }
              if (!SCOPES.includes("https://www.googleapis.com/auth/spreadsheets")) {
                console.warn("Write scope missing for clear.");
                 showImprovedNotification('warning', 'Permission Issue', 'Write scope missing for clear operation.');
                return false;
             }
             if (!isOnline) {
                 showImprovedNotification('warning', 'Offline', 'Cannot clear data while offline.');
                 return false;
             }

             const sheetRowNumber = rowIndex + 1; // Sheets are 1-indexed
             const rangeToClear = `${sheetName}!A${sheetRowNumber}:${sheetRowNumber + count - 1}`; // Example: "Sheet1!A5:5" to clear row 5
             console.log(`Admin clearing Sheet: ${spreadsheetId}, Range: ${rangeToClear}`);
             setSyncing(true);
             try {
                 // Make the API call to clear cell values
                 // Note: This clears content but doesn't delete the row itself.
                 // To truly delete rows requires spreadsheets.batchUpdate with deleteDimension request.
                 const response = await gapi.client.sheets.spreadsheets.values.clear({
                     spreadsheetId,
                     range: rangeToClear,
                 });
                 console.log('Clear success:', response.result);
                 return true;
             } catch (err) {
                 console.error(`Error clearing ${rangeToClear}:`, err);
                 const errDetail = err.result?.error;
                  let message = `Could not clear data: ${errDetail?.message || err.message}`;
                  if (errDetail?.status === 'PERMISSION_DENIED') {
                      message = 'Permission denied. Ensure admin has editor access.';
                  }
                 showImprovedNotification('error', `Sheet Write Error (${errDetail?.status || 'Unknown'})`, message);
                 return false;
             } finally {
                 setSyncing(false);
             }
        }


        // === Admin Data Loading & Display ===
        async function loadExamsData() {
            if (!isAdminAllowed) return;
            console.log("Loading exams data...");
            examsLoading.style.display = 'block';
            refreshExamsBtn.disabled = true;
            examsTableBody.innerHTML = ''; // Clear existing table
            allExamsData = []; // Reset data cache

            // Fetch data from A:H (PIN to Questions)
            const data = await getSheetData(EXAM_SPREADSHEET_ID, `${EXAM_DETAILS_SHEET_NAME}!A:H`);

            examsLoading.style.display = 'none';
            refreshExamsBtn.disabled = !isOnline; // Re-enable based on online status

            if (data && data.length > 1) { // Check if data exists (more than just header)
                // Store data with original index (0-based) for later reference (e.g., editing)
                allExamsData = data.slice(1).map((row, index) => ({
                    data: row,
                    originalIndex: index // 0-based index in the fetched data (excluding header)
                }));

                // Sort by Course Code (column 1), then PIN (column 0)
                allExamsData.sort((a, b) => {
                    const codeA = a.data[1] || ''; // Course Code
                    const codeB = b.data[1] || '';
                    const pinA = a.data[0] || ''; // PIN
                    const pinB = b.data[0] || '';
                    const codeCompare = codeA.localeCompare(codeB);
                    if (codeCompare !== 0) {
                        return codeCompare; // Sort by code first
                    }
                    return pinA.localeCompare(pinB); // Then by PIN within the same code
                });

                populateExamsTable(allExamsData); // Render the sorted data
                resetSortIcon(examsTable); // Clear any previous sort indicators
            } else if (data) { // Data fetched but only header row or empty
                examsTableBody.innerHTML = `<tr><td colspan="8">No exams found.</td></tr>`;
            } else { // Fetch failed (getSheetData returned null)
                examsTableBody.innerHTML = `<tr><td colspan="8">Failed to load exam data. Check permissions or connection.</td></tr>`;
            }
        }

        function populateExamsTable(sortedExamData) {
             if (!sortedExamData || sortedExamData.length === 0) {
                 examsTableBody.innerHTML = `<tr><td colspan="8">No exams found.</td></tr>`;
                 return;
             }

             let currentCourseCode = null;
             let rowsHtml = '';

             sortedExamData.forEach(item => {
                 const row = item.data;
                 const originalIndex = item.originalIndex; // 0-based index from original fetch
                 const sheetRowNumber = originalIndex + 2; // Calculate 1-based sheet row number

                 // Extract data, providing defaults for empty cells
                 const pin = row[0] || '';
                 const courseCode = row[1] || '';
                 const name = row[2] || '';
                 const duration = row[3] || '';
                 const startDate = row[4] || '';
                 const startTime = row[5] || '';
                 const mode = row[6] || '';
                 const questionsRaw = row[7] || '[]'; // Default to empty JSON array string

                 // Count questions for display
                 let questionsCount = 0;
                 try {
                     const questions = JSON.parse(questionsRaw);
                     questionsCount = Array.isArray(questions) ? questions.length : 0;
                 } catch (e) { questionsCount = 0; /* Handle parse error */ }

                 // Add group header row if course code changes
                 if (courseCode !== currentCourseCode) {
                     currentCourseCode = courseCode;
                     rowsHtml += `<tr class="group-header"><td colspan="8">Course: ${escapeHtml(currentCourseCode || 'Uncategorized')}</td></tr>`;
                 }

                 // Add data row
                 // Store originalIndex and sheetRowNumber in data attributes
                 rowsHtml += `<tr data-original-index="${originalIndex}" data-sheet-row="${sheetRowNumber}" data-pin="${escapeHtml(pin)}" data-questions='${escapeHtml(questionsRaw)}'>
                     <td>${escapeHtml(pin)}</td>
                     <td>${escapeHtml(name)}</td>
                     <td>${escapeHtml(duration)}</td>
                     <td>${escapeHtml(startDate)}</td>
                     <td>${escapeHtml(startTime)}</td>
                     <td>${escapeHtml(mode)}</td>
                     <td>
                         <button type="button" class="btn-sm btn-info" onclick="showQuestionsPopup(this.closest('tr'))">
                            <i class="fas fa-question-circle"></i> View (${questionsCount})
                         </button>
                     </td>
                     <td class="actions-cell">
                         <button type="button" class="btn-sm btn-secondary edit-exam-btn" title="Edit Exam">
                             <i class="fas fa-edit"></i>
                         </button>
                         <button type="button" class="btn-sm btn-danger delete-exam-btn" title="Delete Exam">
                             <i class="fas fa-trash"></i>
                         </button>
                     </td>
                 </tr>`;
             });

             examsTableBody.innerHTML = rowsHtml;
         }

        async function loadAttemptsData() {
            if (!isAdminAllowed) return;
            console.log("Loading attempts data...");
            attemptsLoading.style.display = 'block';
            refreshAttemptsBtn.disabled = true;
            attemptsTableBody.innerHTML = ''; // Clear table

            // Fetch data A:J (Timestamp to Grades)
            const data = await getSheetData(EXAM_SPREADSHEET_ID, `${EXAM_ATTEMPTS_SHEET_NAME}!A:J`);

            attemptsLoading.style.display = 'none';
            refreshAttemptsBtn.disabled = !isOnline;

            if (data) {
                populateAttemptsTable(data); // Render attempts
                resetSortIcon(attemptsTable); // Clear sort icons
            } else { // Fetch failed
                attemptsTableBody.innerHTML = `<tr><td colspan="11">Failed to load attempts data. Check permissions or connection.</td></tr>`;
            }
        }

         function populateAttemptsTable(data) {
             // Check if data exists and has more than just the header row
             if (!data || data.length <= 1) {
                 attemptsTableBody.innerHTML = `<tr><td colspan="11">No attempts found.</td></tr>`;
                 return;
             }

             // Process rows starting from the second row (index 1)
             const rowsHtml = data.slice(1).map((row, index) => {
                 const sheetRowNumber = index + 2; // Calculate 1-based sheet row number

                 // Extract data, providing defaults
                 const timestamp = row[0] || '';
                 const studentName = row[1] || '';
                 const email = row[2] || '';
                 const pin = row[3] || '';
                 const courseCode = row[4] || '';
                 const studentId = row[5] || '';
                 const status = row[6] || '';
                 const answersRaw = row[7] || '{}'; // Default to empty JSON string
                 const fingerprintRaw = row[8] || '{}'; // Default to empty JSON string
                 const gradesJson = row[9] || ''; // Grades data (JSON string)

                 // Parse grades for summary display
                 let gradeSummary = '';
                 if (gradesJson) {
                     try {
                         const grades = JSON.parse(gradesJson);
                         // Ensure properties exist before accessing
                         const score = grades.totalScore ?? '?';
                         const max = grades.maxScore ?? '?';
                         const perc = grades.percentage ?? '?%';
                         gradeSummary = `<strong>${score}/${max}</strong> (${perc})`;
                     } catch (e) {
                         console.warn(`Error parsing grades JSON for row ${sheetRowNumber}:`, gradesJson, e);
                         gradeSummary = '<span style="color:red;">Error</span>';
                     }
                 }

                 // Create status badge
                 let statusBadge = '';
                 const lowerStatus = status.toLowerCase();
                 if (lowerStatus === 'submit') {
                     statusBadge = `<span style="background-color: var(--info-color); color: white; padding: 3px 8px; border-radius: 10px; font-size: 0.8em;">Submitted</span>`;
                 } else if (lowerStatus === 'graded') {
                     statusBadge = `<span style="background-color: var(--success-color); color: white; padding: 3px 8px; border-radius: 10px; font-size: 0.8em;">Graded</span>`;
                 }

                 // Store raw data in attributes for popups, properly escaped
                 // FIX: Directly store raw string, escape for HTML attribute context
                 const escapedAnswers = escapeHtmlAttribute(answersRaw);
                 const escapedFingerprint = escapeHtmlAttribute(fingerprintRaw);
                 const escapedGrades = escapeHtmlAttribute(gradesJson);

                 // Generate table row HTML
                 return `<tr data-sheet-row="${sheetRowNumber}"
                             data-key="${escapeHtml(timestamp)}-${escapeHtml(email)}-${escapeHtml(pin)}"
                             data-answers='${escapedAnswers}'
                             data-fingerprint='${escapedFingerprint}'
                             data-grades='${escapedGrades}'
                             data-pin='${escapeHtml(pin)}'
                             data-name='${escapeHtml(studentName)}'
                             data-email='${escapeHtml(email)}'
                             data-timestamp='${escapeHtml(timestamp)}'>
                     <td>${escapeHtml(timestamp)}</td>
                     <td>${escapeHtml(studentName)}</td>
                     <td>${escapeHtml(email)}</td>
                     <td>${escapeHtml(pin)}</td>
                     <td>${escapeHtml(courseCode)}</td>
                     <td>${escapeHtml(studentId)}</td>
                     <td>${statusBadge || escapeHtml(status)}</td>
                     <td>
                         <button type="button" class="btn-sm btn-info" onclick="showAnswersPopup(this.closest('tr'))">
                             <i class="fas fa-list-alt"></i> View
                         </button>
                     </td>
                     <td>
                         <button type="button" class="btn-sm btn-info" onclick="showFingerprintPopup(this.closest('tr'))">
                             <i class="fas fa-fingerprint"></i> View
                         </button>
                     </td>
                     <td>${gradeSummary || 'Not graded'}</td>
                     <td class="actions-cell">
                         <button type="button" class="btn-sm btn-secondary grade-attempt-btn" title="Grade/View Submission">
                             <i class="${lowerStatus === 'graded' ? 'fas fa-edit' : 'fas fa-check-square'}"></i>
                         </button>
                         <button type="button" class="btn-sm btn-danger delete-attempt-btn" title="Delete Attempt">
                             <i class="fas fa-trash"></i>
                         </button>
                     </td>
                 </tr>`;
             }).join('');

             attemptsTableBody.innerHTML = rowsHtml; // Add generated rows to the table body
         }

        // === UI Updates ===
        function updateOnlineStatus() {
             isOnline = navigator.onLine;
             console.log('Admin Connection:', isOnline ? 'Online' : 'Offline');
             if (!isOnline) {
                 showImprovedNotification('warning', 'Offline', 'Functionality requiring connection is disabled.', 5000);
             }
             // Enable/disable buttons based on online status and admin rights
             const buttonsDisabled = !isOnline || !isAdminAllowed;
             refreshExamsBtn.disabled = buttonsDisabled;
             refreshAttemptsBtn.disabled = buttonsDisabled;
             addExamBtn.disabled = buttonsDisabled;
             // Potentially disable save buttons in dialogs if offline
             saveExamDialogBtn.disabled = buttonsDisabled;
             saveGradingDialogBtn.disabled = buttonsDisabled;
         }

        function setSyncing(syncing) {
             isSyncing = syncing;
             console.log("Admin Syncing:", isSyncing);
             // Show/hide loading indicators
             const loadingDisplayStyle = syncing ? 'inline-block' : 'none'; // Use inline-block for spinners
             examsLoading.style.display = loadingDisplayStyle;
             attemptsLoading.style.display = loadingDisplayStyle;

             // Disable buttons during sync operations
             const buttonsDisabled = syncing || !isOnline || !isAdminAllowed;
             refreshExamsBtn.disabled = buttonsDisabled;
             refreshAttemptsBtn.disabled = buttonsDisabled;
             addExamBtn.disabled = buttonsDisabled;
             saveExamDialogBtn.disabled = buttonsDisabled;
             saveGradingDialogBtn.disabled = buttonsDisabled;
             // Disable table action buttons during sync? (Maybe not necessary)
         }

        function showImprovedNotification(type, title, message, duration = 5000) {
             const container = notificationArea;
             if (!container) {
                 console.error("Notification container element not found in the DOM.");
                 return;
             }
             // Create notification element
             const notification = document.createElement('div');
             notification.className = `in-page-notification in-page-notification-${type}`;

             // Determine icon based on type
             let iconClass;
             switch (type) {
                 case 'success': iconClass = 'fa-check-circle'; break;
                 case 'error':   iconClass = 'fa-times-circle'; break;
                 case 'warning': iconClass = 'fa-exclamation-triangle'; break;
                 default:        iconClass = 'fa-info-circle'; // Default to info
             }
             // Set inner HTML with icon, title, message, and close button
             notification.innerHTML = `<i class="fas ${iconClass} fa-icon"></i>
                                       <div class="notification-content"><strong>${escapeHtml(title)}</strong><br>${escapeHtml(message).replace(/\n/g, '<br>')}</div>
                                       <button type="button" class="notification-close" aria-label="Close">&times;</button>`;

             container.appendChild(notification); // Add to the DOM

             // Get close button and add click listener for manual dismissal
             const closeBtn = notification.querySelector('.notification-close');
             const removeNotification = () => {
                 notification.classList.add('removing'); // Add class to trigger slide-out animation
                 // Remove the element after the animation completes
                 setTimeout(() => {
                     // Check if parentNode still exists before removing
                     if (notification.parentNode) {
                          notification.parentNode.removeChild(notification);
                     }
                 }, 300); // Match timeout to CSS animation duration
             };
             closeBtn?.addEventListener('click', (e) => {
                 e.stopPropagation(); // Prevent event bubbling
                 removeNotification();
             });
             // Auto-dismiss after duration (if duration > 0)
             if (duration > 0) {
                 setTimeout(removeNotification, duration);
             }
        }

        // === Utility Functions ===
        function escapeHtml(unsafe) {
             // Basic HTML escaping
             if (typeof unsafe !== 'string') return unsafe;
             return unsafe
                  .replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")
                  .replace(/"/g, "&quot;")
                  .replace(/'/g, "&#039;");
        }

        function escapeHtmlAttribute(unsafe) {
             // Escape specifically for use within HTML attributes (e.g., data-*)
             // Primarily focuses on '&', '<', '>', '"', and especially ''' (single quote)
             // if the attribute itself is delimited by single quotes.
             if (typeof unsafe !== 'string') return unsafe;
             return unsafe
                 .replace(/&/g, '&amp;')
                 .replace(/'/g, '&#39;') // Crucial for attributes using single quotes
                 .replace(/"/g, '&quot;') // Good practice
                 .replace(/</g, '&lt;')
                 .replace(/>/g, '&gt;');
        }

        function formatJsonForDisplay(jsonString) {
             // Formats a JSON string (or potentially other strings) for display in the popup
             if (!jsonString || jsonString.trim() === '{}' || jsonString.trim() === '') return 'N/A';
             try {
                 const data = JSON.parse(jsonString);
                 if (typeof data !== 'object' || data === null || Object.keys(data).length === 0) return 'N/A';

                 let html = '<dl>';
                 for (const key in data) {
                     // Ensure it's an own property
                     if (Object.hasOwnProperty.call(data, key)) {
                         const value = data[key];
                         html += `<dt>${escapeHtml(key)}:</dt>`; // Display the key
                         let valueDisplay = '';

                         if (value === null || typeof value === 'undefined') {
                             valueDisplay = '<em>null/undefined</em>';
                         } else if (typeof value === 'object') {
                             // If the value is another object/array, pretty-print it as JSON
                             try {
                                 valueDisplay = `<pre>${escapeHtml(JSON.stringify(value, null, 2))}</pre>`;
                             } catch (nestedError) {
                                 valueDisplay = escapeHtml(String(value)); // Fallback
                             }
                         } else {
                             // For simple values (string, number, boolean), just display
                             valueDisplay = escapeHtml(String(value)).replace(/\n/g, '<br>');
                         }
                         html += `<dd>${valueDisplay || '<em>empty</em>'}</dd>`; // Display the value
                     }
                 }
                 html += '</dl>';
                 return html;
             } catch (e) {
                 // If parsing fails, display the original string, escaped
                 console.warn("Failed to parse JSON for display, showing raw data:", jsonString, e);
                 return `<pre>${escapeHtml(jsonString)}</pre>`; // Show raw data in pre tag
             }
         }

        // === Table Sorting ===
        function handleSortTable(thElement) {
            const table = thElement.closest('table');
            if (!table) return;
            const tbody = table.querySelector('tbody');
            if (!tbody) return;

            const columnIndex = parseInt(thElement.dataset.column, 10);
            const isExamsTable = table.id === 'exams-table';

            // Determine sort direction
            let isAscending = true;
            if (currentSortColumn.table === table && currentSortColumn.index === columnIndex) {
                isAscending = !currentSortColumn.ascending; // Toggle direction
            }
            currentSortColumn = { table, index: columnIndex, ascending: isAscending };

            if (isExamsTable) {
                // Sort the cached exams data
                allExamsData.sort((a, b) => {
                    const cellA = a.data[columnIndex]?.trim() || '';
                    const cellB = b.data[columnIndex]?.trim() || '';
                    return compareCells(cellA, cellB, isAscending);
                });
                // Re-render exams table with sorted data (handles grouping)
                populateExamsTable(allExamsData);
            } else {
                // Sort attempts table rows directly (doesn't have grouping issues like exams)
                const rows = Array.from(tbody.querySelectorAll('tr'));
                rows.sort((a, b) => {
                    const cellA = a.cells[columnIndex]?.textContent.trim() || '';
                    const cellB = b.cells[columnIndex]?.textContent.trim() || '';
                    return compareCells(cellA, cellB, isAscending);
                });
                // Re-append sorted rows
                rows.forEach(row => tbody.appendChild(row));
            }
            updateSortIcons(table, columnIndex, isAscending); // Update header icons
        }

        function compareCells(cellA, cellB, isAscending) {
             // Helper for sorting: attempts numeric sort first, then locale
             const numA = parseFloat(cellA);
             const numB = parseFloat(cellB);
             let comparison = 0;

             if (!isNaN(numA) && !isNaN(numB)) {
                 comparison = numA - numB; // Numeric comparison
             } else {
                 // Locale-sensitive string comparison (handles text, dates reasonably well)
                 comparison = cellA.localeCompare(cellB, undefined, { numeric: true, sensitivity: 'base' });
             }
             return isAscending ? comparison : -comparison; // Apply direction
         }

        function updateSortIcons(table, activeColumnIndex, isAscending) {
             // Update the sort indicator icons (/) in the table header
             table.querySelectorAll('thead th .sort-icon').forEach((icon, index) => {
                 icon.textContent = (index === activeColumnIndex) ? (isAscending ? ' ' : ' ') : '';
             });
         }

        function resetSortIcon(table) {
            // Clear all sort icons in a table header
            if (!table) return;
            table.querySelectorAll('thead th .sort-icon').forEach(icon => icon.textContent = '');
        }

        // === Dialog and Question Builder Management ===
        function showAddExamDialog() {
            console.log("Showing Add Exam Dialog");
            examForm.reset(); // Clear form fields
            questionsBuilderDiv.innerHTML = '<p style="text-align: center; color: #777;">No questions added yet.</p>'; // Clear builder
            examRowIndexInput.value = ''; // Clear row index (ensures it's an ADD operation)
            examDialogTitle.textContent = "Add New Exam";
            saveExamDialogBtn.textContent = "Add Exam";
            saveExamDialogBtn.disabled = !isOnline || !isAdminAllowed; // Disable if offline

            // --- Auto-fill Date/Time ---
            const now = new Date();
            // Format date as YYYY-MM-DD
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            examStartDateInput.value = `${year}-${month}-${day}`;
            // Format time as HH:MM (required by <input type="time">)
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            examStartTimeInput.value = `${hours}:${minutes}`; // Removed seconds
            // ---------------------------

            examDialogBackdrop.classList.add('visible'); // Show the dialog
        }

        function closeExamDialog() {
            examDialogBackdrop.classList.remove('visible');
        }

        function addQuestionBlock(questionData = null) {
            // Removes the "No questions" placeholder if it exists
            const placeholder = questionsBuilderDiv.querySelector('p');
            if (placeholder) placeholder.remove();

            const questionIndex = questionsBuilderDiv.querySelectorAll('.question-block').length;
            const block = document.createElement('div');
            block.className = 'question-block';
            block.dataset.index = questionIndex; // Keep track of order

            // Determine initial values from questionData if provided (for editing)
            const type = questionData?.type || 'short_answer';
            const prompt = questionData?.prompt || '';
            const lang = questionData?.language || '';
            const allowedTypes = (questionData?.allowed_types || []).join(',');
            const maxSize = questionData?.max_size_mb || '';
            const options = (questionData?.options || []).join('\n');
            const correct = (questionData?.correct_answers || []).join('\n');

            // Added 'multiple_select' option, set 'selected' based on type
            block.innerHTML = `
                <div class="question-block-header">
                    <span>Question ${questionIndex + 1}</span>
                    <button type="button" class="btn-danger btn-sm remove-question-btn" title="Remove Question">&times;</button>
                </div>
                <div class="form-group">
                    <label for="q-type-${questionIndex}">Type:</label>
                    <select id="q-type-${questionIndex}" class="form-control question-type-select">
                        <option value="short_answer" ${type === 'short_answer' ? 'selected' : ''}>Short Answer</option>
                        <option value="long_answer" ${type === 'long_answer' ? 'selected' : ''}>Long Answer / Instructions</option>
                        <option value="code" ${type === 'code' ? 'selected' : ''}>Code</option>
                        <option value="attachment" ${type === 'attachment' ? 'selected' : ''}>Attachment</option>
                        <option value="multiple_select" ${type === 'multiple_select' ? 'selected' : ''}>Multiple Choice</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="q-prompt-${questionIndex}">Prompt / Question Text:</label>
                    <textarea id="q-prompt-${questionIndex}" class="form-control question-prompt" rows="2" required>${escapeHtml(prompt)}</textarea>
                </div>

                {/* --- Conditional Fields (Populated with data if editing) --- */}
                <div class="conditional-field" data-type="code" style="${type === 'code' ? 'display: block;' : ''}">
                     <div class="form-group">
                        <label for="q-lang-${questionIndex}">Language (optional):</label>
                        <input type="text" id="q-lang-${questionIndex}" class="form-control question-lang" placeholder="e.g., python, javascript" value="${escapeHtml(lang)}">
                    </div>
                </div>
                <div class="conditional-field" data-type="attachment" style="${type === 'attachment' ? 'display: block;' : ''}">
                     <div class="form-group">
                        <label for="q-types-${questionIndex}">Allowed Types (comma-separated MIME types, optional):</label>
                        <input type="text" id="q-types-${questionIndex}" class="form-control question-allowed-types" placeholder="e.g., application/pdf,image/jpeg" value="${escapeHtml(allowedTypes)}">
                     </div>
                     <div class="form-group">
                        <label for="q-size-${questionIndex}">Max Size (MB, optional):</label>
                        <input type="number" id="q-size-${questionIndex}" class="form-control question-max-size" min="1" value="${escapeHtml(maxSize)}">
                     </div>
                </div>
                <div class="conditional-field" data-type="multiple_select" style="${type === 'multiple_select' ? 'display: block;' : ''}">
                     <div class="form-group">
                        <label for="q-options-${questionIndex}">Options (Enter ONE option per line):</label>
                        <textarea id="q-options-${questionIndex}" class="form-control question-options" rows="4" placeholder="Option A\nOption B\nOption C">${escapeHtml(options)}</textarea>
                     </div>
                     <div class="form-group">
                        <label for="q-correct-${questionIndex}">Correct Answer(s) (Enter EXACT text of correct option(s), one per line):</label>
                        <textarea id="q-correct-${questionIndex}" class="form-control question-correct" rows="2" placeholder="Option B">${escapeHtml(correct)}</textarea>
                        <small style="font-size: 0.8em; color: #555;">Enter each correct answer on a new line.</small>
                     </div>
                </div>
                `;
            questionsBuilderDiv.appendChild(block);
        }

        function handleQuestionTypeChange(event) {
             // Show/hide conditional fields when the question type dropdown changes
             if (!event.target.classList.contains('question-type-select')) return;

             const block = event.target.closest('.question-block');
             if (!block) return;
             const selectedType = event.target.value;

             // Hide all conditional fields within this block first
             block.querySelectorAll('.conditional-field').forEach(field => field.style.display = 'none');

             // Show the relevant conditional field based on the selected type
             const conditionalField = block.querySelector(`.conditional-field[data-type="${selectedType}"]`);
             if (conditionalField) {
                 conditionalField.style.display = 'block';
             }
         }

         function handleRemoveQuestion(event) {
             // Remove a question block when its 'x' button is clicked
             if (!event.target.classList.contains('remove-question-btn')) return;
             const block = event.target.closest('.question-block');
             if (block) {
                 block.remove(); // Remove the block from the DOM
                 // Re-number the remaining questions for display consistency
                 questionsBuilderDiv.querySelectorAll('.question-block').forEach((qBlock, index) => {
                     const headerSpan = qBlock.querySelector('.question-block-header span');
                     if (headerSpan) headerSpan.textContent = `Question ${index + 1}`;
                 });
                  // If no questions are left, show the placeholder message
                 if (questionsBuilderDiv.children.length === 0) {
                      questionsBuilderDiv.innerHTML = '<p style="text-align: center; color: #777;">No questions added yet.</p>';
                 }
             }
         }

        async function handleSaveExam() {
            // Triggered by the "Save Exam" / "Save Changes" button in the exam dialog
            // Note: Changed from form submit to button click to prevent default form submission

            if (!isAdminAllowed || !isOnline) return;

            // Basic validation for main exam details
            if (!examPinInput.value || !examCodeInput.value || !examNameInput.value || !examDurationInput.value || !examStartDateInput.value || !examStartTimeInput.value || !examModeInput.value) {
                showImprovedNotification('warning', 'Missing Fields', 'Please fill all required exam details (PIN, Code, Name, Duration, Date, Time, Mode).');
                return;
            }

            // --- Collect Questions from Builder ---
            const questionsArray = [];
            const questionBlocks = questionsBuilderDiv.querySelectorAll('.question-block');
            let questionsValid = true; // Flag to track validation status

            questionBlocks.forEach((block, index) => {
                const qNum = index + 1;
                const typeSelect = block.querySelector('.question-type-select');
                const promptInput = block.querySelector('.question-prompt');
                const type = typeSelect.value;
                const prompt = promptInput.value.trim();

                // Reset previous error styling
                promptInput.style.borderColor = '';
                block.querySelectorAll('.question-options, .question-correct').forEach(el => el.style.borderColor = '');

                // Validate prompt
                if (!prompt) {
                    questionsValid = false;
                    promptInput.style.borderColor = 'red'; // Highlight missing prompt
                    showImprovedNotification('warning', `Validation Error (Q${qNum})`, 'Question prompt cannot be empty.');
                }

                const question = { type, prompt };

                // --- Handle type-specific fields and validation ---
                if (type === 'code') {
                    const lang = block.querySelector('.question-lang').value.trim();
                    if (lang) question.language = lang;
                } else if (type === 'attachment') {
                   const typesStr = block.querySelector('.question-allowed-types').value.trim();
                   const sizeStr = block.querySelector('.question-max-size').value.trim();
                   if (typesStr) question.allowed_types = typesStr.split(',').map(t => t.trim()).filter(t => t); // Split, trim, filter empty
                   if (sizeStr) {
                       const sizeNum = parseInt(sizeStr, 10);
                       if (!isNaN(sizeNum) && sizeNum > 0) question.max_size_mb = sizeNum;
                       else if (sizeStr) { // If non-empty but invalid number
                           questionsValid = false;
                           block.querySelector('.question-max-size').style.borderColor = 'red';
                           showImprovedNotification('warning', `Validation Error (Q${qNum})`, 'Max size must be a positive number.');
                       }
                   }
                } else if (type === 'multiple_select') {
                   const optionsInput = block.querySelector('.question-options');
                   const correctInput = block.querySelector('.question-correct');
                   const optionsStr = optionsInput.value.trim();
                   const correctStr = correctInput.value.trim();

                   // Validate options
                   if (!optionsStr) {
                       questionsValid = false;
                       optionsInput.style.borderColor = 'red';
                       showImprovedNotification('warning', `Validation Error (Q${qNum})`, 'Multiple choice options cannot be empty.');
                   } else {
                       question.options = optionsStr.split('\n').map(opt => opt.trim()).filter(opt => opt); // Split by newline, trim, filter empty
                       if (question.options.length < 2) { // Need at least 2 options
                            questionsValid = false;
                            optionsInput.style.borderColor = 'red';
                            showImprovedNotification('warning', `Validation Error (Q${qNum})`, 'Multiple choice needs at least two distinct options.');
                       }
                   }
                   // Validate correct answers
                   if (!correctStr) {
                       questionsValid = false;
                       correctInput.style.borderColor = 'red';
                       showImprovedNotification('warning', `Validation Error (Q${qNum})`, 'Correct answer(s) cannot be empty for multiple choice.');
                   } else {
                       question.correct_answers = correctStr.split('\n').map(ans => ans.trim()).filter(ans => ans); // Split by newline, trim, filter empty
                       if (question.correct_answers.length === 0) {
                           questionsValid = false;
                           correctInput.style.borderColor = 'red';
                           showImprovedNotification('warning', `Validation Error (Q${qNum})`, 'At least one correct answer must be specified.');
                       }
                       // Validate that correct answers exist in the options list
                       if (question.options && question.correct_answers.length > 0) {
                           const allCorrectExist = question.correct_answers.every(ans => question.options.includes(ans));
                           if (!allCorrectExist) {
                               questionsValid = false;
                               correctInput.style.borderColor = 'red';
                               showImprovedNotification('warning', `Validation Error (Q${qNum})`, 'One or more correct answers do not match the provided options.');
                           }
                       }
                   }
                }
                // --- End type-specific fields ---

                if (questionsValid) { // Only add if valid *so far* for this specific question
                   questionsArray.push(question);
                }
            }); // End loop through question blocks
            // --- End Collecting Questions ---

            // If any validation failed during the loop, stop now.
            if (!questionsValid) {
                showImprovedNotification('error', 'Validation Failed', 'Please check the highlighted fields in the questions builder.');
                return;
            }

            // If all questions are valid, proceed to save
            const questionsJsonString = JSON.stringify(questionsArray); // Convert questions array to JSON string

            // Prepare the row data for the spreadsheet
            const examData = [
                examPinInput.value.trim(), examCodeInput.value.trim(), examNameInput.value.trim(),
                examDurationInput.value, examStartDateInput.value, examStartTimeInput.value, // Use HH:MM time
                examModeInput.value, questionsJsonString
            ];

            // Disable button, show loading state
            saveExamDialogBtn.disabled = true;
            saveExamDialogBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
            let success = false;
            const originalIndexStr = examRowIndexInput.value; // Get the stored original index (0-based)

            if (originalIndexStr !== '') { // EDIT operation
                const sheetRowToUpdate = parseInt(originalIndexStr, 10) + 2; // Calculate 1-based sheet row
                const rangeToUpdate = `${EXAM_DETAILS_SHEET_NAME}!A${sheetRowToUpdate}:H${sheetRowToUpdate}`;
                console.log("UPDATING exam on sheet row:", sheetRowToUpdate, "Range:", rangeToUpdate);
                success = await updateSheetData(EXAM_SPREADSHEET_ID, rangeToUpdate, [examData]);
            } else { // ADD operation
                console.log("ADDING new exam:", examData);
                success = await appendSheetData(EXAM_SPREADSHEET_ID, EXAM_DETAILS_SHEET_NAME, [examData]);
            }

            // Re-enable button, restore text
            saveExamDialogBtn.disabled = !isOnline || !isAdminAllowed; // Disable only if offline/not admin
            saveExamDialogBtn.innerHTML = originalIndexStr ? 'Save Changes' : 'Add Exam';

            if (success) {
                showImprovedNotification('success', 'Exam Saved', `Exam "${escapeHtml(examData[2])}" was ${originalIndexStr ? 'updated' : 'added'} successfully.`);
                closeExamDialog(); // Close dialog on success
                loadExamsData(); // Refresh table to show changes/new exam
            }
            // Error notification is handled within updateSheetData/appendSheetData
       }


        // === Action Button Handlers ===
        function handleExamsTableActions(event) {
             // Handles clicks on buttons within the exams table body (Edit, Delete)
             const target = event.target.closest('button'); // Find the clicked button
             if (!target) return; // Exit if click wasn't on a button
             const row = target.closest('tr'); // Find the table row containing the button
             if (!row) return; // Exit if row not found

             // Get data stored in the row's attributes
             const originalIndex = row.dataset.originalIndex; // 0-based index
             const sheetRow = row.dataset.sheetRow; // 1-based sheet row number
             const pin = row.dataset.pin;

             if (target.classList.contains('edit-exam-btn')) {
                 // Pass originalIndex to editExam for potentially fetching specific data if needed
                 editExam(pin, parseInt(originalIndex, 10));
             } else if (target.classList.contains('delete-exam-btn')) {
                 // Pass 1-based sheetRow to deleteExam for clearing the correct row
                 deleteExam(pin, parseInt(sheetRow, 10));
             }
             // Note: View Questions button has its own onclick handler in populateExamsTable
         }

        function handleAttemptsTableActions(event) {
            // Handles clicks on buttons within the attempts table body (Grade, Delete, View...)
            const target = event.target.closest('button');
            if (!target) return;
            const row = target.closest('tr');
            if (!row) return;

            const sheetRow = row.dataset.sheetRow; // 1-based sheet row
            const key = row.dataset.key; // Unique key (timestamp-email-pin)

            if (target.classList.contains('delete-attempt-btn')) {
                deleteAttempt(key, parseInt(sheetRow, 10));
            } else if (target.classList.contains('grade-attempt-btn')) {
                console.log(`Opening grading dialog for sheet row ${sheetRow}`);
                openGradingDialog(row); // Pass the whole row element
            }
            // Note: View Answers/Fingerprint buttons have their own onclick handlers
        }

        async function editExam(pin, originalIndex) {
            // Populates the exam dialog for editing an existing exam
            if (!isAdminAllowed) return;
            console.log(`Editing exam with PIN: ${pin}, Original Index: ${originalIndex}`);

            // Find the exam data in our cached `allExamsData` using the originalIndex
            const examItem = allExamsData.find(item => item.originalIndex === originalIndex);

            if (!examItem) {
                showImprovedNotification('error', 'Edit Error', `Could not find data for exam at index ${originalIndex}. Please refresh.`);
                // Optionally, try fetching the specific row from the sheet as a fallback
                // const sheetRowToFetch = originalIndex + 2;
                // ... fetch logic ...
                return;
            }

            const examData = examItem.data; // The array of row values
            const sheetRowNumber = originalIndex + 2; // Calculate 1-based sheet row for reference if needed

            // Set dialog title and button text for editing mode
            examDialogTitle.textContent = `Edit Exam (PIN: ${escapeHtml(examData[0])})`;
            saveExamDialogBtn.textContent = "Save Changes";
            examRowIndexInput.value = originalIndex; // Store 0-based index for the save handler

            // Populate the main form fields
            examPinInput.value = examData[0] || '';
            examCodeInput.value = examData[1] || '';
            examNameInput.value = examData[2] || '';
            examDurationInput.value = examData[3] || '';
            examStartDateInput.value = examData[4] || '';
            examStartTimeInput.value = examData[5] || ''; // Assumes HH:MM format stored
            examModeInput.value = examData[6] || 'Quiz'; // Default to Quiz if empty

            // --- FIX: Correctly Parse and Populate Questions ---
            questionsBuilderDiv.innerHTML = ''; // Clear existing questions first
            const questionsRaw = examData[7] || '[]';
            try {
                const questions = JSON.parse(questionsRaw);
                if (Array.isArray(questions) && questions.length > 0) {
                    questions.forEach(question => {
                        // Call addQuestionBlock, passing the question data to pre-fill the block
                        addQuestionBlock(question);
                    });
                } else if (questions.length === 0) {
                     questionsBuilderDiv.innerHTML = '<p style="text-align: center; color: #777;">No questions defined for this exam.</p>';
                } else {
                    throw new Error("Parsed questions data is not an array.");
                }
            } catch (e) {
                console.error("Error parsing or populating questions JSON during edit:", e);
                questionsBuilderDiv.innerHTML = `<p style="color: red; text-align: center;">Error loading questions: ${e.message}</p>`;
                showImprovedNotification('error', 'Question Load Error', `Could not parse questions for editing: ${e.message}`);
            }
            // --- End Fix ---

            saveExamDialogBtn.disabled = !isOnline || !isAdminAllowed; // Ensure button state is correct
            examDialogBackdrop.classList.add('visible'); // Show the dialog
        }

        async function deleteExam(pin, sheetRow) {
            // Deletes (clears) an exam row from the sheet
            if (!isAdminAllowed) return;

            if (confirm(`Are you sure you want to delete Exam with PIN: ${pin} (Row ${sheetRow})?\nThis action only clears the row content, it doesn't remove the row itself.`)) {
                console.log(`Attempting to clear exam row ${sheetRow}`);
                 // Clear data from Column A to H (or further if needed) for the specified row
                const success = await clearSheetRows(EXAM_SPREADSHEET_ID, EXAM_DETAILS_SHEET_NAME, sheetRow - 1, 1); // clearSheetRows takes 0-based index

                if (success) {
                    showImprovedNotification('success', 'Exam Cleared', `Exam content for PIN ${pin} (Row ${sheetRow}) has been cleared.`);
                    loadExamsData(); // Refresh the table to reflect the change
                }
                 // Error notification handled by clearSheetRows
            }
        }

        async function deleteAttempt(key, sheetRow) {
             // Deletes (clears) an attempt row from the sheet
             if (!isAdminAllowed) return;

             if (confirm(`Are you sure you want to delete this attempt (Row ${sheetRow})?\nThis action only clears the row content.`)) {
                 console.log(`Attempting to clear attempt row ${sheetRow}`);
                  // Clear data from Column A to J (or further if needed)
                 const success = await clearSheetRows(EXAM_SPREADSHEET_ID, EXAM_ATTEMPTS_SHEET_NAME, sheetRow - 1, 1); // Takes 0-based index

                 if (success) {
                     showImprovedNotification('success', 'Attempt Cleared', `Submission content for row ${sheetRow} has been cleared.`);
                     loadAttemptsData(); // Refresh the attempts table
                 }
                 // Error notification handled by clearSheetRows
             }
         }

        // === Content Popup Functions ===
        function showAnswersPopup(rowElement) {
             // FIX: Parse directly from attribute value
             const answersRaw = rowElement.dataset.answers || '{}';
             const formattedContent = formatJsonForDisplay(answersRaw); // formatJsonForDisplay now handles parsing
             showContentPopup('Student Answers', formattedContent); // Pass formatted HTML directly
         }

        function showFingerprintPopup(rowElement) {
             // FIX: Parse directly from attribute value
             const fingerprintRaw = rowElement.dataset.fingerprint || '{}';
             const formattedContent = formatJsonForDisplay(fingerprintRaw); // formatJsonForDisplay now handles parsing
             showContentPopup('Submission Fingerprint', formattedContent); // Pass formatted HTML directly
         }

        function showQuestionsPopup(rowElement) {
             // Shows exam questions in the popup
             const questionsRaw = rowElement.dataset.questions || '[]';
             const formattedContent = formatQuestionsForDisplay(questionsRaw); // Use the dedicated function
             showContentPopup('Exam Questions', formattedContent); // Pass formatted HTML
        }

        function showContentPopup(title, contentHtml) {
             // Generic function to display content in the popup
             contentPopupTitle.textContent = title;
             contentPopupContent.innerHTML = contentHtml; // Set innerHTML with pre-formatted content
             contentPopupBackdrop.classList.add('visible'); // Show the popup
         }

        function closeContentPopup() {
             contentPopupBackdrop.classList.remove('visible');
             contentPopupContent.innerHTML = ''; // Clear content
             contentPopupTitle.textContent = 'Content Details'; // Reset title
         }


        // === Grading Functions ===
        async function openGradingDialog(rowElement) {
            // Opens the grading dialog and loads relevant data
            if (!isAdminAllowed) return;

            try {
                currentGradeSheetRow = parseInt(rowElement.dataset.sheetRow, 10); // Store 1-based sheet row

                // Get student/exam info directly from row data attributes
                const studentName = rowElement.dataset.name || 'N/A';
                const studentEmail = rowElement.dataset.email || 'N/A';
                const examPin = rowElement.dataset.pin || 'N/A';
                const timestamp = rowElement.dataset.timestamp || 'N/A';
                const answersRaw = rowElement.dataset.answers || '{}';
                const gradesRaw = rowElement.dataset.grades || '{}'; // Get existing grades

                // Show dialog and populate basic info
                gradingDialogTitle.textContent = `Grade Submission (Row ${currentGradeSheetRow})`;
                gradingStudentName.textContent = studentName;
                gradingStudentEmail.textContent = studentEmail;
                gradingExamPin.textContent = examPin;
                gradingTimestamp.textContent = timestamp;
                gradingQuestionsContainer.innerHTML = '<p style="text-align: center;"><i class="fas fa-spinner fa-spin"></i> Loading exam details...</p>'; // Show loading state
                gradingFeedbackInput.value = ''; // Clear feedback
                gradingTotalScoreInput.value = ''; // Clear score
                gradingMaxScoreSpan.textContent = '0';
                gradingPercentageSpan.textContent = '0%';
                gradingDialogBackdrop.classList.add('visible'); // Show backdrop early

                // --- Data Loading ---
                // 1. Parse student answers
                currentSubmissionAnswers = {}; // Reset
                try {
                    currentSubmissionAnswers = JSON.parse(answersRaw);
                } catch (e) {
                     console.error(`Error parsing student answers JSON for row ${currentGradeSheetRow}:`, answersRaw, e);
                     showImprovedNotification('error', 'Answer Parse Error', `Could not parse student answers: ${e.message}`);
                     gradingQuestionsContainer.innerHTML = '<p style="text-align: center; color: red;">Error parsing student answers.</p>';
                     // Optionally disable save button here?
                     return; // Stop if answers can't be parsed
                }

                // 2. Fetch corresponding exam details (including questions)
                const examDetails = await findExamDetailsByPin(examPin);
                if (!examDetails) {
                    gradingQuestionsContainer.innerHTML = `<p style="text-align: center; color: red;">Error: Could not find exam details for PIN: ${examPin}</p>`;
                    return; // Stop if exam details not found
                }
                gradingExamName.textContent = examDetails.Name || 'N/A'; // Update exam name display

                // 3. Parse exam questions
                currentExamQuestions = []; // Reset
                try {
                    currentExamQuestions = JSON.parse(examDetails.Questions || '[]');
                    if (!Array.isArray(currentExamQuestions)) throw new Error("Questions data is not an array.");
                } catch (e) {
                    console.error(`Error parsing exam questions JSON for PIN ${examPin}:`, examDetails.Questions, e);
                    showImprovedNotification('error', 'Question Parse Error', `Could not parse exam questions: ${e.message}`);
                    gradingQuestionsContainer.innerHTML = '<p style="text-align: center; color: red;">Error parsing exam questions.</p>';
                    return; // Stop if questions can't be parsed
                }

                // 4. Calculate Max Score
                const totalPoints = calculateTotalPoints(currentExamQuestions);
                gradingMaxScoreSpan.textContent = totalPoints;

                // 5. Populate the questions area in the dialog
                populateGradingQuestions();

                // 6. Load existing grades (if any)
                loadExistingGrades(gradesRaw);


            } catch (error) {
                console.error("Error in openGradingDialog:", error);
                showImprovedNotification('error', 'Error', 'Failed to open grading dialog: ' + error.message);
                closeGradingDialog(); // Close dialog on error
            }
        }

        async function findExamDetailsByPin(pin) {
            // Helper to find exam details from cache or fetch if necessary
            if (allExamsData.length === 0) {
                console.log("Exam data cache empty, fetching...");
                await loadExamsData(); // Load exams if cache is empty
            }
            const examItem = allExamsData.find(item => item.data[0] === pin); // Find by PIN (index 0)

            if (examItem) {
                 // Return object with named properties for easier access
                 const data = examItem.data;
                 return {
                     PIN: data[0], Code: data[1], Name: data[2], Duration: data[3],
                     StartDate: data[4], StartTime: data[5], Mode: data[6], Questions: data[7]
                 };
            }
            console.warn(`Exam details not found in cache for PIN: ${pin}`);
            return null; // Not found
        }

        function closeGradingDialog() {
            gradingDialogBackdrop.classList.remove('visible');
            // Clear state variables to prevent data leakage
            currentGradingData = null;
            currentExamQuestions = null;
            currentSubmissionAnswers = null;
            currentGradeSheetRow = null;
            // Optionally clear form fields again
            gradingQuestionsContainer.innerHTML = '<p style="text-align: center; color: #777;">Loading questions and answers...</p>';
            gradingFeedbackInput.value = '';
            gradingTotalScoreInput.value = '';
        }

        function calculateTotalPoints(questions) {
             // Calculates the maximum possible score based on questions
             // Assuming 1 point per question for simplicity, adjust if points vary
             return questions.reduce((sum, q) => sum + (q.points || 1), 0);
        }

        function populateGradingQuestions() {
             // Renders the questions, student answers, and grading controls in the dialog
             if (!currentExamQuestions || !currentSubmissionAnswers) {
                 gradingQuestionsContainer.innerHTML = '<p style="text-align: center; color: red;">Error: Missing questions or answers data.</p>';
                 return;
             }
             if (currentExamQuestions.length === 0) {
                  gradingQuestionsContainer.innerHTML = '<p style="text-align: center; color: #777;">No questions found for this exam.</p>';
                 return;
             }

             let html = '';
             currentExamQuestions.forEach((question, index) => {
                 const questionNumber = index + 1;
                 const maxPoints = question.points || 1; // Default to 1 point
                 const answerId = `ans-${questionNumber}`;
                 const studentAnswer = currentSubmissionAnswers[answerId] ?? ''; // Use nullish coalescing
                 const canAutoGrade = question.type === 'multiple_select' && question.correct_answers && question.correct_answers.length > 0;

                 html += `
                     <div class="question-grading-card ungraded" id="grading-q-${questionNumber}" data-question-index="${index}">
                         <div class="question-grading-main">
                             <div class="question-prompt">Question ${questionNumber}: ${escapeHtml(question.prompt)}</div>
                             <div class="student-answer">
                                 <strong>Student Answer:</strong>
                                 <div>${formatStudentAnswer(studentAnswer, question.type)}</div>
                             </div>`;
                 // Conditionally add correct answer section
                 if (canAutoGrade) {
                     html += `
                         <div class="correct-answer">
                             <strong>Correct Answer(s):</strong>
                             <div>${formatCorrectAnswer(question)}</div>
                         </div>`;
                 }
                 html += `</div> {/* End question-grading-main */}
                         <div class="question-grading-controls">
                              <div class="question-points">
                                 <label for="points-q-${questionNumber}">Points:</label>
                                 <input type="number" class="form-control" id="points-q-${questionNumber}"
                                        min="0" max="${maxPoints}" value="0" step="0.1" onchange="updateTotalScore()"> {/* Added onchange */}
                                 <span>/ ${maxPoints}</span>`;
                 if (canAutoGrade) {
                     html += `<span class="auto-graded-label">Auto</span>`;
                 }
                 html += `</div> {/* End question-points */}
                             <div class="grading-button-group">
                                 <button type="button" class="btn-sm btn-success" onclick="markCorrect(${questionNumber}, ${maxPoints})">
                                     <i class="fas fa-check"></i> Full
                                 </button>
                                 <button type="button" class="btn-sm btn-danger" onclick="markIncorrect(${questionNumber})">
                                     <i class="fas fa-times"></i> Zero
                                 </button>`;
                 if (canAutoGrade) {
                     html += `
                         <button type="button" class="btn-sm btn-info" onclick="autoGradeQuestion(${questionNumber}, ${maxPoints})">
                             <i class="fas fa-magic"></i> Auto
                         </button>`;
                 }
                  html += `</div> {/* End grading-button-group */}
                         </div> {/* End question-grading-controls */}
                     </div> {/* End question-grading-card */}
                 `;
             });
             gradingQuestionsContainer.innerHTML = html;
             updateTotalScore(); // Calculate initial total score based on default values (usually 0)
         }

        function loadExistingGrades(gradesRaw) {
            // Parses existing grades JSON and updates the UI
            if (!gradesRaw || gradesRaw === '{}') {
                console.log("No existing grades found.");
                return; // No grades to load
            }
            try {
                const grades = JSON.parse(gradesRaw);
                console.log("Loading existing grades:", grades);

                // Populate total score and feedback
                gradingTotalScoreInput.value = grades.totalScore ?? 0;
                gradingFeedbackInput.value = grades.feedback ?? '';

                // Populate individual question points and card status
                if (grades.questionGrades) {
                    for (const qId in grades.questionGrades) {
                        if (qId.startsWith('q-')) {
                            const qNum = parseInt(qId.substring(2), 10);
                            const pointsInput = document.getElementById(`points-q-${qNum}`);
                            const card = document.getElementById(`grading-q-${qNum}`);
                            const qGrade = grades.questionGrades[qId];

                            if (pointsInput) pointsInput.value = qGrade.points ?? 0;
                            if (card && qGrade.status) {
                                card.className = `question-grading-card ${qGrade.status}`; // Set card class based on saved status
                            }
                        }
                    }
                }
                updateGradePercentage(); // Update percentage display based on loaded score

            } catch (e) {
                console.error("Error loading existing grades JSON:", gradesRaw, e);
                showImprovedNotification('warning', 'Grade Load Warning', `Could not load previously saved grades: ${e.message}`);
            }
        }

        function formatStudentAnswer(answer, questionType) {
            if (answer === null || typeof answer === 'undefined' || answer === '') return '<em>No answer provided</em>';
            const escapedAnswer = escapeHtml(String(answer));

            switch (questionType) {
                case 'code':
                    return `<pre>${escapedAnswer}</pre>`;
                case 'attachment':
                    if (String(answer).startsWith('FILE_UPLOADED:')) {
                        const filename = String(answer).replace('FILE_UPLOADED:', '');
                        return `<em>File uploaded:</em> ${escapeHtml(filename)}`;
                    }
                    return `<em>${escapedAnswer}</em>`; // Display raw value if not expected format
                case 'long_answer':
                     return escapedAnswer.replace(/\n/g, '<br>'); // Preserve line breaks
                case 'short_answer':
                case 'multiple_select':
                default:
                    return escapedAnswer;
            }
        }

        function formatCorrectAnswer(question) {
            // Displays the defined correct answer(s) for auto-gradable questions
            if (question.type === 'multiple_select' && Array.isArray(question.correct_answers)) {
                return question.correct_answers.map(ans => escapeHtml(ans)).join('<br>'); // Display each on new line if multiple
            }
            return '<em>(Manual grading)</em>'; // Placeholder for non-auto-gradable types
        }

        function markCorrect(questionNumber, maxPoints = 1) {
             // Sets points to max and updates card style to 'correct'
             const pointsInput = document.getElementById(`points-q-${questionNumber}`);
             const card = document.getElementById(`grading-q-${questionNumber}`);
             if (pointsInput) pointsInput.value = maxPoints;
             if (card) card.className = 'question-grading-card correct';
             updateTotalScore(); // Recalculate total score
         }

        function markIncorrect(questionNumber) {
             // Sets points to 0 and updates card style to 'incorrect'
             const pointsInput = document.getElementById(`points-q-${questionNumber}`);
             const card = document.getElementById(`grading-q-${questionNumber}`);
             if (pointsInput) pointsInput.value = 0;
             if (card) card.className = 'question-grading-card incorrect';
             updateTotalScore(); // Recalculate total score
         }

        function autoGradeQuestion(questionNumber, maxPoints = 1) {
             // Automatically grades a single multiple-choice question
             const questionIndex = questionNumber - 1;
             if (!currentExamQuestions || !currentSubmissionAnswers || questionIndex < 0 || questionIndex >= currentExamQuestions.length) return;

             const question = currentExamQuestions[questionIndex];
             const answerId = `ans-${questionNumber}`;
             const studentAnswer = currentSubmissionAnswers[answerId] ?? '';

             // Check if auto-gradable
             if (question.type !== 'multiple_select' || !Array.isArray(question.correct_answers) || question.correct_answers.length === 0) {
                 showImprovedNotification('warning', 'Auto-grade Error', `Question ${questionNumber} is not an auto-gradable multiple-choice question.`);
                 return;
             }

             // Compare student answer with correct answers
             const isCorrect = question.correct_answers.includes(String(studentAnswer)); // Ensure comparison is string-based

             if (isCorrect) {
                 markCorrect(questionNumber, maxPoints);
             } else {
                 markIncorrect(questionNumber);
             }
             // updateTotalScore is called by markCorrect/markIncorrect
         }

        function runAutograder() {
             // Runs auto-grading logic on all applicable questions in the dialog
             if (!currentExamQuestions) return;
             let autoGradedCount = 0;
             currentExamQuestions.forEach((question, index) => {
                 const questionNumber = index + 1;
                 const maxPoints = question.points || 1;
                 // Check if it's auto-gradable
                 if (question.type === 'multiple_select' && Array.isArray(question.correct_answers) && question.correct_answers.length > 0) {
                     autoGradeQuestion(questionNumber, maxPoints);
                     autoGradedCount++;
                 }
             });
             // updateTotalScore is called within autoGradeQuestion -> markCorrect/Incorrect
             showImprovedNotification('info', 'Auto-grading Complete', `Attempted to auto-grade ${autoGradedCount} multiple-choice question(s). Please review and grade others manually.`);
         }

        function updateTotalScore() {
             // Calculates and updates the total score display based on individual question points
             if (!currentExamQuestions) return;
             const maxPossibleScore = calculateTotalPoints(currentExamQuestions);
             let currentTotalScore = 0;

             currentExamQuestions.forEach((q, index) => {
                 const qNum = index + 1;
                 const pointsInput = document.getElementById(`points-q-${qNum}`);
                 if (pointsInput) {
                     currentTotalScore += parseFloat(pointsInput.value) || 0;
                 }
             });

             gradingTotalScoreInput.value = currentTotalScore.toFixed(1); // Allow decimals
             updateGradePercentage(); // Update the percentage display
         }

        function updateGradePercentage() {
             // Updates the percentage display based on current total and max score
             const totalScore = parseFloat(gradingTotalScoreInput.value) || 0;
             const maxScore = parseFloat(gradingMaxScoreSpan.textContent) || 0; // Use float here too

             let percentage = 0;
             if (maxScore > 0) {
                 percentage = (totalScore / maxScore) * 100;
             }
             gradingPercentageSpan.textContent = `${percentage.toFixed(1)}%`; // Show one decimal place
         }

        async function saveGrades() {
            // Collects all grading data and saves it to the spreadsheet
            if (!currentGradeSheetRow || !currentExamQuestions) {
                showImprovedNotification('error', 'Save Error', 'Missing data required for saving grades (Sheet Row or Exam Questions).');
                return;
            }

            // Disable button, show loading
            saveGradingDialogBtn.disabled = true;
            saveGradingDialogBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';

            // Collect overall score and feedback
            const totalScore = parseFloat(gradingTotalScoreInput.value) || 0;
            const maxScore = parseFloat(gradingMaxScoreSpan.textContent) || 0;
            const percentage = gradingPercentageSpan.textContent || '0%'; // Get displayed percentage
            const feedback = gradingFeedbackInput.value.trim();

            // Collect individual question grades and statuses
            const questionGrades = {};
            let allGraded = true; // Track if all questions have a status
            currentExamQuestions.forEach((q, index) => {
                const qNum = index + 1;
                const pointsInput = document.getElementById(`points-q-${qNum}`);
                const card = document.getElementById(`grading-q-${qNum}`);
                let status = 'ungraded'; // Default status

                if (card) {
                    if (card.classList.contains('correct')) status = 'correct';
                    else if (card.classList.contains('incorrect')) status = 'incorrect';
                    else if (card.classList.contains('partial')) status = 'partial'; // Added partial state if needed
                }
                if (status === 'ungraded') allGraded = false;

                questionGrades[`q-${qNum}`] = {
                    points: parseFloat(pointsInput?.value || 0), // Get points, default 0
                    status: status
                };
            });

            // Prepare the grade data object
            const gradeData = {
                totalScore: totalScore.toFixed(1), // Store with one decimal
                maxScore: maxScore,
                percentage: percentage,
                feedback: feedback,
                gradedAt: new Date().toISOString(), // Timestamp of grading
                gradedBy: currentUser?.email || 'Unknown', // Admin email
                questionGrades: questionGrades // Object containing individual question grades/statuses
            };
            const gradeJson = JSON.stringify(gradeData); // Convert to JSON string

            console.log(`Saving grades for row ${currentGradeSheetRow}:`, gradeData);

            // Define ranges to update
            // Column J (index 9) for the full grade JSON
            const gradeRange = `${EXAM_ATTEMPTS_SHEET_NAME}!J${currentGradeSheetRow}`;
            // Column G (index 6) for the overall status ('graded' or 'submit')
            const statusRange = `${EXAM_ATTEMPTS_SHEET_NAME}!G${currentGradeSheetRow}`;
            const newStatus = allGraded ? 'graded' : 'submit'; // Mark as 'graded' only if all questions have a status

            let gradeSaveSuccess = false;
            let statusUpdateSuccess = false;
            try {
                // 1. Update the Grades column (J)
                gradeSaveSuccess = await updateSheetData(EXAM_SPREADSHEET_ID, gradeRange, [[gradeJson]]);

                if (gradeSaveSuccess) {
                    // 2. Update the Status column (G)
                    statusUpdateSuccess = await updateSheetData(EXAM_SPREADSHEET_ID, statusRange, [[newStatus]]);
                }

                if (gradeSaveSuccess && statusUpdateSuccess) {
                    showImprovedNotification('success', 'Grades Saved', `Grades saved and status updated to '${newStatus}' for row ${currentGradeSheetRow}.`);
                    closeGradingDialog();
                    loadAttemptsData(); // Refresh the table
                } else if (gradeSaveSuccess && !statusUpdateSuccess) {
                     showImprovedNotification('warning', 'Partial Save', `Grades JSON saved, but failed to update status for row ${currentGradeSheetRow}.`);
                     // Don't close dialog, allow retry? Or just refresh?
                     loadAttemptsData();
                } else {
                    // Grade save failed (error shown by updateSheetData)
                    console.error('Grade save failed.');
                }

            } catch (error) {
                // Catch unexpected errors during the process
                console.error('Error during saveGrades process:', error);
                showImprovedNotification('error', 'Save Failed', `An unexpected error occurred while saving grades: ${error.message}`);
            } finally {
                // Re-enable button regardless of outcome
                saveGradingDialogBtn.disabled = !isOnline || !isAdminAllowed;
                saveGradingDialogBtn.innerHTML = 'Save Grades';
            }
        }

    </script>

</body>
</html>