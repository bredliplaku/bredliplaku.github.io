<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"> <title>Exam Portal</title>
    <link rel="icon" type="image/png" href="https://bredliplaku.github.io/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/monokai.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/closebrackets.min.js"></script>
<style>
    /* --- CSS --- */
    :root {
        --primary-color: #3949ab;
        --primary-dark: #1a237e;
        --secondary-color: #ffa726;
        --background-color: #f4f4f4;
        --card-background: #ffffff;
        --text-color: #333333;
        --text-light: #ffffff;
        --success-color: #43a047;
        --warning-color: #fb8c00;
        --info-color: #2196F3;
        --danger-color: #f44336;
        --border-color: #e0e0e0; /* Added border color variable */
        --confirmed-bg-light: #e8f5e9; /* Light green for confirmed header/background */
        --confirmed-border-color: #7cb342; /* Darker green for border */
    }

    *, *::before, *::after {
        box-sizing: border-box;
    }

    body, html {
        margin: 0;
        padding: 0;
        font-family: 'Roboto', sans-serif;
        background: var(--background-color);
        color: var(--text-color);
        line-height: 1.6; /* Consistent line height */
    }

    .container {
        max-width: 1000px;
        margin: 20px auto; /* Centered margin */
        padding: 20px;
    }

    /* --- Loading Styles --- */
    .app-loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #f4f4f4; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; transition: opacity 0.5s ease-out; }
    .app-loading.hidden { opacity: 0; pointer-events: none; }
    .loading-spinner { border: 5px solid rgba(57, 73, 171, 0.2); border-top: 5px solid var(--primary-color); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* --- Content Visibility --- */
    .content-hidden { visibility: hidden; opacity: 0; }
    .content-visible { visibility: visible; opacity: 1; transition: opacity 0.5s ease-in; }

    /* --- App Header --- */
    .app-header {
        background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
        color: var(--text-light);
        padding: 25px 30px; /* Consistent padding */
        border-radius: 15px;
        margin-bottom: 30px; /* More space below header */
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        -webkit-user-select: none;
        -khtml-user-select: none;
    }
    .app-header h1 {
        margin: 0 0 10px 0;
        font-weight: 500; /* Slightly less bold */
        font-size: 2.0em;
        display: flex; align-items: center; gap: 10px;
    }
    .app-header h2 {
        margin: 0;
        font-weight: 400;
        font-size: 1.1em; /* Slightly larger */
        opacity: 0.9;
    }
    .app-info { display: flex; flex-wrap: wrap; margin-top: 15px; gap: 10px; }
    .info-item {
        background-color: rgba(255,255,255,0.15); /* Slightly more opaque */
        color: var(--text-light);
        padding: 8px 15px; /* Adjusted padding */
        border-radius: 20px; /* Pill shape */
        font-size: 0.9em;
        line-height: 1.5; /* Adjusted line-height */
        display: inline-flex; align-items: center; gap: 8px;
    }

    /* --- Base Module Styles --- */
    .module {
        background-color: var(--card-background);
        border-radius: 12px; /* Consistent radius */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        margin-bottom: 25px; /* Consistent margin */
        overflow: hidden; /* Needed for collapsing content */
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .module-header {
        background-color: var(--primary-color);
        color: var(--text-light);
        padding: 12px 20px; /* Adjusted padding */
        font-weight: 500;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap; /* Allow wrapping */
        gap: 10px; /* Space between items if they wrap */
        position: relative; /* For absolute positioned elements inside if needed */
        border-bottom: 1px solid rgba(0, 0, 0, 0.1); /* Subtle separator */
    }
    .module-title {
        font-size: 1.1em; display: flex; align-items: center; gap: 10px; flex-grow: 1; /* Allow title to take space */
    }
    .module-content {
        padding: 20px; /* Default padding for non-collapsing modules */
    }
    .not-signed-in-message { /* Style for sign-in prompt */
        text-align: center; padding: 30px 20px; color: #555;
    }
    .not-signed-in-message h3 { margin-top: 0; margin-bottom: 10px; color: var(--primary-dark); }
    .not-signed-in-message i { font-size: 2em; color: var(--primary-color); margin-bottom: 15px; display: block; }

    /* --- Buttons (Corrected Theming) --- */
    button {
        display: inline-flex; align-items: center; justify-content: center; gap: 8px;
        background-color: var(--primary-color); color: var(--text-light);
        padding: 10px 20px; border-radius: 20px; font-size: 0.9em; font-weight: 500; /* Added weight */
        transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s, opacity 0.2s; /* Added opacity */
        text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border: 0; cursor: pointer;
        -webkit-user-select: none; -khtml-user-select: none;
    }
    button:hover:not(:disabled) {
        background-color: var(--primary-dark); /* Default hover */
        transform: translateY(-1px); /* Subtle lift */
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    button:disabled {
        background-color: #ccc; color: #666; opacity: 0.7; cursor: not-allowed; transform: none; box-shadow: none;
    }
    /* -- Applying Correct Theme Colors to Button Classes -- */
    button.btn-green, .btn-green { /* Target both tag and class */
        background-color: var(--success-color); color: white;
    }
    button.btn-green:hover:not(:disabled), .btn-green:hover:not(:disabled) {
        background-color: #367c39; /* Darker green */
    }
    button.btn-blue, .btn-blue {
        background-color: var(--info-color); color: white;
    }
    button.btn-blue:hover:not(:disabled), .btn-blue:hover:not(:disabled) {
        background-color: #1976D2; /* Darker blue */
    }
    button.btn-orange, .btn-orange {
        background-color: var(--warning-color); color: white;
    }
    button.btn-orange:hover:not(:disabled), .btn-orange:hover:not(:disabled) {
        background-color: #e65100; /* Darker orange */
    }
    button.btn-grey, .btn-grey {
        background-color: #6c757d; color: white;
    }
    button.btn-grey:hover:not(:disabled), .btn-grey:hover:not(:disabled) {
        background-color: #5a6268; /* Darker grey */
    }
    /* Keep btn-sm as is */
    button.btn-sm, .btn-sm {
        padding: 6px 12px; font-size: 0.85em; border-radius: 15px;
    }

    /* --- Notifications (Keep as is) --- */
    .in-page-notifications { position: fixed; bottom: 20px; right: 20px; z-index: 10000; width: 350px; max-width: 90%; pointer-events: none; }
    .in-page-notification { background-color: white; border-radius: 10px; padding: 15px; margin-bottom: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); animation: slide-in 0.3s ease-out, glow 2s infinite alternate; overflow: hidden; display: flex; align-items: center; opacity: 1; transition: transform 0.3s ease-in, opacity 0.3s ease-in; pointer-events: auto; }
    .in-page-notification.removing { opacity: 0; transform: translateX(100%); }
    @keyframes slide-in { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    @keyframes glow { from { box-shadow: 0 0 5px rgba(0,0,0,0.1); } to { box-shadow: 0 0 15px rgba(0,0,0,0.2); } }
    .in-page-notification i.fa-icon { margin-right: 10px; font-size: 1.2em; flex-shrink: 0; }
    .notification-content { flex-grow: 1; }
    .notification-close { background: none; border: none; font-size: 20px; line-height: 1; color: inherit; opacity: 0.7; padding: 0 5px; margin-left: 10px; cursor: pointer; }
    .notification-close:hover { opacity: 1; }
    .in-page-notification-info { background-color: #e3f2fd; color: #0d47a1; }
    .in-page-notification-warning { background-color: #fff3e0; color: #e65100; }
    .in-page-notification-error { background-color: #ffebee; color: #b71c1c; }
    .in-page-notification-success { background-color: #e8f5e9; color: #1b5e20; }

    /* --- Forms (Keep as is) --- */
    .form-group { margin-bottom: 20px; }
    .form-group label { display: block; margin-bottom: 8px; font-weight: 500; }
    .form-control { width: 100%; padding: 12px; border: 1px solid var(--border-color, #ccc); border-radius: 8px; font-size: 1em; transition: opacity 0.3s, background-color 0.3s, color 0.3s, border-color 0.3s; background-color: #fff; color: #333; opacity: 1; }
    input:disabled, textarea:disabled { background-color: #eee; cursor: not-allowed; opacity: 0.7; }
    textarea.form-control { min-height: 100px; }
    #exam-details-display p { margin: 8px 0; }

    /* --- Footer (Keep as is) --- */
    .footer { max-width: 1000px; text-align: center; padding: 20px 0; color: var(--primary-dark); border-radius: 20px; margin: 30px auto 10px auto; font-size: 0.9em; }
    .social-links { margin-bottom: 10px; margin-top: 10px; }
    .social-links a { color: var(--primary-dark); font-size: 1.0em; margin: 0 10px; transition: color 0.3s; }
    .social-links a:hover { color: var(--secondary-color); }

    /* --- Auth/Sync (Keep as is) --- */
    .auth-container { display: flex; justify-content: flex-end; align-items: center; gap: 10px; }
    .user-info { display: flex; align-items: center; gap: 10px; }
    .user-avatar { width: 32px; height: 32px; border-radius: 50%; }
    .sync-auth-container { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; margin-bottom: 10px; border-bottom: 1px solid #eee; flex-wrap: wrap; gap: 10px; /* Allow wrap */}
    .sync-container { display: flex; align-items: center; gap: 10px; }
    .sync-status { display: flex; align-items: center; gap: 5px; font-size: 0.9em; }
    .sync-status.online i { color: var(--success-color); }
    .sync-status.offline i { color: var(--warning-color); }

    /* --- CodeMirror Styles (Keep as is) --- */
    .CodeMirror { height: auto ; min-height: 150px; border: 1px solid #ccc; border-radius: 6px; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 14px; line-height: 1.4; }
    .cm-s-monokai .cm-keyword {color: #f92672 !important;} /* !important likely needed */
    /* ... (keep all other .cm-s-monokai color overrides) ... */
	.cm-s-monokai .cm-operator {color: #f92672 !important;}
	.cm-s-monokai .cm-variable-2 {color: #9effff !important;}
	.cm-s-monokai .cm-variable-3, .cm-s-monokai .cm-type {color: #66d9ef !important;}
	.cm-s-monokai .cm-builtin {color: #a6e22e !important;}
	.cm-s-monokai .cm-atom {color: #ae81ff !important;}
	.cm-s-monokai .cm-number {color: #ae81ff !important;}
	.cm-s-monokai .cm-def {color: #fd971f !important;}
	.cm-s-monokai .cm-string {color: #e6db74 !important;}
	.cm-s-monokai .cm-comment {color: #75715e !important;}
	.cm-s-monokai .cm-variable {color: #f8f8f2 !important;}
	.cm-s-monokai .cm-tag {color: #f92672 !important;}
	.cm-s-monokai .cm-attribute {color: #a6e22e !important;}
	.cm-s-monokai .cm-property {color: #66d9ef !important;}
    .cm-confirmed { opacity: 0.7; }
    .cm-confirmed .CodeMirror-scroll { background-color: rgba(0,0,0,0.1); }
    .CodeMirror-cursor { border-left: 1px solid white !important; }
    .cm-s-monokai.CodeMirror { background: #272822 !important; color: #f8f8f2 !important; }
    .CodeMirror-linenumber { color: #75715e !important; }
    .cm-s-monokai .CodeMirror-selected { background: rgba(255,255,255,0.1) !important; }

    /* ==========================================================================
       NEW: Exam Questions as Modules (Collapsible on Confirm)
       ========================================================================== */
    #exam-questions-area {
        margin-top: 20px;
        /* Removed padding/background/border - handled by modules now */
    }

    .question-module {
        background-color: var(--card-background);
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        margin-bottom: 25px;
        overflow: hidden;
        border: 1px solid var(--border-color); /* Add subtle border */
        transition: background-color 0.3s ease, border-left 0.3s ease, border-color 0.3s ease; /* Smooth transitions */
    }

    .question-header {
        background-color: #f7f9fc; /* Lighter header for questions */
        padding: 10px 15px;
        font-weight: 500;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--border-color);
        position: relative; /* For absolute positioned badge */
        flex-wrap: wrap; /* Allow wrapping */
        gap: 10px;
        /* cursor: pointer; */ /* Remove cursor pointer - header doesn't toggle */
    }

    .question-title {
        font-size: 1.1em;
        color: var(--primary-dark);
        flex-grow: 1;
    }
    .question-title strong { font-weight: 700; }
    .points-badge {
        display: inline-block;
        background-color: var(--info-color);
        color: white;
        font-size: 0.8em;
        padding: 3px 10px;
        border-radius: 15px;
        margin-left: 8px;
        vertical-align: middle;
        font-weight: 600;
    }

    /* Content area within the question module */
    .question-content-area {
        padding: 20px; /* Default padding */
        max-height: 2500px; /* Start expanded - large max-height */
        overflow: hidden; /* Important for collapsing */
        transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out, opacity 0.4s ease-in-out;
        opacity: 1;
    }

    /* Collapsed state when .confirmed class is added */
    .question-module.confirmed .question-content-area {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        opacity: 0;
        /* overflow: hidden; */ /* Already set above */
    }

    /* Style confirmed header */
    .question-module.confirmed {
        background-color: var(--confirmed-bg-light);
        border-left: 5px solid var(--confirmed-border-color);
        border-color: var(--confirmed-border-color);
    }
     .question-module.confirmed .question-header {
        background-color: transparent; /* Or a slightly different shade */
        border-bottom-color: transparent; /* Hide border when collapsed */
     }

    /* Confirmed badge using ::after on the header */
    .question-header::after {
        content: "âœ“ CONFIRMED";
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.8em;
        background-color: var(--success-color);
        color: white;
        padding: 3px 10px;
        border-radius: 15px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        font-weight: 600;
        opacity: 0; /* Hidden by default */
        transition: opacity 0.3s ease;
        pointer-events: none;
    }
    .question-module.confirmed .question-header::after {
        opacity: 1; /* Show badge when confirmed */
    }


    .question-prompt-display {
        margin-bottom: 15px;
        line-height: 1.5;
        /* Style prompt text */
    }
     .question-prompt-display em.term {
        background-color: rgba(255, 167, 38, 0.15); padding: 2px 4px; border-radius: 3px; font-style: normal; font-weight: 500; color: #d84315;
     }
     .question-prompt-display strong { font-weight: bold; }


    .question-answer-area {
        margin-bottom: 15px; /* Space before actions */
    }

    /* --- Question Action Buttons --- */
    .question-actions {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px; /* Space above buttons */
        padding-top: 15px; /* Space */
        border-top: 1px solid var(--border-color); /* Separator */
    }
    /* Buttons use standard .btn-* classes now */
    /* Hide Edit button by default */
    .question-module:not(.confirmed) .btn-edit {
        display: none;
    }
    /* Hide Confirm button when confirmed */
    .question-module.confirmed .btn-confirm {
        display: none;
    }

    /* Keep checkbox styles */
     .checkbox-group { display: flex ; flex-wrap: wrap ; gap: 12px ; margin-top: 10px; }
     .checkbox-item { flex: 1 1 180px; margin-right: 0; margin-bottom: 8px; background-color: #f8f9fa; padding: 8px 12px; border-radius: 6px; transition: background-color 0.2s; border: 1px solid #dee2e6; display: flex; align-items: center; }
     .checkbox-item:hover { background-color: #e9ecef; border-color: #ced4da; }
     .checkbox-item input[type="radio"] { margin-right: 8px; cursor: pointer; width: 16px; height: 16px; }
     .checkbox-item input[type="radio"]:checked + label { font-weight: 500; color: var(--primary-dark); }
     .checkbox-item:has(input[type="radio"]:checked) { background-color: #e3f2fd; border-color: #90caf9; }
     .checkbox-item label { margin-bottom: 0; font-weight: normal; cursor: pointer; flex-grow: 1; transition: color 0.3s; }


    /* --- Sticky Timer (Keep as is) --- */
    .sticky-timer { position: fixed; top: 15px; left: 50%; transform: translateX(-50%); color: white; z-index: 1000; font-size: 1.1em; font-weight: 700; padding: 12px 24px; border-radius: 30px; box-shadow: 0 3px 15px rgba(0,0,0,0.15); background-color: var(--primary-color); transition: background-color 0.5s ease; }
    .sticky-timer i { font-size: 1.2em; margin-right: 8px; }
    .sticky-timer.warning { background: linear-gradient(to right, #ff9800, #f57c00); }
    .sticky-timer.danger { background: linear-gradient(to right, #f44336, #d32f2f); animation: pulse 0.8s infinite alternate; }
    .sticky-timer.expired { background: #6c757d; }
    @keyframes pulse { from { transform: translateX(-50%) scale(1); box-shadow: 0 4px 10px rgba(0,0,0,0.2); } to { transform: translateX(-50%) scale(1.03); box-shadow: 0 4px 15px rgba(211,47,47,0.4); } }

    /* --- Body Background Timer States (Keep as is) --- */
    body.time-warning { background-color: #fff8e1; transition: background-color 1s; }
    body.time-danger { background-color: #ffebee; transition: background-color 1s; }
    body.time-expired { background-color: #ffcdd2; } /* Fixed hex */

    /* --- Backup Modal (Keep as is) --- */
    .backup-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 2000; opacity: 0; visibility: hidden; transition: opacity 0.3s; }
    .backup-modal.visible { opacity: 1; visibility: visible; }
    .backup-modal-content { background-color: white; border-radius: 10px; width: 90%; max-width: 600px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); display: flex; flex-direction: column; max-height: 90vh; transform: scale(0.9); transition: transform 0.3s; }
    .backup-modal.visible .backup-modal-content { transform: scale(1); }
    .backup-modal-header { padding: 15px 20px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
    .backup-modal-header h3 { margin: 0; color: var(--primary-dark); }
    .backup-close-btn { background: none; border: none; font-size: 24px; cursor: pointer; color: #999; }
    .backup-modal-body { padding: 20px; overflow-y: auto; flex-grow: 1; }
    .backup-modal-footer { padding: 15px 20px; border-top: 1px solid #eee; display: flex; justify-content: flex-end; gap: 10px; }
    .backup-preview { margin-top: 15px; padding: 15px; background-color: #f5f5f5; border-radius: 5px; max-height: 200px; overflow-y: auto; }
    .backup-info p { margin: 5px 0; }
    .backup-error { color: var(--danger-color); }

    /* --- Misc Text Styles (Keep as is) --- */
    label.code-prompt { white-space: pre-wrap; font-family: monospace; display: block; background-color: #f8f9fa; padding: 10px; border: 1px solid #eee; border-radius: 4px; line-height: 1.4; margin-bottom: 10px; }
    label em.term, div em.term { font-style: italic; font-weight: bold; color: var(--primary-dark); }

    /* --- Submit Button (Keep as is) --- */
    #submit-exam-btn { margin-top: 30px; width: 100%; font-size: 1.1em; transition: all 0.3s ease; position: relative; overflow: hidden; background: linear-gradient(to right, var(--success-color), #2e7d32); font-weight: 500; padding: 15px 30px; border-radius: 30px; box-shadow: 0 4px 12px rgba(46, 125, 50, 0.3); color: white; /* Ensure text is visible */ }
    #submit-exam-btn:hover:not(:disabled) { box-shadow: 0 6px 16px rgba(46, 125, 50, 0.4); transform: translateY(-2px); }
    #submit-exam-btn::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to right, rgba(255,255,255,0.1), transparent); transform: translateX(-100%); transition: transform 0.6s ease; }
    #submit-exam-btn:hover::after { transform: translateX(100%); }

    /* --- Utility --- */
    .hidden { display: none !important; }
    #timer-display { font-weight: bold; }
    .confirmation-message { text-align: center; font-weight: bold; color: var(--success-color); padding: 30px; font-size: 1.2em; }
    .file-helper-text { display: block; margin-top: 5px; color: #666; font-size: 0.85em; }
    .length-limit-note { display: block; margin-top: 5px; color: #757575; font-size: 0.8em; font-style: italic; }

    /* --- Responsive --- */
    @media (max-width: 768px) {
        .sync-auth-container { flex-direction: row; flex-wrap: nowrap; gap: 10px; border-bottom: 1px solid #eee; /* Restore border */ } /* Revert to row */
        .auth-container { width: auto; justify-content: flex-end;}
        .sync-container { width: auto; justify-content: flex-start; /* Align sync left */ }
        .user-info span { max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .in-page-notifications { width: 90%; left: 50%; transform: translateX(-50%); bottom: 10px; right: auto;}
        #exam-questions-area .checkbox-group { flex-direction: column; }
        #exam-questions-area .checkbox-item { width: 100%; margin-right: 0 ; flex-basis: auto; }
        .app-info { flex-direction: column; }
        .info-item { width: 100%; margin-bottom: 5px; }
        .sticky-timer { padding: 8px 16px; font-size: 1em; }
        .question-header { padding: 8px 12px;}
        .question-title { font-size: 1em;}
        .points-badge { font-size: 0.75em; padding: 2px 8px;}
        .question-header::after { /* Adjust badge position on mobile */ right: 8px; font-size: 0.75em; padding: 2px 8px;}
    }

</style>
</head>
<body class="content-hidden">
    <div id="app-loading" class="app-loading">
        <img src="https://raw.githubusercontent.com/bredliplaku/bredliplaku.github.io/refs/heads/main/loading.gif" alt="Loading..." style="width: 150px; height: 150px;">
        <div style="margin-top: 10px; font-size: 14px; color: #666;">Loading Exam Portal...</div>
    </div>
    <div class="container" id="main-container">
        <div class="sync-auth-container">
            <div class="sync-container">
                 <div id="sync-status" class="sync-status offline">
                    <i class="fas fa-circle"></i>
                    <span id="sync-text">Offline</span>
                </div>
            </div>
            <div class="auth-container">
                 <div id="login-container">
                    <button id="login-btn" class="btn-blue"> <i class="fas fa-sign-in-alt"></i> Sign in
                    </button>
                </div>
                 <div id="user-container" style="display: none">
                    <div class="user-info">
                        <img id="user-avatar" class="user-avatar" src="" alt="Avatar">
                        <span id="user-name"></span>
                         <button id="logout-btn" class="btn-sm btn-grey"> <i class="fas fa-sign-out-alt"></i>
                        </button>
                    </div>
                 </div>
            </div>
        </div>
        <div class="app-header">
             <h1><i class="fa-solid fa-clipboard-question"></i> Exam Portal</h1>
             <div class="app-info">
                 <span class="info-item">
                       <i class="fa-solid fa-table-list"></i> Course:
                     <span id="exam-code-display">N/A</span>
                 </span>
                 <span class="info-item">
                     <i class="far fa-clock "></i> Duration: <span id="exam-duration-display">N/A</span>
                 </span>
                 <span class="info-item">
                     <i class="fas fa-calendar-alt"></i> Start Time:
                     <span id="exam-start-time-display">N/A</span>
                 </span>
             </div>
        </div>
        <h2 id="exam-name-header">Enter PIN to load exam</h2>

        <div id="in-page-notification-area" class="in-page-notifications"></div>

        <div id="signin-prompt-module" class="module">
            <div class="module-content not-signed-in-message">
                 <h3><i class="fas fa-info-circle"></i> Welcome</h3>
                 <p>Sign in with your University Google Account.</p>
            </div>
        </div>
        <div id="exam-start-module" class="module hidden">
            <div class="module-header">
                <span class="module-title"> <i class="fas fa-user-check"></i> Student Details </span>
            </div>
            <div class="module-content">
                 <div class="form-group">
                     <label for="student-name">Name:</label>
                     <input type="text" id="student-name" class="form-control" disabled>
                 </div>
                 <div class="form-group">
                     <label for="student-email">Email:</label>
                     <input type="email" id="student-email" class="form-control" disabled>
                 </div>
                 <div class="form-group">
                     <label for="exam-pin-input">Exam PIN:</label>
                     <input type="text" id="exam-pin-input" class="form-control" placeholder="The lecturer will provide you with the PIN">
                 </div>
                 <div id="student-exam-id-group" class="form-group hidden">
                     <label for="student-exam-id-input">Student Exam ID (Confidential - 5 characters):</label>
                     <input type="text" id="student-exam-id-input" class="form-control" placeholder="Enter your Exam ID from the attendance sheet" maxlength="5">
                 </div>
                 <button id="load-exam-btn" class="btn-info" disabled> <i class="fas fa-download"></i> Load Exam
                 </button>
                 <button id="start-exam-btn-alt" class="btn-success hidden" disabled> <i class="fas fa-play"></i> Start Exam
                 </button>
             </div>
        </div>
        <div id="exam-details-module" class="module hidden">
            <div class="module-header">
                <span class="module-title"> <i class="fas fa-info-circle"></i> Exam Information </span>
            </div>
            <div class="module-content" id="exam-details-display">
                 <p> <strong>Exam Name:</strong> <span id="exam-name-detail"></span> </p>
                  <p> <strong>Course Code:</strong> <span id="exam-course-code-detail"></span> </p>
                  <p> <strong>Mode:</strong> <span id="exam-mode-detail"></span> </p>
                  <p> <strong>Duration:</strong> <span id="exam-duration-detail"></span> </p>
                  <p> <strong>Start Time:</strong> <span id="exam-start-time-detail"></span> </p>
                  <button id="start-exam-btn" class="btn-success" disabled> <i class="fas fa-play"></i> Start Exam
                 </button>
            </div>
        </div>
        <form id="exam-form">
            <div id="exam-questions-area">
                <p>Loading questions...</p>
            </div>
            <button type="button" id="submit-exam-btn" class="btn-success" disabled> <i class="fas fa-check-circle"></i> Submit Exam
            </button>
        </form>

        <div id="submission-confirmation-module" class="module hidden">
             <div class="module-content confirmation-message">
                 <i class="fas fa-check-circle fa-3x" style="color: var(--success-color); margin-bottom: 15px;"></i><br>
                 Exam Submitted Successfully!
            </div>
        </div>
        <footer class="footer">
             <div class="social-links">
                 <a href="https://eis.epoka.edu.al/cv/fullcv/655" target="_blank" rel="noopener noreferrer"><i class="far fa-id-card"></i></a>
                 <a href="mailto:bplaku@epoka.edu.al" target="_blank" rel="noopener noreferrer"><i class="far fa-envelope"></i></a>
             </div>
              <p style="font-size:0.7em"><i class="far fa-copyright"></i> 2023-<span id="currentYear"></span> Bredli Plaku. All Rights Reserved.</p>
        </footer>
    </div> 
	// === Configuration ===
const ADMIN_EMAILS = ['bplaku@epoka.edu.al'];
const CLIENT_ID = '740588046540-npg0crodtcuinveu6bua9rd6c3hb2s1m.apps.googleusercontent.com'; // Keep for sign-in
const SCOPES = "https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile";
const BACKEND_URL = 'https://script.google.com/macros/s/AKfycbx-jSJ9gVzM6b975hEY6bEbM3JOTawq5Av8LE61-gJV8mi7cymPq9lj3k9OZJpxCrlD/exec'; // MAKE SURE THIS IS YOUR DEPLOYED APPS SCRIPT URL
const appStateKey = 'examAppState'; // Key for localStorage
const TOKEN_REFRESH_INTERVAL = 20 * 60 * 1000; // 20 minutes in milliseconds
const INACTIVITY_WARNING_TIME = 15 * 60 * 1000; // 15 minutes in milliseconds
const AUTO_SAVE_INTERVAL = 3 * 60 * 1000; // 3 minutes in milliseconds

// === App State ===
let isAdmin = false;
let isSignedIn = false;
let currentUser = null;
let tokenClient = null;
let isOnline = navigator.onLine;
let isSyncing = false;
let isInitializing = true;
let examDetails = null; // Holds the loaded exam data {PIN, Code, Name, Duration, StartDate, StartTime, Mode, Questions, OriginalOrderMap}
let studentPINEntered = ''; // PIN entered by the student
let studentExamIdEntered = ''; // 5-character ID ONLY for 'Exam' mode, entered by student
let examTimerInterval = null; // Interval ID for the countdown timer
let examEndTime = null; // Absolute end time (timestamp in ms)
let totalQuestions = 0; // To track total number of questions displayed
let confirmedQuestionsCount = 0; // To track confirmed questions
let tokenRefreshTimer = null; // Timer for periodic token refresh
let inactivityTimer = null; // Timer to detect inactivity
let lastActivityTime = Date.now(); // Timestamp of last user activity
let autoSaveTimer = null; // Timer for auto-saving answers
let codeEditors = {}; // Object to store CodeMirror instances by answerId

// === DOM Elements Cache ===
const loadingIndicator = document.getElementById('app-loading');
const mainContainer = document.getElementById('main-container');
const syncStatus = document.getElementById('sync-status');
const syncText = document.getElementById('sync-text');
const loginBtn = document.getElementById('login-btn');
const logoutBtn = document.getElementById('logout-btn');
const loginContainer = document.getElementById('login-container');
const userContainer = document.getElementById('user-container');
const userName = document.getElementById('user-name');
const userAvatar = document.getElementById('user-avatar');
const notificationArea = document.getElementById('in-page-notification-area');
const examNameHeader = document.getElementById('exam-name-header');
const examCodeDisplay = document.getElementById('exam-code-display');
const examDurationDisplay = document.getElementById('exam-duration-display');
const examStartTimeDisplay = document.getElementById('exam-start-time-display');
const signinPromptModule = document.getElementById('signin-prompt-module');
const examStartModule = document.getElementById('exam-start-module');
const studentNameInput = document.getElementById('student-name');
const studentEmailInput = document.getElementById('student-email');
const examPinInput = document.getElementById('exam-pin-input');
const studentExamIdGroup = document.getElementById('student-exam-id-group');
const studentExamIdInput = document.getElementById('student-exam-id-input');
const loadExamBtn = document.getElementById('load-exam-btn');
const examDetailsModule = document.getElementById('exam-details-module');
// const examDetailsDisplay = document.getElementById('exam-details-display'); // Content within module
const examNameDetail = document.getElementById('exam-name-detail');
const examCourseCodeDetail = document.getElementById('exam-course-code-detail');
const examModeDetail = document.getElementById('exam-mode-detail');
const examDurationDetail = document.getElementById('exam-duration-detail');
const examStartTimeDetail = document.getElementById('exam-start-time-detail');
const startExamBtn = document.getElementById('start-exam-btn');
const startExamBtnAlt = document.getElementById('start-exam-btn-alt');
// const examQuestionsModule = document.getElementById('exam-questions-module'); // Removed this wrapper
const examForm = document.getElementById('exam-form');
const examQuestionsArea = document.getElementById('exam-questions-area'); // Target for rendering question modules
const submitExamBtn = document.getElementById('submit-exam-btn');
// const timerDisplay = document.getElementById('timer-display'); // Removed from header, integrated into sticky
const submissionConfirmationModule = document.getElementById('submission-confirmation-module');

// === Initialisation ===
window.addEventListener('load', init);

function init() {
    console.log("Initialising...");
    if(document.body) document.body.classList.remove('content-hidden');
    if(mainContainer) mainContainer.classList.add('content-visible');
    updateYear();
    setupEventListeners();
    loadAppState(); // Load any saved state early
    updateOnlineStatus();
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    setupBackupImportFeature();
    setupSessionManagement(); // Added call

    // Use polling for Google API init
    let checkGoogleApiInterval = setInterval(() => {
        if (typeof gapi !== 'undefined' && typeof google !== 'undefined' && typeof google.accounts !== 'undefined') {
            clearInterval(checkGoogleApiInterval); // Stop polling
            console.log("Google API objects detected.");
            initGoogleApi(); // Initialize now that objects exist
        } else {
            console.log("Waiting for Google API objects to load...");
        }
    }, 200); // Check every 200ms

    // Optional: Add a timeout to stop polling after a while
    setTimeout(() => {
        if (checkGoogleApiInterval) { // Check if interval is still running
             clearInterval(checkGoogleApiInterval);
             console.error("Google API objects failed to load within 10 seconds.");
             handleApiInitError(new Error("Google API objects did not load in time"));
        }
    }, 10000); // Timeout after 10 seconds
}

function setupEventListeners() {
    loginBtn?.addEventListener('click', handleAuthClick);
    logoutBtn?.addEventListener('click', handleSignoutClick);
    loadExamBtn?.addEventListener('click', handleLoadExam);
    startExamBtn?.addEventListener('click', handleStartExam);
    startExamBtnAlt?.addEventListener('click', handleStartExam);
    submitExamBtn?.addEventListener('click', () => handleSubmitExam(false));

    // Enable load button only when PIN is entered, signed in, and online
    examPinInput?.addEventListener('input', () => {
        if (loadExamBtn) {
            loadExamBtn.disabled = examPinInput.value.trim() === '' || !isSignedIn || !isOnline;
        }
    });

    // Validate Student Exam ID input for Exam mode
    studentExamIdInput?.addEventListener('input', validateStudentExamIdInput);

    // Initial button states
    if (loadExamBtn) loadExamBtn.disabled = true;
    if (startExamBtn) startExamBtn.disabled = true;
    if (startExamBtnAlt) startExamBtnAlt.classList.add('hidden'); // Hide Exam mode button initially
    if (submitExamBtn) submitExamBtn.disabled = true;
}

function setupSessionManagement() {
    // Setup activity tracking
    document.addEventListener('mousemove', recordUserActivity);
    document.addEventListener('keydown', recordUserActivity);
    document.addEventListener('click', recordUserActivity);

    // Initial activity timestamp
    lastActivityTime = Date.now();

    // Set up auto-save for answers
    startAutoSave();
}

function showAppContent() {
    loadingIndicator?.classList.add('hidden');
    mainContainer?.classList.add('content-visible');
    console.log("App content shown.");
}

function updateYear() {
    const el = document.getElementById('currentYear');
    if (el) {
        el.textContent = new Date().getFullYear();
    }
}

function recordUserActivity() {
    const now = Date.now();
    const timeSinceLastActivity = now - lastActivityTime;
    lastActivityTime = now;

    // If there was a significant gap in activity, consider refreshing the token
    if (timeSinceLastActivity > 10 * 60 * 1000) { // 10 minutes
        console.log(`Detected activity after ${timeSinceLastActivity/1000}s inactivity, refreshing token...`);
        refreshTokenIfNeeded(true); // Force refresh
    }

    // Reset inactivity timer if it exists
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
        inactivityTimer = null;
    }

    // Start inactivity detection
    startInactivityDetection();
}

function startInactivityDetection() {
    // Clear any existing timer
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
    }

    // Set new timer to detect inactivity
    inactivityTimer = setTimeout(() => {
        const inactiveTime = Date.now() - lastActivityTime;
        if (inactiveTime >= INACTIVITY_WARNING_TIME) {
            showInactivityWarning();
        }
    }, INACTIVITY_WARNING_TIME);
}

function showInactivityWarning() {
    showImprovedNotification(
        'warning',
        'Session Expiring Soon',
        'You appear to be inactive. Please click, type, or move your mouse to keep your session active.',
        0 // Don't auto-dismiss
    );

    // Play a sound to alert the user (optional)
    try {
        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj2a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PruXI3DypsuO7Lfy4GFmS09tW0XigPRJXn8s13Hw0sbsfz4ZU+CxFVru/mtGYpDj6S5fPQgzMKFVyy9NeybCYQPZHk9dOIPAoTW7L11rVvKRE5j+P30oc9DBJZsvTYuXMqETiM4vfWjUIMEFew89e6disRNorm99SNQAwPVK/y2bt3LBE0i+X115FDDBBTrvPau3gtEDOJ5PfYk0ULDlCt8tu8ei4PMIjj+duXSAsMTarx3L56Lw8vhOP53JlKCwxKqfLdvXwwDi2C4/vem0sKCkmo8t/AfTANK3/i/OCdTQoJRqbx4MKAMgwqfeL84p9PCwhEpfDhw4IzCyl74fzjoVELCEKk8OLEgzQLKHnh/OWhUgsIPqPv5MWENComeOL96KNTCwc9oe/lxoY1CSV24v3ppVQMBzug7+bHiDYJJHTi/eulVQ0GN5/u58iJNwkic+P+66dXDQY2nu7oyos3CSBx4v7tqVkOBTWd7enLjDgJH3Di/+2rWw4FNJL9gsdlS0dlWID/q1sOBTOS/4LHZUtHZViA/6tcDgQx9f46vMG0g/iuXQ4EMfX+OrzBtIP4r14PBC/0/j+xwbKC+bBfDwMu9P8/scGygvmxYBADLvP/Q6/BsYL6s2IRBC3y/0Suwbrt+RSjqz3JkcgTKK3x/0WuwbnskRqeqT3EmcMXJ6vw/0etx8OUEhUilELQrtAeKKrv/0erycuiDQgLaTniyOUxLajt/0eqzNe2BwEEfjHxw+k8Nqbq/0qpztunAQEGkyz/uOVFP6nn/FvP3P5q/9oIC5s9nnMUNJDS/8G44zN4VxiPw/Ds/38uYvbzGI5TFhVwwO6dOnUGTUb/PYFWEQhwv/ChQIYL/Fk3/0WKPBAEb8ABqEyGA/lWMvxJlDERAHPBBaxSgAL9VCj7TJ0qEgFzwgmwWHoC/1Ij+0+kIhQDc8MNsV11Av9TIP1SmxkVA3LEELJhcAT/Uh37Vp8SFwZyxRSzZmkF/1Ia/LineRcIcsUYtGpiBf9TF/5fpHEXCXLGG7ZvWwb/VBb/ZKlpGApwxx26dFQH/1MV/2muYBkMb8cfvXlNCP9WFP9ttFgZDW3HIL98Rgj/Stb9Km2yUhsObMgiwIE/CP9F3P0bbr9KHBBqySPBhzcJ/0Di/RBvxUIdEmnKJcWMMAr/O+f+CW/KOh4UZ8wnx5EpC/8y7f8Bb88yHhVlzCrKliIM/0Tz/59w1CofFmTNLM2aGg3/Pe///HHZICAXYs4u0J8TDv8v9gDxcNwYIhlgzi/SoxMP/yf4Ad9v3xAkGl7PMdSoSxL/OvsCw27jCCQcXNAy1q5CFP8z8AOpcOYAJh1a0TTasD0V/yvxBJlv6fgnHljRNdy2ORb/JPMFiW7s9CgfVtI33bozF/8f9QZ4bO/qKSBV0zjfwCwY/xr3B2lr8uAqIVPUOuDGJhn/FPgIWWrz1SshUtU74MsgGf8S+gg4Z/TLLCJr1TzhziCJMpT+AiVA/Fxr988tI2rVN+HPQBozk/sCKFD9YW3/4C8jatU15tZlHF2P+wYygP+YdPMzLyRp1TOc42AgfIT5BiWY+/l9CDswKWnUMjr0Mg0qcPkArP4Bhh9GL0g31jF7/mz4sS5MKvxaWPg6Li3WL8F7+dDtCDe+Mx5NeA1SLSDKCJfzBJXw0jMQVY8WSS83xmBXvhSDVxdW0GceHnbfH4dTE1LjaSYZ2OQVlFcLWeRsJRHh7gqhXQBi33QcCP36BrhkljgLPgwjEP0E0SxLvzkLy3h80wxsxkfYbdUGOw0O/sMZq4yOqMfD5hQyDQr8yxyhjIyoyM7tGS0LCPvRHqCLiqnL2vIbKQgH+tghn4qJqM3h9R4lCAb42iOeiYmoz+j4IR8GA/fcJZ2JiKjP7vogHwYC9d0nnImIqM7s/CEfBgH03SiciIiozuz9Ih8I');
        audio.play().catch(e => console.warn("Could not play alert sound:", e));
    } catch(e) {
        console.warn("Could not create alert sound:", e);
    }
}

function startTokenRefresh() {
    stopTokenRefresh();
    console.log("Starting token refresh timer");
    tokenRefreshTimer = setInterval(() => {
        refreshTokenIfNeeded(false);
    }, TOKEN_REFRESH_INTERVAL);
}

function stopTokenRefresh() {
    if (tokenRefreshTimer) {
        clearInterval(tokenRefreshTimer);
        tokenRefreshTimer = null;
    }
}

async function refreshTokenIfNeeded(force = false) {
    if (!isSignedIn || !tokenClient) {
        console.log("Not refreshing token: not signed in or no tokenClient");
        return false;
    }
    const savedTokenStr = localStorage.getItem('gapi_token');
    if (!savedTokenStr) {
        console.log("No token to refresh");
        return false;
    }
    try {
        const savedToken = JSON.parse(savedTokenStr);
        let tokenAgeMs = Infinity; // Default to needing refresh if issued_at is invalid

        // Check if issued_at exists and is a number
        if (typeof savedToken.issued_at === 'number') {
             tokenAgeMs = Date.now() - savedToken.issued_at;
        } else {
             console.warn("Token 'issued_at' timestamp missing or invalid. Assuming refresh is needed.");
             force = true; // Force refresh if timestamp is bad
        }

        // If forced or token is older than 40 minutes, refresh it
        const needsRefresh = force || tokenAgeMs > 40 * 60 * 1000; // 40 minutes

        if (needsRefresh) {
            console.log(`Token age: ${tokenAgeMs / 1000}s - Refreshing token...`);
            // Use requestAccessToken without prompt for silent refresh
            tokenClient.requestAccessToken({ prompt: '' });
            return true;
        } else {
            console.log(`Token age: ${tokenAgeMs / 1000}s - No refresh needed`);
            return false;
        }
    } catch (e) {
        console.error("Error checking/refreshing token:", e);
        return false;
    }
}

function startAutoSave() {
    stopAutoSave();
    console.log("Starting auto-save timer");
    autoSaveTimer = setInterval(() => {
         // Use examQuestionsArea as the check, since the module wrapper was removed
        if (examQuestionsArea && !examQuestionsArea.closest('.hidden')) {
            autoSaveAnswers();
        }
    }, AUTO_SAVE_INTERVAL);
}

function stopAutoSave() {
    if (autoSaveTimer) {
        clearInterval(autoSaveTimer);
        autoSaveTimer = null;
    }
}

function autoSaveAnswers() {
    // Use examQuestionsArea as the check
    if (!examQuestionsArea || examQuestionsArea.closest('.hidden') || !examDetails) {
        return;
    }
    console.log("Auto-saving current answers...");
    try {
        const currentAnswers = {};
        const confirmationStatus = {};
        // Use the original indices to collect answers
        const originalIndices = Object.keys(examDetails.OriginalOrderMap).map(Number).sort((a, b) => a - b);
        originalIndices.forEach(originalIndex => {
            const originalQNum = originalIndex + 1;
            const answerName = `ans-${originalQNum}`;
            const questionDivId = `q-${originalQNum}`; // ID is now on question-module
            const questionDiv = document.getElementById(questionDivId);

            // Get confirmation status from the module div
            if (questionDiv) {
                confirmationStatus[questionDivId] = questionDiv.classList.contains('confirmed');
            }

            // Get answer value based on question type
            const questionData = examDetails.OriginalOrderMap[originalIndex];
            if (!questionData || questionData.type === 'text_only') return; // Skip text_only

            const formElement = examForm.elements[answerName];
            if (formElement) {
                switch (questionData.type) {
                    case 'multiple_select':
                        currentAnswers[answerName] = formElement.value || '';
                        break;
                    case 'attachment':
                        currentAnswers[answerName] = (formElement.files && formElement.files.length > 0) ? 'FILE_SELECTED' : '';
                        break;
                    case 'code':
                        if (codeEditors[answerName]) {
                           currentAnswers[answerName] = codeEditors[answerName].getValue();
                        } else {
                           currentAnswers[answerName] = formElement.value || '';
                        }
                         break;
                    default:
                        currentAnswers[answerName] = formElement.value || '';
                }
            }
        });

        // Update the saved state with current answers and confirmation status
        const currentState = JSON.parse(localStorage.getItem(appStateKey) || '{}');
        currentState.currentAnswers = currentAnswers;
        currentState.confirmationStatus = confirmationStatus;
        localStorage.setItem(appStateKey, JSON.stringify(currentState));

        console.log("Answers auto-saved successfully");
    } catch (e) {
        console.error("Error auto-saving answers:", e);
    }
}

function initializeCodeEditor(textareaId, language = 'python') {
    const textarea = document.getElementById(textareaId);
    if (!textarea) {
        console.warn(`Cannot initialize code editor: textarea #${textareaId} not found`);
        return null;
    }

    if (typeof CodeMirror === 'undefined') {
        console.warn('CodeMirror library not loaded. Using regular textarea.');
        return null;
    }

    console.log(`Initializing simple code editor for ${textareaId} with language ${language}`);

    try {
        // Initialize CodeMirror directly on the textarea (replacing it)
        const editor = CodeMirror.fromTextArea(textarea, {
            mode: language || "python",
            theme: "monokai",
            lineNumbers: true,
            indentUnit: 4,
            tabSize: 4,
            indentWithTabs: false,
            matchBrackets: true,
            autoCloseBrackets: true,
            lineWrapping: true,
            extraKeys: {
                "Tab": function(cm) {
                    if (cm.somethingSelected()) {
                        cm.indentSelection("add");
                    } else {
                        cm.replaceSelection("    ", "end");
                    }
                }
            }
        });

        // Make the editor a bit taller for better visibility
        editor.setSize(null, 150);

        // Store the editor instance
        codeEditors[textareaId] = editor;
        console.log(`Code editor initialized for ${textareaId}`);

        return editor;
    } catch (e) {
        console.error(`Error initializing CodeMirror for ${textareaId}:`, e);
        // Show the original textarea as fallback
        textarea.style.display = 'block';
        return null;
    }
}

function enhancePointsDisplay() {
     // Logic to find and enhance points display if needed based on new structure
     // Example: Find '.question-title' elements and parse/add badge if not already there
     document.querySelectorAll('.question-title').forEach(titleEl => {
         // Check if badge already exists to prevent duplicates
         if (titleEl.querySelector('.points-badge')) return;

         // Example of finding points in text like "Question X (Y points):"
         const match = titleEl.textContent.match(/\((\d+)\s+p(?:oin)?ts?\)/i);
         if(match && match[1]) {
              const points = match[1];
              const badgeHtml = `<span class="points-badge">${points} ${points == 1 ? 'pt' : 'pts'}</span>`;
              // Add badge - be careful modifying innerHTML if other event listeners exist
              titleEl.innerHTML += badgeHtml;
         }
     });
}

function hashString(str) {
    let hash = 0;
    if (!str || str.length === 0) return Math.floor(Math.random() * 1000000);
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash);
}

function seededShuffle(array, seed) {
    let m = array.length, t, i;
    // very simple PRNG: linear congruential
    while (m > 0) {
        seed = (seed * 1664525 + 1013904223) >>> 0; // update seed
        i = seed % m; // pick an index
        m--;
        // swap array[m] and array[i]
        t = array[m];
        array[m] = array[i];
        array[i] = t;
    }
    return array;
}

function escapeHtml(unsafe) {
    if (typeof unsafe !== 'string') return unsafe;
    return unsafe
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}

function addAttachmentValidation(inputId) {
    // Placeholder - Add validation logic if needed for file inputs
}

function getFingerprintData() {
    const webglFp = getWebglFingerprint();
    const data = {
        ua: navigator.userAgent || 'N/A',
        lang: navigator.language || 'N/A',
        vendor: navigator.vendor || 'N/A',
        cookieEnabled: navigator.cookieEnabled || false,
        doNotTrack: navigator.doNotTrack || 'unknown',
        plugins: Array.from(navigator.plugins || []).map(p => ({ name: p.name, filename: p.filename })).sort((a,b) => a.name.localeCompare(b.name)),
        mimeTypes: Array.from(navigator.mimeTypes || []).map(m => ({ type: m.type, description: m.description })).sort((a,b) => a.type.localeCompare(b.type)),
        platform: navigator.platform || 'N/A',
        cores: navigator.hardwareConcurrency || undefined,
        memory: navigator.deviceMemory || undefined,
        maxTouchPoints: navigator.maxTouchPoints || 0,
        screenRes: `${screen.width || 0}x${screen.height || 0}x${screen.colorDepth || 0}`,
        availScreenRes: `${screen.availWidth || 0}x${screen.availHeight || 0}`,
        windowInnerSize: `${window.innerWidth || 0}x${window.innerHeight || 0}`,
        timezoneOffset: new Date().getTimezoneOffset(),
        webglAvailable: webglFp.available,
        webglVendor: webglFp.vendor,
        webglRenderer: webglFp.renderer,
        ts: Date.now()
    };
    console.log("Collected Fingerprint Data:", data);
    return data;
}

function getWebglFingerprint() {
    try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) { return { available: false, vendor: 'N/A', renderer: 'N/A' }; }
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        const vendor = gl.getParameter(debugInfo ? debugInfo.UNMASKED_VENDOR_WEBGL : gl.VENDOR);
        const renderer = gl.getParameter(debugInfo ? debugInfo.UNMASKED_RENDERER_WEBGL : gl.RENDERER);
        return { available: true, vendor: vendor || 'unknown', renderer: renderer || 'unknown' };
    } catch (e) {
        console.warn("WebGL fingerprinting failed:", e);
        return { available: false, vendor: 'error', renderer: 'error', errorMsg: e.message };
    }
}

function downloadJsonBackup(data, filename) {
    try {
        const jsonString = JSON.stringify(data, null, 2); // Pretty-print
        const blob = new Blob([jsonString], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        console.log("JSON backup download initiated:", filename);
        showImprovedNotification('info', 'Backup Saved', 'A JSON backup file of your submission has been downloaded.');
    } catch (e) {
        console.error("Error creating or triggering JSON backup download:", e);
        showImprovedNotification('error', 'Backup Error', 'Could not create the backup file. Please manually copy your answers if needed.');
    }
}

function setupBackupImportFeature() {
    const userAvatarEl = document.getElementById('user-avatar'); // Use cached element
    if (!userAvatarEl) return;
    let clickCount = 0;
    let clickTimer = null;
    userAvatarEl.addEventListener('click', function() {
        clickCount++;
        if (clickCount === 1) {
            clickTimer = setTimeout(() => { clickCount = 0; clickTimer = null; }, 500);
        }
        if (clickCount === 3) {
            clearTimeout(clickTimer); clickCount = 0; clickTimer = null;
            showBackupImportDialog();
        }
    });
    if (!document.getElementById('backup-import-modal')) {
        createBackupImportDialog();
    }
}

function createBackupImportDialog() {
    const modalDiv = document.createElement('div');
    modalDiv.id = 'backup-import-modal';
    modalDiv.className = 'backup-modal';
    modalDiv.innerHTML = `
        <div class="backup-modal-content">
            <div class="backup-modal-header"><h3><i class="fas fa-file-import"></i> Import Backup</h3><button type="button" class="backup-close-btn" id="backup-close-btn">&times;</button></div>
            <div class="backup-modal-body">
                <p>You can restore a previously saved exam backup JSON file here.</p>
                <div class="form-group"><label for="backup-file-input">Select Backup File:</label><input type="file" id="backup-file-input" class="form-control" accept=".json"></div>
                <div class="backup-info" id="backup-info"></div><div class="backup-preview" id="backup-preview"></div>
            </div>
            <div class="backup-modal-footer"><button type="button" class="btn-orange" id="backup-cancel-btn">Cancel</button><button type="button" class="btn-green" id="backup-import-btn" disabled>Import Backup</button></div>
        </div>`;
    document.body.appendChild(modalDiv);
    document.getElementById('backup-close-btn')?.addEventListener('click', hideBackupImportDialog);
    document.getElementById('backup-cancel-btn')?.addEventListener('click', hideBackupImportDialog);
    document.getElementById('backup-file-input')?.addEventListener('change', handleBackupFileSelected);
    document.getElementById('backup-import-btn')?.addEventListener('click', importBackupData);
}

function showBackupImportDialog() {
    const modal = document.getElementById('backup-import-modal');
    if (modal) {
        const fileInput = document.getElementById('backup-file-input');
        const infoDiv = document.getElementById('backup-info');
        const previewDiv = document.getElementById('backup-preview');
        const importBtn = document.getElementById('backup-import-btn');
        if(fileInput) fileInput.value = '';
        if(infoDiv) infoDiv.innerHTML = '';
        if(previewDiv) previewDiv.innerHTML = '';
        if(importBtn) importBtn.disabled = true;
        if(fileInput) fileInput.dataset.validBackup = 'false';
        modal.classList.add('visible');
    }
}

function hideBackupImportDialog() {
    const modal = document.getElementById('backup-import-modal');
    if (modal) modal.classList.remove('visible');
}

function handleBackupFileSelected(event) {
    const fileInput = event.target;
    const file = fileInput.files[0];
    const infoDiv = document.getElementById('backup-info');
    const previewDiv = document.getElementById('backup-preview');
    const importBtn = document.getElementById('backup-import-btn');
    if(!infoDiv || !previewDiv || !importBtn) return; // Ensure elements exist
    infoDiv.innerHTML = ''; previewDiv.innerHTML = ''; importBtn.disabled = true; fileInput.dataset.validBackup = 'false';
    if (!file) return;
    if (file.type !== 'application/json' && !file.name.endsWith('.json')) { infoDiv.innerHTML = '<p class="backup-error">Error: Selected file is not a JSON file.</p>'; return; }
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const backupData = JSON.parse(e.target.result);
            if (!backupData.examDetails || !backupData.studentInfo || !backupData.answers) { throw new Error('Invalid backup file structure'); }
            infoDiv.innerHTML = `<p><strong>Exam:</strong> ${escapeHtml(backupData.examDetails.Name || 'N/A')}</p><p><strong>PIN:</strong> ${escapeHtml(backupData.examDetails.PIN || 'N/A')}</p><p><strong>Student:</strong> ${escapeHtml(backupData.studentInfo.name || 'N/A')}</p><p><strong>Timestamp:</strong> ${escapeHtml(backupData.submissionTimestamp || 'N/A')}</p><p><strong>Questions:</strong> ${backupData.totalQuestionsOnSubmit || 'N/A'}</p><p><strong>Confirmed:</strong> ${backupData.confirmedCountOnSubmit || 'N/A'}</p>`;
            const answerKeys = Object.keys(backupData.answers || {}).slice(0, 3);
            if (answerKeys.length > 0) { let previewHtml = '<p><strong>Answer Preview:</strong></p><ul>'; answerKeys.forEach(key => { const value = backupData.answers[key]; const truncatedValue = typeof value === 'string' && value.length > 50 ? value.substring(0, 50) + '...' : value; previewHtml += `<li>${escapeHtml(key)}: ${escapeHtml(String(truncatedValue))}</li>`; }); if (Object.keys(backupData.answers).length > 3) { previewHtml += `<li>... and ${Object.keys(backupData.answers).length - 3} more</li>`; } previewHtml += '</ul>'; previewDiv.innerHTML = previewHtml; } else { previewDiv.innerHTML = '<p>No answers found in backup.</p>'; }
            fileInput.dataset.validBackup = 'true'; importBtn.disabled = false;
        } catch (error) { console.error('Error parsing backup file:', error); infoDiv.innerHTML = `<p class="backup-error">Error: ${error.message}. Please select a valid backup file.</p>`; }
    };
    reader.onerror = function() { infoDiv.innerHTML = '<p class="backup-error">Error: Failed to read the file.</p>'; };
    reader.readAsText(file);
}

function importBackupData() {
    const fileInput = document.getElementById('backup-file-input');
    if (!fileInput || fileInput.dataset.validBackup !== 'true' || !fileInput.files[0]) { showImprovedNotification('error', 'Import Failed', 'Invalid or missing backup file.', 3000); return; }
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const backupData = JSON.parse(e.target.result);
            if (confirm(`Are you sure you want to import backup for ${backupData.examDetails.Name} (PIN: ${backupData.examDetails.PIN})?\n\nThis will replace any current exam data.`)) {
                applyBackupToForm(backupData); hideBackupImportDialog(); showImprovedNotification('success', 'Backup Imported', 'Exam backup has been successfully imported.', 5000);
            }
        } catch (error) { console.error('Error importing backup:', error); showImprovedNotification('error', 'Import Failed', `Error: ${error.message}`, 5000); }
    };
    reader.readAsText(fileInput.files[0]);
}

function applyBackupToForm(backupData) {
    // Load exam first if needed
    if (!examDetails || examDetails.PIN !== backupData.examDetails.PIN) {
        examDetails = backupData.examDetails; studentPINEntered = backupData.studentInfo.pinEntered || ''; studentExamIdEntered = backupData.studentInfo.studentExamId || '';
        displayExamDetailsHeader(); examStartModule.classList.add('hidden'); examDetailsModule.classList.add('hidden'); examQuestionsArea.parentElement.classList.remove('hidden');
        displayQuestions(examDetails.Questions); // Display questions first
    }
    // Apply answers after a delay to ensure questions (esp. CodeMirror) are rendered
    setTimeout(() => {
        const answers = backupData.answers || {};
        for (const answerName in answers) {
            const formElement = examForm.elements[answerName]; if (!formElement) continue;
            const answerValue = answers[answerName];
            if (formElement.type === 'file' || answerValue === '[NOT CONFIRMED]') continue;
            if (formElement.classList.contains('code-editor') && codeEditors[answerName]) { codeEditors[answerName].setValue(answerValue || ''); }
            else if (formElement.type === 'radio' || (formElement.length > 0 && formElement[0]?.type === 'radio')) { const radios = document.querySelectorAll(`input[name="${answerName}"]`); radios.forEach(radio => { radio.checked = (radio.value === answerValue); }); }
            else { formElement.value = answerValue || ''; }
            // Handle confirmation based on backup (might need adjustment if confirmation logic changed)
            const questionId = answerName.replace('ans-', 'q-');
            const questionModule = document.getElementById(questionId);
            // Check if the backup indicates *all* were confirmed, or check individual status if available
            const wasConfirmed = backupData.confirmationStatus ? backupData.confirmationStatus[questionId] : (backupData.confirmedCountOnSubmit === backupData.totalQuestionsOnSubmit);
            if (questionModule && wasConfirmed && !questionModule.classList.contains('text-only-question')) {
                confirmAnswer(questionId); // Apply confirmed state
            }
        }
        if (backupData.examEndTime) { examEndTime = backupData.examEndTime; startTimer(); }
        checkAllConfirmed();
    }, 600); // Increased delay slightly
}

// === Google API & Auth ===
function initGoogleApi() {
    console.log('Initialising Google Sign-In and GAPI client...');
    try {
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID,
            scope: SCOPES,
            callback: handleTokenResponse
        });
        gapi.load('client', async () => {
            console.log('GAPI client library loaded.');
            checkSavedTokenAndProceed();
        });
    } catch (error) {
        handleApiInitError(error);
    }
}

async function checkSavedTokenAndProceed() {
    const savedToken = localStorage.getItem('gapi_token');
    if (savedToken) {
        const token = JSON.parse(savedToken);
        if (token?.access_token) {
            try {
                gapi.client.setToken(token);
                console.log("Using saved token.");
                await tokenObtained(token);
            } catch (e) {
                console.warn("Error setting saved token even after gapi.load:", e);
                updateAuthUI();
                showAppContent();
            }
        } else {
            localStorage.removeItem('gapi_token');
            console.log("Saved token invalid or expired.");
            updateAuthUI();
            showAppContent();
        }
    } else {
        console.log("No saved token found.");
        updateAuthUI();
        showAppContent();
    }
}

function handleApiInitError(error) {
    console.error('API Initialisation Error:', error);
    showImprovedNotification('error', 'API Load Error', `Failed to load Google services: ${error.message}`);
    updateAuthUI();
    showAppContent();
}

function isTokenExpired(token) {
    // Placeholder - real check might involve expiry time if available in token
    return false;
}

function handleAuthClick() {
    if (tokenClient) {
        showImprovedNotification('info', 'Signing In', 'Opening Google Sign-In...');
        tokenClient.requestAccessToken({ prompt: 'select_account' });
    } else {
        console.error('Token client not initialised.');
        showImprovedNotification('error', 'Authentication Error', 'Authentication service is not ready. Please try again later.');
    }
}

function handleTokenResponse(resp) {
    if (resp.error) {
        console.error('Token response error:', resp);
        let msg = `Authentication failed: ${resp.error}`;
        if (resp.error === 'popup_closed_by_user') msg = 'Sign-in cancelled by user.';
        if (resp.error === 'access_denied') msg = 'Access denied. Please grant permission to proceed.';
        showImprovedNotification('error', 'Authentication Error', msg);
        updateAuthUI();
        showAppContent();
        return;
    }
    console.log('Access token received.');
    localStorage.setItem('gapi_token', JSON.stringify(resp)); // Save token
    if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined') {
        gapi.client.setToken(resp); // Set token for GAPI client
        tokenObtained(resp); // Proceed with obtained token
    } else {
        console.error("handleTokenResponse: gapi.client not ready when token received!");
        showImprovedNotification('error', 'Authentication Problem', 'Could not process sign-in token properly. Please try signing out and signing back in, or reload the page.');
        handleSignoutClick(); // Force sign out
    }
}

async function tokenObtained(token) {
    console.log("Token available, proceeding...");
    isSignedIn = true;
    await fetchUserInfo(token); // Fetch user info with the token
    updateAuthUI(); // Update UI to logged-in state
    showAppContent(); // Ensure content is shown

    // Check for saved state matching current user
    const loadedState = JSON.parse(localStorage.getItem(appStateKey) || '{}');
    if (currentUser &&
        loadedState.currentUserEmail === currentUser.email &&
        loadedState.examEndTime &&
        Date.now() < loadedState.examEndTime) {
        console.log("Attempting to restore active exam session.");
        restoreAppState(loadedState); // Restore previous session
    } else if (loadedState.currentUserEmail) {
        console.log("Saved state is invalid or expired for the current user.");
        localStorage.removeItem(appStateKey); // Clear invalid state
        // saveAppState(); // Optionally save clean state
    }
    startTokenRefresh(); // Start periodic token refresh
}

async function fetchUserInfo(tokenObject) {
    const accessToken = tokenObject?.access_token;
    if (!accessToken) {
        console.warn("fetchUserInfo called without a valid access token.");
        showImprovedNotification('error', 'Auth Error', 'Missing access token. Signing out.');
        handleSignoutClick(); return;
    }
    console.log('Fetching user information using provided token...');
    try {
        const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        if (!response.ok) {
            if (response.status === 401) {
                console.warn("User Info fetch failed (401 - Unauthorized). Signing out.");
                showImprovedNotification('error', 'Auth Expired', 'Your session has expired. Please sign in again.');
                handleSignoutClick(); return;
            }
            throw new Error(`(${response.status}) ${await response.text()}`);
        }
        const userInfo = await response.json();
        currentUser = { id: userInfo.sub, name: userInfo.name || 'N/A', email: userInfo.email || 'N/A', picture: userInfo.picture || '' };
        console.log('User details fetched:', currentUser.email);
        isAdmin = ADMIN_EMAILS.includes(currentUser?.email);
        document.body.classList.toggle('is-admin', isAdmin);
        console.log(`User role: ${isAdmin ? 'ADMIN' : 'STUDENT'}`);
        if (studentNameInput) studentNameInput.value = currentUser.name;
        if (studentEmailInput) studentEmailInput.value = currentUser.email;
        if (userAvatar) userAvatar.src = currentUser.picture;
        if (userName) userName.textContent = currentUser.name;
        if (examPinInput) examPinInput.disabled = false; // Enable PIN input
        if (loadExamBtn) { loadExamBtn.disabled = examPinInput.value.trim() === '' || !isOnline; } // Update load button
    } catch (e) {
        console.error('Fetch user info error:', e);
        showImprovedNotification('error', 'User Info Error', `Could not get user details: ${e.message}. Please try signing in again.`);
        currentUser = null; updateAuthUI();
    }
}

function handleSignoutClick() {
    console.log("Signing out...");
    const token = localStorage.getItem('gapi_token');
    if (token) {
        const parsedToken = JSON.parse(token);
        if (parsedToken?.access_token && typeof google !== 'undefined' && google.accounts?.oauth2) {
            try { google.accounts.oauth2.revoke(parsedToken.access_token, () => console.log('Token revoked successfully.')); } catch (e) { console.warn("Error revoking token:", e); }
        }
    }
    if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined') {
        try { gapi.client.setToken(''); } catch(e) { console.warn("Error clearing gapi token on signout", e); }
    }
    localStorage.removeItem('gapi_token'); localStorage.removeItem(appStateKey);
    isSignedIn = false; isAdmin = false; currentUser = null; examDetails = null; studentPINEntered = ''; studentExamIdEntered = '';
    stopTimer(); resetExamState(); updateAuthUI(); showImprovedNotification('info', 'Signed Out', 'You have been signed out.');
    stopTokenRefresh(); stopAutoSave(); if (inactivityTimer) { clearTimeout(inactivityTimer); inactivityTimer = null; }
}

// === UI State & Reset ===
function resetExamState() {
    console.log("Resetting UI to initial state.");
    examStartModule?.classList.add('hidden');
    examDetailsModule?.classList.add('hidden');
    examForm?.classList.add('hidden'); // Hide form containing questions area
    submissionConfirmationModule?.classList.add('hidden');
    studentExamIdGroup?.classList.add('hidden');
    signinPromptModule?.classList.remove('hidden');
    if (examPinInput) { examPinInput.value = ''; examPinInput.disabled = true; }
    if (studentExamIdInput) studentExamIdInput.value = '';
    if (studentNameInput) studentNameInput.value = '';
    if (studentEmailInput) studentEmailInput.value = '';
    if (loadExamBtn) { loadExamBtn.disabled = true; loadExamBtn.classList.remove('hidden'); loadExamBtn.innerHTML = '<i class="fas fa-download"></i> Load Exam'; }
    if (startExamBtn) startExamBtn.disabled = true;
    if (startExamBtnAlt) { startExamBtnAlt.classList.add('hidden'); startExamBtnAlt.disabled = true; }
    if (submitExamBtn) { submitExamBtn.disabled = true; submitExamBtn.innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)'; }
    const na = 'N/A';
    if (examCodeDisplay) examCodeDisplay.textContent = na;
    if (examDurationDisplay) examDurationDisplay.textContent = na;
    if (examStartTimeDisplay) examStartTimeDisplay.textContent = na;
    if (examNameHeader) examNameHeader.textContent = 'Please sign in to load the exam';
    if (examNameDetail) examNameDetail.textContent = '';
    if (examCourseCodeDetail) examCourseCodeDetail.textContent = '';
    if (examModeDetail) examModeDetail.textContent = '';
    if (examDurationDetail) examDurationDetail.textContent = '';
    if (examStartTimeDetail) examStartTimeDetail.textContent = '';
    if (examQuestionsArea) examQuestionsArea.innerHTML = '<p>Exam questions will appear here...</p>'; // Clear area
    stopTimer();
    const stickyTimer = document.querySelector('.sticky-timer'); if(stickyTimer) stickyTimer.remove(); // Remove sticky timer
    totalQuestions = 0; confirmedQuestionsCount = 0;
    document.body.classList.remove('time-warning', 'time-danger', 'time-expired'); // Reset body classes
}

function updateAuthUI() {
    console.log('Updating Auth UI - SignedIn:', isSignedIn, 'CurrentUser:', !!currentUser);
    document.body.classList.toggle('is-admin', isAdmin);
    if (isSignedIn && currentUser) {
        console.log('Showing logged-in UI.');
        if(loginContainer) loginContainer.style.display = 'none';
        if(userContainer) userContainer.style.display = 'flex';
        if(signinPromptModule) signinPromptModule.classList.add('hidden');
        // Show start module only if exam not loaded/started
        if (examStartModule && !examDetails && examForm?.classList.contains('hidden')) {
            examStartModule.classList.remove('hidden');
        }
        if (examPinInput) examPinInput.disabled = false;
        if (loadExamBtn) { loadExamBtn.disabled = examPinInput.value.trim() === '' || !isOnline; }
        if (studentNameInput) studentNameInput.value = currentUser.name || 'N/A';
        if (studentEmailInput) studentEmailInput.value = currentUser.email || 'N/A';
        if (userName) userName.textContent = currentUser.name || '';
        if (userAvatar) userAvatar.src = currentUser.picture || '';
    } else {
        console.log('Showing logged-out UI.');
         if(loginContainer) loginContainer.style.display = 'flex';
         if(userContainer) userContainer.style.display = 'none';
        resetExamState(); // Full reset for logged out state
         if(signinPromptModule) signinPromptModule.classList.remove('hidden');
    }
}

// === Exam Logic ===
async function handleLoadExam() {
    studentPINEntered = examPinInput.value.trim();
    if (!studentPINEntered) { showImprovedNotification('warning', 'Missing PIN', 'Please enter the Exam PIN.'); return; }
    loadExamBtn.disabled = true; loadExamBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
    await fetchExamDetails(studentPINEntered);
    loadExamBtn.disabled = false; loadExamBtn.innerHTML = '<i class="fas fa-download"></i> Load Exam';
    // Enable start buttons based on loaded details and online status
    if (startExamBtn) startExamBtn.disabled = !examDetails || !isOnline;
    if (startExamBtnAlt) startExamBtnAlt.disabled = !examDetails || !isOnline;
}

async function fetchExamDetails(pin) {
    showImprovedNotification('info', 'Fetching Exam', `Loading details for PIN: ${pin}...`);
    setSyncing(true); examDetails = null; examEndTime = null;
    try {
        const fetchUrl = `${BACKEND_URL}?pin=${encodeURIComponent(pin)}&action=getDetails`;
        console.log(`Workspaceing exam details from backend: ${fetchUrl}`);
        const response = await fetch(fetchUrl);
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const result = await response.json();
        console.log("Backend response (Exam Details):", result);
        if (result.success && result.examData) {
            const d = result.examData; // Alias for brevity
            const duration = parseInt(d.Duration, 10);
            const startTs = d.StartTimestampUTC;
            const mode = String(d.Mode || 'Quiz').toLowerCase();
            const qJson = String(d.Questions || '[]').trim();
            if (isNaN(duration) || duration <= 0) throw new Error("Invalid duration.");
            if (typeof startTs !== 'number' || isNaN(startTs)) throw new Error("Invalid StartTimestampUTC.");
            try { JSON.parse(qJson); } catch (e) { throw new Error(`Invalid questions JSON: ${e.message}`); }
            try { examEndTime = startTs + (duration * 60 * 1000); console.log(`[TIMER CALC] End TS: ${examEndTime}`); }
            catch (e) { throw new Error(`Could not calculate end time: ${e.message}`); }
            examDetails = { PIN: d.PIN, Code: d.Code, Name: d.Name, Duration: duration, StartDate: d.StartDate, StartTime: d.StartTime, Mode: mode, Questions: qJson, OriginalOrderMap: null, StartTimestampUTC: startTs, shuffleQuestions: String(d.ShuffleQuestions || 'yes').toLowerCase() };
            console.log("Exam details processed:", examDetails);
            displayExamDetailsHeader();
            showImprovedNotification('success', 'Exam Loaded', `Details for "${examDetails.Name}" loaded.`);
            // UI adjustments based on mode
            if (mode === 'exam') {
                examStartModule.classList.remove('hidden'); studentExamIdGroup.classList.remove('hidden');
                if(studentExamIdInput) studentExamIdInput.value = '';
                examDetailsModule.classList.add('hidden'); startExamBtnAlt.classList.remove('hidden');
                startExamBtn.classList.add('hidden'); startExamBtn.disabled = true; loadExamBtn.classList.add('hidden');
                validateStudentExamIdInput();
            } else { /* Quiz Mode */
                studentExamIdGroup.classList.add('hidden'); if(studentExamIdInput) studentExamIdInput.value = ''; studentExamIdEntered = '';
                examStartModule.classList.add('hidden'); displayExamDetailsFull(); examDetailsModule.classList.remove('hidden');
                startExamBtnAlt.classList.add('hidden'); startExamBtn.classList.remove('hidden');
                startExamBtn.disabled = !isOnline; loadExamBtn.disabled = true; loadExamBtn.classList.remove('hidden');
            }
            saveAppState();
        } else { throw new Error(result.message || "Exam details not found/backend error."); }
    } catch (error) {
        console.error(`Error fetching/processing exam details for PIN ${pin}:`, error);
        showImprovedNotification('error', 'Exam Load Failed', `Could not load exam: ${error.message}`);
        examDetails = null; examDetailsModule.classList.add('hidden'); examStartModule.classList.remove('hidden');
        if (loadExamBtn) loadExamBtn.disabled = !isOnline;
        // resetExamState(); // Reset might be too aggressive here, allow retry
    } finally { setSyncing(false); }
}

function validateStudentExamIdInput() {
    const btn = startExamBtnAlt; if (!btn || !studentExamIdInput || !examDetails || examDetails.Mode !== 'exam') return;
    const idValue = studentExamIdInput.value.trim(); const isValid = idValue.length === 5;
    btn.disabled = !isValid || !isOnline;
    studentExamIdInput.style.borderColor = (isValid || idValue === '') ? '#ccc' : 'red';
}

function displayExamDetailsHeader() {
    if (!examDetails) return;
    if (examCodeDisplay) examCodeDisplay.textContent = examDetails.Code || 'N/A';
    if (examDurationDisplay) examDurationDisplay.textContent = `${examDetails.Duration} minutes`;
    const startTimeStr = `${examDetails.StartDate || ''} ${examDetails.StartTime || ''}`.trim();
    if (examStartTimeDisplay) examStartTimeDisplay.textContent = startTimeStr || 'N/A';
    if (examNameHeader) examNameHeader.textContent = examDetails.Name || 'Exam Loaded'; // Update main H2
}

function displayExamDetailsFull() {
    if (!examDetails) return;
    if (examNameDetail) examNameDetail.textContent = examDetails.Name || 'N/A';
    if (examCourseCodeDetail) examCourseCodeDetail.textContent = examDetails.Code || 'N/A';
    const displayMode = examDetails.Mode ? (examDetails.Mode.charAt(0).toUpperCase() + examDetails.Mode.slice(1)) : 'N/A';
    if (examModeDetail) examModeDetail.textContent = displayMode;
    if (examDurationDetail) examDurationDetail.textContent = `${examDetails.Duration} minutes`;
    const startTimeStr = `${examDetails.StartDate || ''} ${examDetails.StartTime || ''}`.trim();
    if (examStartTimeDetail) examStartTimeDetail.textContent = startTimeStr || 'N/A';
}

async function checkIfAttemptExists(email, pin, studentExamId, mode) {
    console.log("Checking backend for existing 'submit' record..."); setSyncing(true);
    try {
        const params = new URLSearchParams({ action: 'checkExists', pin: pin, mode: mode });
        if (mode === 'quiz') { params.append('email', email); } else if (mode === 'exam') { params.append('studentExamId', studentExamId); }
        const fetchUrl = `${BACKEND_URL}?${params.toString()}`; console.log(`Checking existence via backend: ${fetchUrl}`);
        const response = await fetch(fetchUrl, { method: 'GET', headers: { 'Accept': 'application/json' } });
        if (!response.ok) { let eMsg = `BE check error! Status: ${response.status}`; try { const eD = await response.json(); eMsg = eD.message || eMsg; } catch (e) {} throw new Error(eMsg); }
        const result = await response.json(); console.log("Backend check response:", result);
        if (result.success) { return result.exists; } else { throw new Error(result.message || "BE error during existence check."); }
    } catch (error) { console.error('Error checking submission existence via backend:', error); showImprovedNotification('error', 'Check Failed', `Could not verify previous submissions: ${error.message}. Assuming none exist.`); return false; }
    finally { setSyncing(false); }
}

async function handleStartExam() {
    if (!examDetails || !currentUser) { showImprovedNotification('error', 'Start Error', 'Cannot start. User or exam details missing.'); return; }
    const currentMode = examDetails.Mode.toLowerCase(); let identifierForCheck = null;
    if (currentMode === 'exam') {
        const currentId = studentExamIdInput.value.trim();
        if (currentId.length !== 5) { showImprovedNotification('error', 'Invalid ID', 'Please enter the 5-character Student Exam ID.'); studentExamIdInput.focus(); return; }
        studentExamIdEntered = currentId; identifierForCheck = studentExamIdEntered; console.log(`Exam Mode: Using ID '${identifierForCheck}'`);
    } else { studentExamIdEntered = ''; identifierForCheck = currentUser.email; console.log(`Quiz Mode: Using Email '${identifierForCheck}'`); }
    console.log("Performing pre-start checks...");
    const alreadySubmitted = await checkIfAttemptExists(currentUser.email, examDetails.PIN, identifierForCheck, currentMode);
    if (alreadySubmitted) { showImprovedNotification('error', 'Already Submitted', `This exam (${examDetails.PIN}) was already submitted.`, 0); if (startExamBtn) startExamBtn.disabled = true; if (startExamBtnAlt) startExamBtnAlt.disabled = true; return; }
    try { /* ... Timing check logic ... */ const startTs = examDetails.StartTimestampUTC; if (!startTs || isNaN(startTs)) throw new Error("Start timestamp missing."); if (Date.now() < startTs) { showImprovedNotification('error', 'Not Yet Available', `Starts at ${new Date(startTs).toLocaleString()}.`); return; } if (!examEndTime || isNaN(examEndTime)) throw new Error("End time not determined."); if (Date.now() >= examEndTime) { showImprovedNotification('error', 'Deadline Passed', `Deadline was ${new Date(examEndTime).toLocaleString()}.`, 0); return; } }
    catch (e) { console.error("Timing check error:", e); showImprovedNotification('warning', 'Timing Check Warning', `${e.message}. Proceeding cautiously.`); }
    console.log(`Starting ${currentMode} mode. PIN: ${examDetails.PIN}` + (currentMode === 'exam' ? `, ID: ${studentExamIdEntered}` : ''));
    confirmedQuestionsCount = 0;
    examStartModule.classList.add('hidden'); examDetailsModule.classList.add('hidden'); examForm.classList.remove('hidden'); /* Show form */
    submissionConfirmationModule.classList.add('hidden');
    displayQuestions(examDetails.Questions); startTimer(); saveAppState(); checkAllConfirmed(); stopAutoSave(); startAutoSave();
}

// --- MODIFIED: displayQuestions to use module structure ---
function displayQuestions(questionsJsonString) {
    return new Promise((resolve, reject) => {
        console.log("Parsing and displaying exam questions as modules...");
        examQuestionsArea.innerHTML = ''; // Clear previous questions
        totalQuestions = 0;
        confirmedQuestionsCount = 0;
        codeEditors = {};

        try {
            let questionsArray = [];
            try {
                questionsArray = JSON.parse(questionsJsonString);
                if (!Array.isArray(questionsArray)) throw new Error("Parsed data is not an array.");
            } catch (parseError) {
                console.warn("Could not parse questions JSON.", parseError);
                questionsArray = [{ type: "long_answer", prompt: "Exam Instructions / Questions", content: questionsJsonString }];
            }

            totalQuestions = questionsArray.length;
            console.log(`Total questions loaded: ${totalQuestions}`);

            // Shuffling logic
            const shuffleSetting = String(examDetails.shuffleQuestions).trim().toLowerCase();
            const shuffleDisabled = ['no', 'false', '0'].includes(shuffleSetting);
            const skipShuffle = Boolean(isAdmin) || shuffleDisabled;
            console.log(`Shuffling: ${!skipShuffle}`);
            const seed = hashString(currentUser?.email || Date.now().toString());
            const originalIndices = Array.from(questionsArray.keys());
            const displayIndices = skipShuffle ? originalIndices : seededShuffle(originalIndices.slice(), seed);
            console.log("Display order:", displayIndices);

            examDetails.OriginalOrderMap = {};
            questionsArray.forEach((q, index) => { examDetails.OriginalOrderMap[index] = q; });

            let codeEditorInitPromises = [];

            displayIndices.forEach((originalIndex, displayIndex) => {
                const q = questionsArray[originalIndex];
                const displayQNum = displayIndex + 1;
                const originalQNum = originalIndex + 1;
                const questionId = `q-${originalQNum}`; // ID for the outer module div
                const answerId = `ans-${originalQNum}`;
                const answerName = `ans-${originalQNum}`;

                // Create Module Structure
                const questionModuleDiv = document.createElement('div');
                questionModuleDiv.className = 'module question-module'; // Add specific class
                if (q.type === 'text_only') {
                    questionModuleDiv.classList.add('text-only-question');
                }
                questionModuleDiv.id = questionId;
                questionModuleDiv.dataset.originalIndex = originalIndex;
                questionModuleDiv.dataset.displayIndex = displayIndex;

                // Create Header
                const headerDiv = document.createElement('div');
                headerDiv.className = 'module-header question-header';

                let pointsBadgeHtml = '';
                if (q.points && q.type !== 'text_only') {
                    pointsBadgeHtml = ` <span class="points-badge">${q.points} ${q.points == 1 ? 'pt' : 'pts'}</span>`;
                }
                const titleSpan = document.createElement('span');
                titleSpan.className = 'module-title question-title';
                const questionNumberLabel = isAdmin ? `Q${originalQNum} (Display #${displayQNum})` : `Question ${displayQNum}`;
                titleSpan.innerHTML = `<strong>${questionNumberLabel}${pointsBadgeHtml}:</strong>`;
                headerDiv.appendChild(titleSpan);
                questionModuleDiv.appendChild(headerDiv);

                // Create Content Area
                const contentAreaDiv = document.createElement('div');
                contentAreaDiv.className = 'module-content question-content-area'; // Specific class

                // Add Prompt Display Area
                const promptDiv = document.createElement('div');
                promptDiv.className = 'question-prompt-display';
                let promptText = q.prompt || '';
                promptText = escapeHtml(promptText);
                promptText = promptText.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
                promptText = promptText.replace(/(?<!\*)\*\*(?!\*)(.*?)\*\*(?!\*)/g, '<strong>$1</strong>');
                promptText = promptText.replace(/(?<![*\\])\*(?![*\\])(.*?)\*(?![*\\])/g, '<em>$1</em>');
                const termsToEmphasise = ['sep', 'end', 'print()', 'input()', 'range\\(5\\)', 'range\\(2, 8, 2\\)', 'TypeError', 'IDE'];
                 termsToEmphasise.forEach(term => { const t = (term.includes('\\(')) ? term : term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); const r = new RegExp(`(?<![=\\"'>])(\\b${t}\\b)(?![<\\(\\"'])`, 'g'); promptText = promptText.replace(r, (m) => `<em class="term">${m}</em>`); });
                 promptText = promptText.replace(/print'Hello World'/g, () => '<em class="term">print\'Hello World\'</em>'); promptText = promptText.replace(/x = 5 \+ '3'/g, () => '<em class="term">x = 5 + \'3\'</em>'); promptText = promptText.replace(/print\("Value:", value, sep = ':'\)/g, () => '<em class="term">print("Value:", value, sep = \':\')</em>'); promptText = promptText.replace(/print\(My variable is, x\)/g, () => '<em class="term">print(My variable is, x)</em>'); promptText = promptText.replace(/"My variable is"/g, () => '<em class="term">"My variable is"</em>');
                promptDiv.innerHTML = promptText.replace(/\n/g, '<br>');
                contentAreaDiv.appendChild(promptDiv);

                // Add Answer Input Area
                const answerAreaDiv = document.createElement('div');
                answerAreaDiv.className = 'question-answer-area form-group';
                let inputHtml = '';
                switch (q.type) {
                    case 'text_only': break;
                    case 'short_answer': inputHtml = `<input type="text" id="${answerId}" name="${answerName}" class="form-control" placeholder="Enter your answer">`; break;
                    case 'long_answer': inputHtml = `<textarea id="${answerId}" name="${answerName}" class="form-control" rows="5" placeholder="Enter your detailed answer">${escapeHtml(q.content || '')}</textarea>`; break;
                    case 'code':
                        inputHtml = `<textarea id="${answerId}" name="${answerName}" class="form-control code-editor" rows="8" placeholder="Enter your code">${escapeHtml(q.content || '')}</textarea>`;
                        codeEditorInitPromises.push(new Promise(res => { setTimeout(() => { initializeCodeEditor(answerId, q.language || 'python'); res(); }, 100); }));
                        break;
                    case 'attachment': inputHtml = `<input type="file" id="${answerId}" name="${answerName}" class="form-control"><span class="file-helper-text">Max size: ... Allowed types: ...</span>`; break;
                    case 'multiple_select':
                        inputHtml += `<div class="checkbox-group" id="${answerId}">`;
                        if (Array.isArray(q.options) && q.options.length > 0) {
                            const opts = [...Array(q.options.length).keys()];
                            const shuffledOpts = skipShuffle ? opts : seededShuffle(opts.slice(), seed + originalIndex);
                            q.shuffledOptionIndices = shuffledOpts;
                            shuffledOpts.forEach(oIdx => { const opt = q.options[oIdx]; const optId = `${answerId}-opt${oIdx}`; const escOpt = escapeHtml(opt); inputHtml += `<div class="checkbox-item"><input type="radio" id="${optId}" name="${answerName}" value="${escOpt}" class="form-control-checkbox" data-original-index="${oIdx}"><label for="${optId}">${escOpt}</label></div>`; });
                        } else { inputHtml += `<p style="color:red;">Error: Options missing.</p>`; }
                        inputHtml += `</div>`; break;
                    default: inputHtml = `<p>${escapeHtml(q.content || '')}</p>`; break;
                }
                answerAreaDiv.innerHTML = inputHtml;
                contentAreaDiv.appendChild(answerAreaDiv);

                // Add Actions Area (Confirm/Edit Buttons)
                if (q.type !== 'text_only') {
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'question-actions';
                    actionsDiv.innerHTML = `
                        <button type="button" class="btn-sm btn-success btn-confirm" onclick="confirmAnswer('${questionId}')"><i class="fas fa-check"></i> Confirm</button>
                        <button type="button" class="btn-sm btn-info btn-edit" onclick="editAnswer('${questionId}')"><i class="fas fa-pencil-alt"></i> Edit</button>`;
                    contentAreaDiv.appendChild(actionsDiv);
                }

                questionModuleDiv.appendChild(contentAreaDiv); // Add content to module
                examQuestionsArea.appendChild(questionModuleDiv); // Add module to page

                // Auto-confirm text_only
                if (q.type === 'text_only') {
                    confirmedQuestionsCount++;
                    questionModuleDiv.classList.add('confirmed', 'text-only-confirmed');
                }
            }); // End displayIndices.forEach

            // Wait for CodeMirror
            Promise.all(codeEditorInitPromises).then(() => {
                console.log("CodeMirror editors initialized.");
                enhancePointsDisplay(); checkAllConfirmed(); resolve();
            }).catch(reject);

        } catch (e) { console.error("Error displaying questions:", e); examQuestionsArea.innerHTML = '<p>Error loading questions.</p>'; reject(e); }
    });
}

function confirmAnswer(questionId) {
    const questionModuleDiv = document.getElementById(questionId);
    if (!questionModuleDiv || questionModuleDiv.classList.contains('confirmed')) return;
    questionModuleDiv.classList.add('confirmed'); // Triggers collapse via CSS
    if (!questionModuleDiv.classList.contains('text-only-question')) { confirmedQuestionsCount++; }
    const contentArea = questionModuleDiv.querySelector('.question-content-area');
    if (contentArea) {
        const inputs = contentArea.querySelectorAll('.form-control, .form-control-checkbox');
        inputs.forEach(input => { input.disabled = true; });
        const cmTextarea = contentArea.querySelector('.code-editor');
        if (cmTextarea && cmTextarea.id && codeEditors[cmTextarea.id]) {
            codeEditors[cmTextarea.id].setOption('readOnly', true);
            const cmElement = codeEditors[cmTextarea.id].getWrapperElement();
            if (cmElement) cmElement.classList.add('cm-confirmed');
        }
    }
    console.log(`Confirmed answer for question: ${questionId}`);
    checkAllConfirmed();
}

function editAnswer(questionId) {
    const questionModuleDiv = document.getElementById(questionId);
    if (!questionModuleDiv || !questionModuleDiv.classList.contains('confirmed')) return;
    questionModuleDiv.classList.remove('confirmed'); // Triggers expansion via CSS
    if (!questionModuleDiv.classList.contains('text-only-question')) { confirmedQuestionsCount--; }
    const contentArea = questionModuleDiv.querySelector('.question-content-area');
    if(contentArea){
        const inputs = contentArea.querySelectorAll('.form-control, .form-control-checkbox');
        inputs.forEach(input => { input.disabled = false; });
        const cmTextarea = contentArea.querySelector('.code-editor');
        if (cmTextarea && cmTextarea.id && codeEditors[cmTextarea.id]) {
            codeEditors[cmTextarea.id].setOption('readOnly', false);
            const cmElement = codeEditors[cmTextarea.id].getWrapperElement();
            if (cmElement) cmElement.classList.remove('cm-confirmed');
        }
    }
    console.log(`Enabled editing for question: ${questionId}`);
    checkAllConfirmed();
}

function checkAllConfirmed() {
    // Check if questions area exists and is visible (i.e., exam started)
    if (!examQuestionsArea || examQuestionsArea.closest('form')?.classList.contains('hidden') || totalQuestions <= 0) {
         if(submitExamBtn) { submitExamBtn.disabled = true; submitExamBtn.innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)'; }
         return;
     }
    // Count questions requiring confirmation (excluding text-only)
    const questionsRequiringConfirmation = document.querySelectorAll('.question-module:not(.text-only-question)').length;
    const confirmedNonTextOnly = document.querySelectorAll('.question-module.confirmed:not(.text-only-question)').length;
    const allConfirmed = confirmedNonTextOnly === questionsRequiringConfirmation;
    console.log(`Confirmed ${confirmedNonTextOnly}/${questionsRequiringConfirmation} questions. All confirmed: ${allConfirmed}`);
    if (submitExamBtn) {
        submitExamBtn.disabled = !allConfirmed || !isOnline;
        if (allConfirmed && isOnline) { submitExamBtn.innerHTML = '<i class="fas fa-check-circle"></i> Submit Exam Now'; }
        else if (!isOnline) { submitExamBtn.innerHTML = '<i class="fas fa-wifi"></i> Submit Exam (Offline)'; }
        else { submitExamBtn.innerHTML = `<i class="fas fa-lock"></i> Submit Exam (${confirmedNonTextOnly}/${questionsRequiringConfirmation} Confirmed)`; }
    }
}

// --- Timer Functions ---
function startTimer() { if (examTimerInterval) { console.warn("Timer running."); return; } if (!examEndTime || isNaN(examEndTime) || examEndTime <= Date.now()) { console.error("Timer start error: Invalid/past end time.", examEndTime); const s=document.getElementById('sticky-timer-display'); if(s) s.textContent="Error"; if (examEndTime && examEndTime <= Date.now()) { showImprovedNotification('error', 'Deadline Passed', 'Exam time expired.', 0); handleSubmitExam(true); } return; } createStickyTimer(); console.log(`Timer starting. End: ${new Date(examEndTime).toLocaleString()}`); updateTimerDisplay(); examTimerInterval = setInterval(updateTimerDisplay, 1000); }
function updateTimerDisplay() { if (!examEndTime) { console.warn("Timer update err: No end time."); stopTimer(); const s=document.getElementById('sticky-timer-display'); if(s) s.textContent="--:--"; return; } const n=Date.now(); const tL=Math.max(0, examEndTime - n); const min=Math.floor(tL/(1000*60)); const sec=Math.floor((tL/1000)%60); const timeStr=`${String(min).padStart(2,'0')}:${String(sec).padStart(2,'0')}`; const s=document.getElementById('sticky-timer-display'); if(s) s.textContent=timeStr; updateTimeVisualCues(min, sec, tL); if(tL<=0){ console.log("Time expired!"); stopTimer(); showImprovedNotification('warning', "Time's Up!", 'Submitting automatically.', 0); handleSubmitExam(true); } }
function updateTimeVisualCues(min, sec, timeLeft) { const st = document.querySelector('.sticky-timer'); const ti = st ? st.querySelector('i') : null; if (!st || !ti) return; if (timeLeft <= 0) { document.body.classList.remove('time-warning', 'time-danger'); document.body.classList.add('time-expired'); st.classList.remove('warning', 'danger'); st.classList.add('expired'); ti.className = 'fas fa-hourglass-end'; } else if (min <= 5) { document.body.classList.remove('time-warning'); document.body.classList.add('time-danger'); st.classList.remove('warning'); st.classList.add('danger'); ti.className = 'fas fa-exclamation-triangle'; } else if (min <= 10) { document.body.classList.add('time-warning'); document.body.classList.remove('time-danger'); st.classList.add('warning'); st.classList.remove('danger'); ti.className = 'fas fa-stopwatch'; } else { document.body.classList.remove('time-warning', 'time-danger'); st.classList.remove('warning', 'danger'); ti.className = 'fas fa-stopwatch'; } }
function stopTimer() { if (examTimerInterval) { clearInterval(examTimerInterval); examTimerInterval = null; console.log("Timer stopped."); } }
function createStickyTimer() { const et = document.querySelector('.sticky-timer'); if (et) et.remove(); const st = document.createElement('div'); st.className = 'sticky-timer'; st.innerHTML = `<i class="fas fa-stopwatch"></i> <span id="sticky-timer-display">--:--</span>`; document.body.appendChild(st); return st; }

// --- Submission ---
async function handleSubmitExam(isAutoSubmit = false) { const tUp = examEndTime && Date.now() >= examEndTime; if (tUp && !isAutoSubmit) { console.warn("Manual submit after deadline."); showImprovedNotification('warning', 'Deadline Passed', 'Submitting automatically.'); isAutoSubmit = true; } stopTimer(); submitExamBtn.disabled = true; submitExamBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...'; if (!isAutoSubmit) { const reqConf = document.querySelectorAll('.question-module:not(.text-only-question)').length; if (confirmedQuestionsCount !== reqConf /* Adjusted check */ ) { showImprovedNotification('error', 'Not All Confirmed', `Confirm all ${reqConf} answerable questions. Confirmed: ${confirmedQuestionsCount}.`, 5000); checkAllConfirmed(); return; } if (!confirm("Submit exam? This cannot be undone.")) { checkAllConfirmed(); if (examEndTime && Date.now() < examEndTime) { startTimer(); } return; } } console.log("Processing submission..." + (isAutoSubmit ? " (Auto)" : " (Manual)")); const answers = {}; const fpObj = getFingerprintData(); if (!examDetails || !examDetails.OriginalOrderMap || totalQuestions <= 0) { showImprovedNotification('error', 'Submit Error', 'Cannot collect answers.', 0); checkAllConfirmed(); return; } const oIdxs = Object.keys(examDetails.OriginalOrderMap).map(Number).sort((a, b) => a - b); oIdxs.forEach(oIdx => { const oQN = oIdx + 1; const qD = examDetails.OriginalOrderMap[oIdx]; const aN = `ans-${oQN}`; const qDivId = `q-${oQN}`; const qDiv = document.getElementById(qDivId); if (qD.type === 'text_only') { answers[aN] = "[TEXT_ONLY]"; return; } const isConf = qDiv ? qDiv.classList.contains('confirmed') : false; if (isAutoSubmit && !isConf) { answers[aN] = "[NOT CONFIRMED]"; } else { const fE = examForm.elements[aN]; if (fE) { switch (qD.type) { case 'attachment': answers[aN] = (fE.files && fE.files.length > 0) ? `FILE:${fE.files[0].name}` : ''; break; case 'multiple_select': let selVal = null; if (fE && typeof fE.value !== 'undefined') { if (fE.value !== "") { selVal = fE.value; if (!isAdmin && qD.shuffledOptionIndices) { const selOptEl = document.querySelector(`input[name="${aN}"]:checked`); if (selOptEl && selOptEl.dataset.originalIndex) { answers[`${aN}_metadata`] = { originalIndex: selOptEl.dataset.originalIndex }; } } } } answers[aN] = selVal; break; default: if (qD.type === 'code' && codeEditors[aN]) { answers[aN] = codeEditors[aN].getValue(); } else if (typeof fE.value !== 'undefined') { answers[aN] = fE.value; } else { answers[aN] = 'ERROR_NO_VALUE'; } break; } } else { answers[aN] = 'ERROR_NO_ELEMENT'; } } }); const bkData = { submissionTimestamp: new Date().toISOString(), examDetails: { PIN: examDetails?.PIN, Name: examDetails?.Name, Mode: examDetails?.Mode, Code: examDetails?.Code }, studentInfo: { pinEntered: studentPINEntered, studentExamId: examDetails?.Mode === 'exam' ? studentExamIdEntered : undefined, name: currentUser?.name, email: currentUser?.email }, answers: answers, fingerprint: fpObj, submittedLate: tUp, autoSubmitted: isAutoSubmit, confirmedCountOnSubmit: confirmedQuestionsCount, totalQuestionsOnSubmit: totalQuestions }; const bkFn = `exam_backup_${examDetails?.PIN||'unk'}_${(currentUser?.email||studentExamIdEntered||'anon').replace(/@.*/,'')}_${Date.now()}.json`; downloadJsonBackup(bkData, bkFn); const subData = { timestamp: bkData.submissionTimestamp, pin: examDetails?.PIN, courseCode: examDetails?.Code, mode: examDetails?.Mode, studentEmail: (examDetails?.Mode==='quiz'?currentUser?.email:undefined), studentName: (examDetails?.Mode==='quiz'?currentUser?.name:undefined), studentExamId: (examDetails?.Mode==='exam'?studentExamIdEntered:undefined), answers: answers, fingerprint: fpObj, isAutoSubmit: isAutoSubmit, timeIsUp: tUp }; let subSuccess = await sendSubmissionToBackend(subData); if (subSuccess) { showImprovedNotification('success', 'Exam Submitted', `Submission sent.`, 0); examForm.classList.add('hidden'); submissionConfirmationModule.classList.remove('hidden'); localStorage.removeItem(appStateKey); examDetails = null; studentPINEntered = ''; studentExamIdEntered = ''; examEndTime = null; totalQuestions = 0; confirmedQuestionsCount = 0; } else { console.error("Online submission failed after backup."); if (!isAutoSubmit) { checkAllConfirmed(); } else { showImprovedNotification('error', 'Auto-Submit Failed', 'Could not send submission. Backup downloaded.', 0); } } }
async function sendSubmissionToBackend(subData) { try { console.log(`Sending data to backend: ${BACKEND_URL}`); const response = await fetch(BACKEND_URL, { method: 'POST', mode: 'no-cors', headers: { 'Content-Type': 'text/plain;charset=utf-8', }, body: JSON.stringify({ submission: subData }) }); console.log("Fetch request sent to backend (no-cors)."); return true; } catch (error) { console.error('Error submitting to backend:', error); showImprovedNotification('error', 'Submission Error', `Could not send: ${error.message}. Backup downloaded.`, 0); return false; } }

// --- State Persistence ---
function saveAppState() { /* ... Paste definition from previous version ... */ if (!examDetails || (examForm?.classList.contains('hidden') && !submissionConfirmationModule.classList.contains('hidden'))) { if (examForm?.classList.contains('hidden') && submissionConfirmationModule.classList.contains('hidden')) { /* Save setup */ } else { console.log("Not saving state: Exam not active or submitted."); return; } } try { const state = { isSignedIn: isSignedIn, currentUserEmail: currentUser?.email, examDetails: examDetails, studentPINEntered: studentPINEntered, studentExamIdEntered: studentExamIdEntered, examEndTime: examEndTime, currentAnswers: /* collect */ {}, confirmationStatus: /* collect */ {} }; localStorage.setItem(appStateKey, JSON.stringify(state)); console.log("App state saved."); } catch (e) { console.error("Error saving state:", e); } }
function loadAppState() { /* ... Paste definition from previous version ... */ const sStr = localStorage.getItem(appStateKey); if (!sStr) { console.log("No saved state."); return; } try { const state = JSON.parse(sStr); console.log("Found saved state:", state); } catch (e) { console.error("Error parsing saved state:", e); localStorage.removeItem(appStateKey); } }
async function restoreAppState(state) { /* ... Paste definition from previous version ... */ console.log("Restoring state..."); examDetails = state.examDetails; studentPINEntered = state.studentPINEntered; studentExamIdEntered = state.studentExamIdEntered; examEndTime = state.examEndTime; if (!examEndTime || isNaN(examEndTime) || Date.now() >= examEndTime) { console.warn("Restored state expired/invalid."); localStorage.removeItem(appStateKey); resetExamState(); showImprovedNotification('warning', 'Session Expired', 'Previous session expired.', 0); return; } showImprovedNotification('info', 'Session Restored', 'Resuming previous session.', 5000); signinPromptModule.classList.add('hidden'); examStartModule.classList.add('hidden'); examDetailsModule.classList.add('hidden'); submissionConfirmationModule.classList.add('hidden'); examForm.classList.remove('hidden'); displayExamDetailsHeader(); try { if (examDetails && examDetails.Questions && examDetails.OriginalOrderMap) { console.log("Waiting for questions display..."); await displayQuestions(examDetails.Questions); console.log("Restoring answers..."); if (state.currentAnswers) { try { for (const aN in state.currentAnswers) { const fE = examForm.elements[aN]; if (fE && fE.classList.contains('code-editor') && codeEditors[aN]) { if (state.currentAnswers[aN] !== 'FILE_SELECTED') { codeEditors[aN].setValue(state.currentAnswers[aN] || ''); } } else if (fE && state.currentAnswers[aN] !== 'FILE_SELECTED') { if(fE.type === 'radio' || (fE.length > 0 && fE[0]?.type === 'radio')) { const val = state.currentAnswers[aN]; const radios = document.querySelectorAll(`input[name="${aN}"]`); radios.forEach(r => { r.checked = (r.value === val); }); } else { fE.value = state.currentAnswers[aN]; } } } if (state.confirmationStatus) { confirmedQuestionsCount = document.querySelectorAll('.text-only-confirmed').length; for (const qId in state.confirmationStatus) { const qDiv = document.getElementById(qId); if (qDiv && state.confirmationStatus[qId] && !qDiv.classList.contains('text-only-question')) { confirmAnswer(qId); } } } console.log(`Restored ${confirmedQuestionsCount}/${totalQuestions} confirms`); } catch (e) { console.error("Err restoring answers:", e); } } checkAllConfirmed(); } else { throw new Error("Missing Qs/Map in state."); } } catch (dErr) { console.error("Err during Q display/restore:", dErr); showImprovedNotification('error', 'Restore Failed', 'Could not restore Qs/answers.', 0); localStorage.removeItem(appStateKey); resetExamState(); return; } startTimer(); console.log("State restored."); }

// --- Utility Functions ---
function showImprovedNotification(type, title, message, duration = 5000) { /* ... Paste definition from previous version ... */ const container = notificationArea; if (!container) { console.error("Notification container missing."); return; } const notification = document.createElement('div'); notification.className = `in-page-notification in-page-notification-${type}`; let iconClass; switch (type) { case 'success': iconClass = 'fa-check-circle'; break; case 'error': iconClass = 'fa-times-circle'; break; case 'warning': iconClass = 'fa-exclamation-triangle'; break; default: iconClass = 'fa-info-circle'; } notification.innerHTML = `<i class="fas ${iconClass} fa-icon"></i><div class="notification-content"><strong>${title}</strong><br>${message.replace(/\n/g, '<br>')}</div><button type="button" class="notification-close" aria-label="Close">&times;</button>`; container.appendChild(notification); const closeBtn = notification.querySelector('.notification-close'); const removeNotification = () => { notification.classList.add('removing'); setTimeout(() => { if (notification.parentNode) { notification.parentNode.removeChild(notification); } }, 300); }; closeBtn?.addEventListener('click', (e) => { e.stopPropagation(); removeNotification(); }); if (duration > 0) { setTimeout(removeNotification, duration); } }
function updateOnlineStatus() { /* ... Paste definition from previous version ... */ isOnline = navigator.onLine; console.log('Connection Status:', isOnline ? 'Online' : 'Offline'); const sI = syncStatus?.querySelector('i'); if (isOnline) { syncStatus.className = 'sync-status online'; if (sI) sI.style.color = 'var(--success-color)'; if (syncText) syncText.textContent = 'Online'; } else { syncStatus.className = 'sync-status offline'; if (sI) sI.style.color = 'var(--warning-color)'; if (syncText) syncText.textContent = 'Offline'; if (!isInitializing) { showImprovedNotification('warning', 'Offline', 'Offline. Connection needed for some actions.', 5000); } } if (sI && !isSyncing) { sI.className = 'fas fa-circle'; if(isOnline) sI.style.color = 'var(--success-color)'; else sI.style.color = 'var(--warning-color)'; } if (loadExamBtn) { loadExamBtn.disabled = !isOnline || !isSignedIn || (examPinInput && examPinInput.value.trim() === ''); } let startDis = !isOnline || !isSignedIn || !examDetails; const isExam = examDetails && examDetails.Mode === 'exam'; if (isExam) { startDis = startDis || (studentExamIdInput && studentExamIdInput.value.trim().length !== 5); if (startExamBtnAlt) startExamBtnAlt.disabled = startDis; if (startExamBtn) startExamBtn.disabled = true; } else { if (startExamBtn) startExamBtn.disabled = startDis; if (startExamBtnAlt && examDetails) startExamBtnAlt.classList.add('hidden'); } checkAllConfirmed(); if (isInitializing && (typeof gapi !== 'undefined')) { isInitializing = false; console.log("Init complete."); } }
function setSyncing(syncing) { /* ... Paste definition from previous version ... */ isSyncing = syncing; console.log("Syncing:", isSyncing); const sI = syncStatus?.querySelector('i'); if (!sI) return; if (syncing) { sI.className = 'fas fa-spinner fa-spin'; sI.style.color = 'var(--info-color)'; if (syncText) syncText.textContent = 'Syncing...'; } else { updateOnlineStatus(); } }


// Make key functions globally available for inline handlers
window.confirmAnswer = confirmAnswer;
window.editAnswer = editAnswer;

</script>

</body>
</html>