<!DOCTYPE html>
<html lang="en-GB"> 
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>Exam Portal</title>
    <link rel="icon" type="image/png" href="https://bredliplaku.github.io/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.19/codemirror.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.19/theme/monokai.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.19/codemirror.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.19/mode/python/python.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.19/addon/edit/matchbrackets.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.19/addon/edit/closebrackets.min.js"></script>
<style>
:root {
    --primary-color: #3949ab;
    --secondary-color: #ffa726;
    --primary-dark: #1a237e;
    --success-color: #43a047;
    --warning-color: #fb8c00;
    --info-color: #2196F3;
    --danger-color: #f44336;
    --text-light: #fff;
    
    /* Python syntax highlighting colors */
    --py-keyword: #ff79c6;
    --py-builtin: #8be9fd;
    --py-function: #50fa7b;
    --py-string: #f1fa8c;
    --py-number: #bd93f9;
    --py-comment: #6272a4;
    --py-operator: #ff79c6;
    --py-variable: #f8f8f2;
}

/* ---------- Base Styles ---------- */
*, *::before, *::after { box-sizing: border-box; }

body, html {
    margin: 0;
    padding: 0;
    font-family: 'Roboto', sans-serif;
    background: #ffffff;
    color: #333;
    font-size: 16px;
}

/* Increase container width for larger screens */
.container {
    max-width: 1200px;
    margin: 20px auto;
    padding: 20px;
    width: 92%;
}

@media (min-width: 1600px) {
    body, html {
        font-size: 18px; /* Larger text for larger screens */
    }
    .container {
        max-width: 1400px;
    }
}

/* ---------- Header Styling ---------- */
.app-header {
    background: linear-gradient(135deg, #3949ab, #1a237e);
    padding: 28px 35px;
    border-radius: 15px;
    color: white;
    margin-bottom: 20px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

/* Switch title hierarchy when in exam */
body.in-exam .app-header h1 {
    font-size: 1.6em;
    font-weight: 500; /* Reduce boldness */
    margin: 0 0 15px 0;
    display: flex;
    align-items: center;
    opacity: 0.9;
}

body.in-exam .app-header h2 {
    font-size: 2.2em;
    margin: 0 0 10px 0;
    font-weight: 600;
}

/* Default header styles */
.app-header h1 {
    font-size: 2.2em;
    font-weight: 600;
    margin: 0 0 15px 0;
    display: flex;
    align-items: center;
}

.app-header h2 {
    font-size: 1.4em;
    opacity: 0.95;
    margin: 0 0 10px 0;
    font-weight: 500;
}

.app-header h1 i {
    margin-right: 10px;
}

.app-info {
    display: flex;
    flex-wrap: wrap;
    margin-top: 15px;
    gap: 10px;
}

.info-item {
    background-color: rgba(255,255,255,0.15);
    padding: 10px 15px;
    border-radius: 10px;
    font-size: 0.95em;
    line-height: 30px;
    display: inline-flex;
    align-items: center;
    gap: 5px;
}

/* ---------- Sync & Auth Container (Always Horizontal) ---------- */
.sync-auth-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    margin-bottom: 10px;
    border-bottom: 1px solid #eee;
    flex-wrap: nowrap; /* Prevent wrapping */
}

.sync-container {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-shrink: 0; /* Prevent shrinking */
}

.auth-container {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 10px;
    margin-left: auto; /* Push to right */
    flex-shrink: 0; /* Prevent shrinking */
}

/* Force horizontal layout even on small screens */
@media (max-width: 768px) {
    .sync-auth-container {
        flex-direction: row !important;
        border-bottom: 1px solid #eee;
        flex-wrap: nowrap !important;
        overflow-x: auto; /* Allow scrolling if needed */
        padding: 10px 0;
    }
    
    .auth-container, .sync-container {
        width: auto !important;
    }
    
    .user-info span {
        max-width: 100px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
}

/* ---------- Exam Questions Area ---------- */
#exam-questions-area {
    margin-top: 20px;
    padding: 20px;
    background-color: #f9f9f9;
    border: 1px solid #eee;
    border-radius: 10px;
}

/* Base question card */
#exam-questions-area .question {
    margin-bottom: 25px;
    padding: 20px;
    background-color: #fff;
    border-radius: 12px;
    box-shadow: 0 3px 10px rgba(0,0,0,0.08);
    border: 1px solid #e3e8f4;
    position: relative;
    transition: all 0.3s ease;
}

#exam-questions-area .question:hover {
    box-shadow: 0 5px 15px rgba(0,0,0,0.12);
}

/* Enhanced Question Labels */
#exam-questions-area .question > label,
#exam-questions-area .question > div.text-content {
    background: linear-gradient(to right, rgba(57, 73, 171, 0.12), transparent);
    padding: 12px 15px;
    border-radius: 6px 6px 0 0;
    font-size: 1.1em;
    margin: -20px -20px 15px -20px;
    border-bottom: 1px solid #e0e6f5;
    display: block;
    font-weight: 500;
    color: #333;
    position: relative;
}

.points-badge {
    background-color: #2196F3;
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.85em;
    margin-left: 5px;
}

#exam-questions-area .question > label strong {
    position: relative;
}

/* Stylized Points Badge */
#exam-questions-area .question-points {
    position: absolute;
    right: 15px;
    top: 12px;
    background-color: var(--info-color);
    color: white;
    padding: 3px 10px;
    border-radius: 15px;
    font-size: 0.85em;
    font-weight: 600;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Improved styling for emphasized terms */
#exam-questions-area .question em.term {
    background-color: rgba(255, 167, 38, 0.2);
    padding: 2px 5px;
    border-radius: 3px;
    font-style: normal;
    font-weight: 500;
    color: #d84315;
    display: inline-block;
}

/* Python Keywords Highlighting */
.py-keyword {
    color: var(--py-keyword);
    font-weight: 500;
    background-color: rgba(255, 121, 198, 0.1);
    padding: 0 3px;
    border-radius: 3px;
}

.py-builtin {
    color: var(--py-builtin);
    font-weight: 500;
    background-color: rgba(139, 233, 253, 0.1);
    padding: 0 3px;
    border-radius: 3px;
}

.py-string {
    color: var(--py-string);
    background-color: rgba(241, 250, 140, 0.1);
    padding: 0 3px;
    border-radius: 3px;
}

.py-number {
    color: var(--py-number);
    background-color: rgba(189, 147, 249, 0.1);
    padding: 0 3px;
    border-radius: 3px;
}

.py-function {
    color: var(--py-function);
    background-color: rgba(80, 250, 123, 0.1);
    padding: 0 3px;
    border-radius: 3px;
    font-weight: 500;
}

/* Improved Code Prompt Styling */
#exam-questions-area .question .code-prompt {
    font-family: 'Consolas', 'Monaco', monospace;
	background-color: #282a36;
    color: #f8f8f2;
    padding: 15px;
    border-radius: 6px;
    line-height: 1.6;
    margin-bottom: 15px;
    border-left: 4px solid var(--warning-color);
    white-space: pre-wrap;
    overflow-x: auto;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
}

/* Remove horizontal scrollbar when not needed */
#exam-questions-area .question .code-prompt::-webkit-scrollbar {
    height: 8px;
}

#exam-questions-area .question .code-prompt::-webkit-scrollbar-track {
    background: #373846;
    border-radius: 4px;
}

#exam-questions-area .question .code-prompt::-webkit-scrollbar-thumb {
    background: #555;
    border-radius: 4px;
}

#exam-questions-area .question .code-prompt::-webkit-scrollbar-thumb:hover {
    background: #666;
}

/* Text-only questions */
#exam-questions-area .question.text-only-question {
    background-color: #fffde7;
    border-left: 4px solid #fbc02d;
}

#exam-questions-area .question.text-only-question > div.text-content {
    background: linear-gradient(to right, rgba(251, 192, 45, 0.15), transparent);
    font-size: 1.05em;
}

/* Confirmed question styling */
#exam-questions-area .question.confirmed {
    background-color: #f1f8e9;
    border-left: 4px solid #7cb342;
    max-height: none !important;
    overflow: visible !important;
}

#exam-questions-area .question.confirmed > label,
#exam-questions-area .question.confirmed > div.text-content {
    background: linear-gradient(to right, rgba(124, 179, 66, 0.15), transparent);
    display: block !important;
    opacity: 1 !important;
}

/* Hide content when confirmed */
#exam-questions-area .question.confirmed .question-content {
    display: none !important;
}

/* Improved Multiple Choice Options */
#exam-questions-area .checkbox-group {
	display: flex !important;
    flex-direction: row !important;
    flex-wrap: wrap !important;
    gap: 12px !important;
    margin-top: 15px;
    width: 100% !important;
}

/* Make options fill the row evenly */
#exam-questions-area .checkbox-item {
    flex: 1 1 0 !important; /* grow, shrink, basis */
    min-width: 180px !important;
    max-width: 100% !important;
    margin: 0 !important;
    background-color: #f8f9fa;
    padding: 10px 12px;
    border-radius: 6px;
    transition: all 0.2s ease;
    border: 1px solid #dee2e6;
    display: flex;
    align-items: center;
}

#exam-questions-area .checkbox-item:hover {
    background-color: #e9ecef;
    border-color: #ced4da;
    transform: translateY(-2px);
    box-shadow: 0 3px 6px rgba(0,0,0,0.08);
}

#exam-questions-area .checkbox-item input[type="radio"] {
    margin-right: 8px !important;
    cursor: pointer;
    width: 18px;
    height: 18px;
    flex-shrink: 0;
}

#exam-questions-area .checkbox-item label {
    margin-bottom: 0;
    font-weight: normal;
    cursor: pointer;
    flex-grow: 1;
}

/* Selected option styling */
#exam-questions-area .checkbox-item input[type="radio"]:checked + label {
    font-weight: 500;
    color: var(--primary-dark);
}

#exam-questions-area .checkbox-item:has(input[type="radio"]:checked) {
    background-color: #e3f2fd;
    border-color: #90caf9;
    box-shadow: 0 2px 5px rgba(33, 150, 243, 0.2);
}

/* Action buttons */
#exam-questions-area .question-actions {
    display: flex !important;
    justify-content: center !important;
    gap: 12px !important;
    margin-top: 20px;
    margin-bottom: 10px;
}

#exam-questions-area .btn-confirm,
#exam-questions-area .btn-edit {
    min-width: 120px;
    padding: 10px 15px;
    font-weight: 500;
}

#exam-questions-area .btn-confirm {
    background-color: var(--success-color) !important;
    color: white !important;
}

#exam-questions-area .btn-edit {
    background-color: var(--info-color) !important;
}

/* Hide edit button by default, show on confirmation */
#exam-questions-area .question:not(.confirmed) .btn-edit {
    display: none !important;
}

#exam-questions-area .question.confirmed .btn-edit {
    display: inline-flex !important;
}

#exam-questions-area .question.confirmed .btn-confirm {
    display: none !important;
}

/* Confirmed badge */
#exam-questions-area .question.confirmed::after {
    content: "✓ CONFIRMED";
    position: absolute;
    right: 15px;
    top: 15px;
    font-size: 0.8em;
    background-color: #81c784;
    color: white;
    padding: 4px 10px;
    border-radius: 15px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    z-index: 5;
    font-weight: 600;
    letter-spacing: 0.5px;
}

/* Submit Button */
#submit-exam-btn {
    margin-top: 30px;
    width: 100%;
    background: linear-gradient(to right, #43a047, #2e7d32);
    font-weight: 500;
    padding: 15px 30px;
    font-size: 1.1em;
    border-radius: 30px;
    box-shadow: 0 4px 12px rgba(46, 125, 50, 0.3);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

#submit-exam-btn:hover:not(:disabled) {
    box-shadow: 0 6px 16px rgba(46, 125, 50, 0.4);
    transform: translateY(-2px);
}

/* ---------- Responsive Fixes ---------- */
@media (max-width: 768px) {
    /* Ensure checkboxes stay readable on small screens */
    #exam-questions-area .checkbox-item {
        flex: 1 1 100% !important;
        min-width: 100% !important;
    }
    
    /* Adjust points badge position */
    #exam-questions-area .question-points {
        position: static;
        display: inline-block;
        margin-left: 10px;
        margin-top: 5px;
    }
    
    /* Make sure app info stays readable */
    .app-info {
        flex-direction: column;
    }
    
    .info-item {
        width: 100%;
    }
	    .sync-auth-container {
        flex-direction: row !important;
        flex-wrap: nowrap !important;
    }
    
    .user-info span {
        max-width: 100px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
}
    </style>

</head>
<body class="content-hidden">
    <div id="app-loading" class="app-loading">
        <img src="https://raw.githubusercontent.com/bredliplaku/bredliplaku.github.io/refs/heads/main/loading.gif" alt="Loading..." style="width: 150px; height: 150px;">
        <div style="margin-top: 10px; font-size: 14px; color: #666;">Loading Exam Portal...</div>
    </div>
    <div class="container" id="main-container">
        <div class="sync-auth-container">
            <div class="sync-container">
                 <div id="sync-status" class="sync-status offline">
                    <i class="fas fa-circle"></i>
                    <span id="sync-text">Offline</span>
                </div>
            </div>
            <div class="auth-container">
                 <div id="login-container">
                    <button id="login-btn" class="btn-blue">
                        <i class="fas fa-sign-in-alt"></i> Sign in
                    </button>
                </div>
                <div id="user-container" style="display: none">
                    <div class="user-info">
                        <img id="user-avatar" class="user-avatar" src="" alt="Avatar">
                        <span id="user-name"></span>
                         <button id="logout-btn" class="btn-sm">
                            <i class="fas fa-sign-out-alt"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <div class="app-header">
            <h1><i class="fa-solid fa-clipboard-question"></i> Exam Portal</h1>
            <h2 id="exam-name-header">Enter PIN to load exam</h2>
            <div class="app-info">
                <span class="info-item">
                     <i class="fa-solid fa-table-list"></i> Course:
                    <span id="exam-code-display">N/A</span>
                </span>
                <span class="info-item">
                    <i class="far fa-clock fa-spin"></i> Duration:
                     <span id="exam-duration-display">N/A</span>
                </span>
                <span class="info-item">
                    <i class="fas fa-calendar-alt"></i> Start Time:
                    <span id="exam-start-time-display">N/A</span>
                 </span>
            </div>
        </div>
        <div id="in-page-notification-area" class="in-page-notifications"></div>
        <div id="signin-prompt-module" class="module">
            <div class="module-content not-signed-in-message">
                <h3><i class="fas fa-info-circle"></i> Welcome</h3>
                <p>Sign in with your University Google Account.</p>
            </div>
        </div>
        <div id="exam-start-module" class="module hidden">
            <div class="module-header">
                <span class="module-title">
                    <i class="fas fa-user-check"></i> Student Details
                </span>
            </div>
            <div class="module-content">
                <div class="form-group">
                    <label for="student-name">Name:</label>
                     <input type="text" id="student-name" class="form-control" disabled>
                </div>
                <div class="form-group">
                    <label for="student-email">Email:</label>
                    <input type="email" id="student-email" class="form-control" disabled>
                </div>
                  <div class="form-group">
                    <label for="exam-pin-input">Exam PIN:</label>
                    <input type="text" id="exam-pin-input" class="form-control" placeholder="The lecturer will provide you with the PIN">
                </div>
                <div id="student-exam-id-group" class="form-group hidden">
                    <label for="student-exam-id-input">Student Exam ID (Confidential - 5 characters):</label>
                    <input type="text" id="student-exam-id-input" class="form-control" placeholder="Enter your Exam ID from the attendance sheet" maxlength="5">
                </div>
                <button id="load-exam-btn" class="btn-blue" disabled>
                     <i class="fas fa-download"></i> Load Exam
                </button>
                <button id="start-exam-btn-alt" class="btn-green hidden" disabled>
                    <i class="fas fa-play"></i> Start Exam
                </button>
             </div>
        </div>
        <div id="exam-details-module" class="module hidden">
            <div class="module-header">
                <span class="module-title">
                    <i class="fas fa-info-circle"></i> Exam Information
                </span>
             </div>
            <div class="module-content" id="exam-details-display">
                <p>
                    <strong>Exam Name:</strong>
                    <span id="exam-name-detail"></span>
                </p>
                 <p>
                    <strong>Course Code:</strong>
                    <span id="exam-course-code-detail"></span>
                </p>
                <p>
                      <strong>Mode:</strong>
                    <span id="exam-mode-detail"></span>
                </p>
                <p>
                    <strong>Duration:</strong>
                    <span id="exam-duration-detail"></span>
                 </p>
                <p>
                    <strong>Start Time:</strong>
                    <span id="exam-start-time-detail"></span>
                </p>
                 <button id="start-exam-btn" class="btn-green" disabled>
                    <i class="fas fa-play"></i> Start Exam
                </button>
            </div>
        </div>
        <div id="exam-questions-module" class="module hidden">
            <div class="module-header">
                 <span class="module-title">
                    <i class="fa-solid fa-list-ol"></i> Exercises
                </span>
                <span class="info-item" style="background-color: var(--danger-color); color: white;">
                    <i class="fas fa-stopwatch"></i> Time Left:
                    <span id="timer-display">--:--</span>
                </span>
            </div>
            <div class="module-content">
                 <form id="exam-form">
                    <div id="exam-questions-area">
                        <p>Loading questions...</p>
                    </div>
                    <button type="button" id="submit-exam-btn" class="btn-green" disabled>
                         <i class="fas fa-check-circle"></i> Submit Exam
                    </button>
                </form>
            </div>
        </div>
        <div id="submission-confirmation-module" class="module hidden">
              <div class="module-content confirmation-message">
                <i class="fas fa-check-circle fa-3x" style="color: var(--success-color); margin-bottom: 15px;"></i><br>
                Exam Submitted Successfully!
            </div>
        </div>
    <footer class="footer">
        <div class="social-links">
            <a href="https://eis.epoka.edu.al/cv/fullcv/655" target="_blank" rel="noopener noreferrer"><i class="far fa-id-card"></i></a>
            <a href="mailto:bplaku@epoka.edu.al" target="_blank" rel="noopener noreferrer"><i class="far fa-envelope"></i></a>
        </div>
        <p style="font-size:0.7em"><i class="far fa-copyright"></i> 2023-<span id="currentYear"></span> Bredli Plaku. All Rights Reserved.</p>
    </footer>
    </div>

<script>
// === DOM Cache & Configuration ===
// Configuration constants
const CONFIG = {
    ADMIN_EMAILS: ['bplaku@epoka.edu.al'],
    CLIENT_ID: '740588046540-npg0crodtcuinveu6bua9rd6c3hb2s1m.apps.googleusercontent.com',
    SCOPES: "https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile",
    BACKEND_URL: 'https://script.google.com/macros/s/AKfycbwwxJtabXudOMceDKfAAfp3sPfcD_UvMaBSfoTEqrTIoq-9wJAfJhm9g50c-wGq5xBS/exec',
    TOKEN_REFRESH_INTERVAL: 20 * 60 * 1000, // 20 minutes
    INACTIVITY_WARNING_TIME: 15 * 60 * 1000, // 15 minutes
    AUTO_SAVE_INTERVAL: 3 * 60 * 1000, // 3 minutes
    APP_STATE_KEY: 'examAppState'
};

// Global state
const STATE = {
    isAdmin: false,
    isSignedIn: false,
    currentUser: null,
    tokenClient: null,
    isOnline: navigator.onLine,
    isSyncing: false,
    isInitializing: true,
    examDetails: null,
    studentPINEntered: '',
    studentExamIdEntered: '',
    examTimerInterval: null,
    examEndTime: null,
    totalQuestions: 0,
    confirmedQuestionsCount: 0,
    tokenRefreshTimer: null,
    inactivityTimer: null,
    lastActivityTime: Date.now(),
    autoSaveTimer: null,
    codeEditors: {}
};

// DOM elements cache - populated during init
const DOM = {};

// === Initialization ===
window.addEventListener('load', init);

function init() {
    console.log("Initializing...");
    // Keep this check if init might be called before load somehow
    if (document.readyState !== 'complete') {
        window.addEventListener('load', init);
        return;
    }
    document.body.classList.remove('content-hidden');

    // Cache all DOM elements
    cacheDOMElements();

    // Basic setup
    if (DOM.mainContainer) DOM.mainContainer.classList.add('content-visible');
    updateYear();
    setupEventListeners();
    loadAppState();
    updateOnlineStatus(); // Initial status check

    // Event listeners for online/offline detection
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    setupBackupImportFeature();

    // ADDED: Poll to check if Google API objects are loaded
    let checkGoogleApiInterval = setInterval(() => {
        if (typeof gapi !== 'undefined' && typeof google !== 'undefined' && typeof google.accounts !== 'undefined') {
            clearInterval(checkGoogleApiInterval); // Stop polling
            console.log("Google API objects detected.");
            initGoogleApi(); // Initialize now that objects exist
        } else {
            console.log("Waiting for Google API objects to load...");
        }
    }, 200); // Check every 200ms

    // Optional: Add a timeout to stop polling after a while to prevent infinite loops if scripts fail badly
    setTimeout(() => {
        if (checkGoogleApiInterval) { // Check if interval is still running
             clearInterval(checkGoogleApiInterval);
             console.error("Google API objects failed to load within 10 seconds.");
             handleApiInitError(new Error("Google API objects did not load in time"));
        }
    }, 10000); // Timeout after 10 seconds
}

function cacheDOMElements() {
    // Main elements
    const ids = [
        'app-loading', 'main-container', 'sync-status', 'sync-text',
        'login-btn', 'logout-btn', 'login-container', 'user-container',
        'user-name', 'user-avatar', 'in-page-notification-area',
        'exam-name-header', 'exam-code-display', 'exam-duration-display',
        'exam-start-time-display', 'signin-prompt-module', 'exam-start-module',
        'student-name', 'student-email', 'exam-pin-input',
        'student-exam-id-group', 'student-exam-id-input', 'load-exam-btn',
        'exam-details-module', 'exam-details-display', 'exam-name-detail',
        'exam-course-code-detail', 'exam-mode-detail', 'exam-duration-detail',
        'exam-start-time-detail', 'start-exam-btn', 'start-exam-btn-alt',
        'exam-questions-module', 'exam-form', 'exam-questions-area',
        'submit-exam-btn', 'timer-display', 'submission-confirmation-module',
        'currentYear'
    ];
    
    // Cache all elements with IDs
    ids.forEach(id => {
        DOM[id] = document.getElementById(id);
    });
    
    // Store references to sync icon and other elements that need frequent access
    if (DOM['sync-status']) {
        DOM.syncIcon = DOM['sync-status'].querySelector('i');
    }
}

function setupEventListeners() {
    // Auth
    if (DOM['login-btn']) DOM['login-btn'].addEventListener('click', handleAuthClick);
    if (DOM['logout-btn']) DOM['logout-btn'].addEventListener('click', handleSignoutClick);
    
    // Exam flow
    if (DOM['load-exam-btn']) DOM['load-exam-btn'].addEventListener('click', handleLoadExam);
    if (DOM['start-exam-btn']) DOM['start-exam-btn'].addEventListener('click', handleStartExam);
    if (DOM['start-exam-btn-alt']) DOM['start-exam-btn-alt'].addEventListener('click', handleStartExam);
    if (DOM['submit-exam-btn']) DOM['submit-exam-btn'].addEventListener('click', () => handleSubmitExam(false));
    
    // Enable load button only when PIN is entered, signed in, and online
    if (DOM['exam-pin-input']) {
        DOM['exam-pin-input'].addEventListener('input', () => {
            if (DOM['load-exam-btn']) {
                DOM['load-exam-btn'].disabled = DOM['exam-pin-input'].value.trim() === '' || 
                                                !STATE.isSignedIn || 
                                                !STATE.isOnline;
            }
        });
    }
    
    // Validate Student Exam ID input for Exam mode
    if (DOM['student-exam-id-input']) {
        DOM['student-exam-id-input'].addEventListener('input', validateStudentExamIdInput);
    }
    
    // Set initial button states
    if (DOM['load-exam-btn']) DOM['load-exam-btn'].disabled = true;
    if (DOM['start-exam-btn']) DOM['start-exam-btn'].disabled = true;
    if (DOM['start-exam-btn-alt']) DOM['start-exam-btn-alt'].classList.add('hidden');
    if (DOM['submit-exam-btn']) DOM['submit-exam-btn'].disabled = true;
    
    // Set up activity monitoring
    setupSessionManagement();
}

function setupSessionManagement() {
    // Activity tracking
    ['mousemove', 'keydown', 'click'].forEach(eventType => {
        document.addEventListener(eventType, recordUserActivity);
    });
    
    // Initial activity timestamp
    STATE.lastActivityTime = Date.now();
    
    // Set up auto-save for answers
    startAutoSave();
}

function recordUserActivity() {
    const now = Date.now();
    const timeSinceLastActivity = now - STATE.lastActivityTime;
    STATE.lastActivityTime = now;
    
    // If significant gap in activity, refresh token
    if (timeSinceLastActivity > 10 * 60 * 1000) { // 10 minutes
        console.log(`Detected activity after ${timeSinceLastActivity/1000}s inactivity, refreshing token...`);
        refreshTokenIfNeeded(true); // Force refresh
    }
    
    // Reset inactivity timer
    if (STATE.inactivityTimer) {
        clearTimeout(STATE.inactivityTimer);
        STATE.inactivityTimer = null;
    }
    
    // Start inactivity detection
    startInactivityDetection();
}

function startInactivityDetection() {
    // Clear any existing timer
    if (STATE.inactivityTimer) {
        clearTimeout(STATE.inactivityTimer);
    }
    
    // Set new timer to detect inactivity
    STATE.inactivityTimer = setTimeout(() => {
        const inactiveTime = Date.now() - STATE.lastActivityTime;
        if (inactiveTime >= CONFIG.INACTIVITY_WARNING_TIME) {
            showInactivityWarning();
        }
    }, CONFIG.INACTIVITY_WARNING_TIME);
}

function showInactivityWarning() {
    showImprovedNotification(
        'warning', 
        'Session Expiring Soon', 
        'You appear to be inactive. Please click, type, or move your mouse to keep your session active.', 
        0 // Don't auto-dismiss
    );
    
    // Play alert sound (optional)
    try {
        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj2a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PruXI3DypsuO7Lfy4GFmS09tW0XigPRJXn8s13Hw0sbsfz4ZU+CxFVru/mtGYpDj6S5fPQgzMKFVyy9NeybCYQPZHk9dOIPAoTW7L11rVvKRE5j+P30oc9DBJZsvTYuXMqETiM4vfWjUIMEFew89e6disRNorm99SNQAwPVK/y2bt3LBE0i+X115FDDBBTrvPau3gtEDOJ5PfYk0ULDlCt8tu8ei4PMIjj+duXSAsMTarx3L56Lw8vhOP53JlKCwxKqfLdvXwwDi2C4/vem0sKCkmo8t/AfTANK3/i/OCdTQoJRqbx4MKAMgwqfeL84p9PCwhEpfDhw4IzCyl74fzjoVELCEKk8OLEgzQLKHnh/OWhUgsIPqPv5MWENComeOL96KNTCwc9oe/lxoY1CSV24v3ppVQMBzug7+bHiDYJJHTi/eulVQ0GN5/u58iJNwkic+P+66dXDQY2nu7oyos3CSBx4v7tqVkOBTWd7enLjDgJH3Di/+2rWw4FNJL9gsdlS0dlWID/q1sOBTOS/4LHZUtHZViA/6tcDgQx9f46vMG0g/iuXQ4EMfX+OrzBtIP4r14PBC/0/j+xwbKC+bBfDwMu9P8/scGygvmxYBADLvP/Q6/BsYL6s2IRBC3y/0Suwbrt+RSjqz3JkcgTKK3x/0etx8OUEhUilELQrtAeKKrv/0erycuiDQgLaTniyOUxLajt/0eqzNe2BwEEfjHxw+k8Nqbq/0qpztunAQEGkyz/uOVFP6nn/FvP3P5q/9oIC5s9nnMUNJDS/8G44zN4VxiPw/Ds/38uYvbzGI5TFhVwwO6dOnUGTUb/PYFWEQhwv/ChQIYL/Fk3/0WKPBAEb8ABqEyGA/lWMvxJlDERAHPBBaxSgAL9VCj7TJ0qEgFzwgmwWHoC/1Ij+0+kIhQDc8MNsV11Av9TIP1SmxkVA3LEELJhcAT/Uh37Vp8SFwZyxRSzZmkF/1Ia/lineRcIcsUYtGpiBf9TF/5fpHEXCXLGG7ZvWwb/VBb/ZKlpGApwxx26dFQH/1MV/2muYBkMb8cfvXlNCP9WFP9ttFgZDW3HIL98Rgj/Stb9Km2yUhsObMgiwIE/CP9F3P0bbr9KHBBqySPBhzcJ/0Di/RBvxUIdEmnKJcWMMAr/O+f+CW/KOh4UZ8wnx5EpC/8y7f8Bb88yHhVlzCrKliIM/0Tz/59w1CofFmTNLM2aGg3/Pe///HHZICAXYs4u0J8TDv8v9gDxcNwYIhlgzi/SoxMP/yf4Ad9v3xAkGl7PMdSoSxL/OvsCw27jCCQcXNAy1q5CFP8z8AOpcOYAJh1a0TTasD0V/yvxBJlv6fgnHljRNdy2ORb/JPMFiW7s9CgfVtI33bozF/8f9QZ4bO/qKSBV0zjfwCwY/xr3B2lr8uAqIVPUOuDGJhn/FPgIWWrz1SshUtU74MsgGf8S+gg4Z/TLLCJr1TzhziCJMpT+AiVA/Fxr988tI2rVN+HPQBozk/sCKFD9YW3/4C8jatU15tZlHF2P+wYygP+YdPMzLyRp1TOc42AgfIT5BiWY+/l9CDswKWnUMjr0Mg0qcPkArP4Bhh9GL0g31jF7/mz4sS5MKvxaWPg6Li3WL8F7+dDtCDe+Mx5NeA1SLSDKCJfzBJXw0jMQVY8WSS83xmBXvhSDVxdW0GceHnbfH4dTE1LjaSYZ2OQVlFcLWeRsJRHh7gqhXQBi33QcCP36BrhkljgLPgwjEP0E0SxLvzkLy3h80wxsxkfYbdUGOw0O/sMZq4yOqMfD5hQyDQr8yxyhjIyoyM7tGS0LCPvRHqCLiqnL2vIbKQgH+tghn4qJqM3h9R4lCAb42iOeiYmoz+j4IR8GA/fcJZ2JiKjP7vogHwYC9d0nnImIqM7s/CEfBgH03SiciIiozuz9Ih8I');
        audio.play().catch(e => console.warn("Could not play alert sound:", e));
    } catch(e) {
        console.warn("Could not create alert sound:", e);
    }
}

// === Token/Authentication Management ===
function initGoogleApi() {
    console.log('Initializing Google Sign-In and GAPI client...');
    try {
        // Initialize token client
        STATE.tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CONFIG.CLIENT_ID,
            scope: CONFIG.SCOPES,
            callback: handleTokenResponse
        });

        // Load base GAPI client library
        gapi.load('client', async () => {
            console.log('GAPI client library loaded.');
            // Check for saved token
            checkSavedTokenAndProceed();
        });
    } catch (error) {
        handleApiInitError(error);
    }
}

async function checkSavedTokenAndProceed() {
    const savedToken = localStorage.getItem('gapi_token');
    if (savedToken) {
        const token = JSON.parse(savedToken);
        if (token?.access_token) {
            try {
                gapi.client.setToken(token);
                console.log("Using saved token.");
                await tokenObtained(token);
            } catch (e) {
                console.warn("Error setting saved token:", e);
                updateAuthUI();
                showAppContent();
            }
        } else {
            localStorage.removeItem('gapi_token');
            console.log("Saved token invalid or expired.");
            updateAuthUI();
            showAppContent();
        }
    } else {
        console.log("No saved token found.");
        updateAuthUI();
        showAppContent();
    }
}

function handleApiInitError(error) {
    console.error('API Initialization Error:', error);
    showImprovedNotification('error', 'API Load Error', `Failed to load Google services: ${error.message}`);
    updateAuthUI();
    showAppContent();
}

function handleAuthClick() {
    if (STATE.tokenClient) {
        showImprovedNotification('info', 'Signing In', 'Opening Google Sign-In...');
        STATE.tokenClient.requestAccessToken({ prompt: 'select_account' });
    } else {
        console.error('Token client not initialized.');
        showImprovedNotification('error', 'Authentication Error', 'Authentication service is not ready. Please try again later.');
    }
}

// Callback function after user grants or denies access
function handleTokenResponse(resp) {
    if (resp.error) {
        console.error('Token response error:', resp);
        let msg = `Authentication failed: ${resp.error}`;
        if (resp.error === 'popup_closed_by_user') msg = 'Sign-in cancelled by user.';
        if (resp.error === 'access_denied') msg = 'Access denied. Please grant permission to proceed.';
        showImprovedNotification('error', 'Authentication Error', msg);
        updateAuthUI();
        showAppContent();
        return;
    }
    
    console.log('Access token received.');
    localStorage.setItem('gapi_token', JSON.stringify(resp));

    // Ensure gapi.client is loaded before setting token
    if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined') {
        gapi.client.setToken(resp);
        tokenObtained(resp);
    } else {
        console.error("handleTokenResponse: gapi.client not ready when token received!");
        showImprovedNotification('error', 'Auth Error', 'Failed to process token immediately. Please try reloading.');
    }
}

// Called after token is successfully obtained
async function tokenObtained(token) {
    console.log("Token available, proceeding...");
    STATE.isSignedIn = true;
    
    // Fetch user info and update UI
    await fetchUserInfo(token);
    updateAuthUI();
    showAppContent();

    // Check for saved exam state for this user
    const loadedState = JSON.parse(localStorage.getItem(CONFIG.APP_STATE_KEY) || '{}');
    if (STATE.currentUser &&
        loadedState.currentUserEmail === STATE.currentUser.email &&
        loadedState.examEndTime &&
        Date.now() < loadedState.examEndTime) {
        console.log("Attempting to restore active exam session.");
        restoreAppState(loadedState);
    } else if (loadedState.currentUserEmail) {
        console.log("Saved state is invalid or expired for the current user.");
        localStorage.removeItem(CONFIG.APP_STATE_KEY);
        saveAppState();
    }
    
    startTokenRefresh();
}

// User info fetching with token
async function fetchUserInfo(tokenObject) {
    const accessToken = tokenObject?.access_token;

    if (!accessToken) {
        console.warn("fetchUserInfo called without a valid access token.");
        showImprovedNotification('error', 'Auth Error', 'Missing access token. Signing out.');
        handleSignoutClick();
        return;
    }

    console.log('Fetching user information...');
    try {
        const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
            headers: {
                'Authorization': `Bearer ${accessToken}`
            }
        });

        if (!response.ok) {
            if (response.status === 401) {
                console.warn("User Info fetch failed (401 - Unauthorized). Token might be invalid/expired.");
                showImprovedNotification('error', 'Auth Expired', 'Your session has expired. Please sign in again.');
                handleSignoutClick();
                return;
            }
            throw new Error(`(${response.status}) ${await response.text()}`);
        }

        const userInfo = await response.json();

        // Store user details
        STATE.currentUser = {
            id: userInfo.sub,
            name: userInfo.name || 'N/A',
            email: userInfo.email || 'N/A',
            picture: userInfo.picture || ''
        };
        console.log('User details fetched:', STATE.currentUser.email);
        
        // Update admin status
        STATE.isAdmin = CONFIG.ADMIN_EMAILS.includes(STATE.currentUser?.email);
        document.body.classList.toggle('is-admin', STATE.isAdmin);
        console.log(`User role: ${STATE.isAdmin ? 'ADMIN' : 'STUDENT'}`);

        // Update UI with user info
        if (DOM['student-name']) DOM['student-name'].value = STATE.currentUser.name;
        if (DOM['student-email']) DOM['student-email'].value = STATE.currentUser.email;
        if (DOM['user-avatar']) DOM['user-avatar'].src = STATE.currentUser.picture;
        if (DOM['user-name']) DOM['user-name'].textContent = STATE.currentUser.name;

        // Enable PIN input now that user is signed in
        if (DOM['exam-pin-input']) {
            DOM['exam-pin-input'].disabled = false;
        }

        // Re-evaluate load button state
        if (DOM['load-exam-btn']) {
            DOM['load-exam-btn'].disabled = DOM['exam-pin-input'].value.trim() === '' || !STATE.isOnline;
        }

    } catch (e) {
        console.error('Fetch user info error:', e);
        showImprovedNotification('error', 'User Info Error', `Could not get user details: ${e.message}. Please try signing in again.`);
        STATE.currentUser = null;
        updateAuthUI();
    }
}

// Sign out handler
function handleSignoutClick() {
    console.log("Signing out...");
    const token = localStorage.getItem('gapi_token');
    
    if (token) {
        const parsedToken = JSON.parse(token);
        if(parsedToken?.access_token && typeof google !== 'undefined' && google.accounts?.oauth2) {
            try {
                google.accounts.oauth2.revoke(parsedToken.access_token, () => console.log('Token revoked successfully.'));
            } catch (e) {
                console.warn("Error revoking token:", e);
            }
        }
    }
    
    // Clear token from gapi.client if it exists
    if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined') {
        try {
            gapi.client.setToken('');
        } catch(e) {
            console.warn("Error clearing gapi token on signout", e);
        }
    }
    
    // Clear stored tokens and state
    localStorage.removeItem('gapi_token');
    localStorage.removeItem(CONFIG.APP_STATE_KEY);

    // Reset application state
    STATE.isSignedIn = false;
    STATE.isAdmin = false;
    STATE.currentUser = null;
    STATE.examDetails = null;
    STATE.studentPINEntered = '';
    STATE.studentExamIdEntered = '';
    
    stopTimer();
    resetExamState();
    updateAuthUI();
    showImprovedNotification('info', 'Signed Out', 'You have been signed out.');
    
    // Clear all timers
    stopTokenRefresh();
    stopAutoSave();
    if (STATE.inactivityTimer) {
        clearTimeout(STATE.inactivityTimer);
        STATE.inactivityTimer = null;
    }
}

// Token refresh management
function startTokenRefresh() {
    stopTokenRefresh();
    
    console.log("Starting token refresh timer");
    STATE.tokenRefreshTimer = setInterval(() => {
        refreshTokenIfNeeded(false);
    }, CONFIG.TOKEN_REFRESH_INTERVAL);
}

function stopTokenRefresh() {
    if (STATE.tokenRefreshTimer) {
        clearInterval(STATE.tokenRefreshTimer);
        STATE.tokenRefreshTimer = null;
    }
}

async function refreshTokenIfNeeded(force = false) {
    if (!STATE.isSignedIn || !STATE.tokenClient) {
        console.log("Not refreshing token: not signed in or no tokenClient");
        return false;
    }

    const savedTokenStr = localStorage.getItem('gapi_token');
    if (!savedTokenStr) {
        console.log("No token to refresh");
        return false;
    }

    try {
        const savedToken = JSON.parse(savedTokenStr);
        let tokenAgeMs = Infinity; // Default to needing refresh if issued_at is invalid

        // ADDED: Check if issued_at exists and is a number
        if (typeof savedToken.issued_at === 'number') {
             tokenAgeMs = Date.now() - savedToken.issued_at;
        } else {
             console.warn("Token 'issued_at' timestamp missing or invalid. Assuming refresh is needed.");
             force = true; // Force refresh if timestamp is bad
        }

        // If forced or token is older than 40 minutes, refresh it
        const needsRefresh = force || tokenAgeMs > 40 * 60 * 1000; // 40 minutes

        if (needsRefresh) {
            console.log(`Token age: ${tokenAgeMs / 1000}s - Refreshing token...`);
            // Use requestAccessToken without prompt for silent refresh
            STATE.tokenClient.requestAccessToken({ prompt: '' });
            return true;
        } else {
            console.log(`Token age: ${tokenAgeMs / 1000}s - No refresh needed`);
            return false;
        }
    } catch (e) {
        console.error("Error checking/refreshing token:", e);
        return false;
    }
}

// === UI State Management ===
function showAppContent() {
    if (DOM['app-loading']) DOM['app-loading'].classList.add('hidden');
    if (DOM['main-container']) DOM['main-container'].classList.add('content-visible');
    console.log("App content shown.");
}

function updateYear() {
    if (DOM['currentYear']) {
        DOM['currentYear'].textContent = new Date().getFullYear();
    }
}

function resetExamState() {
    console.log("Resetting UI to initial state.");
    
    // Hide exam-related modules
    const modulesToHide = [
        'exam-start-module', 'exam-details-module', 
        'exam-questions-module', 'submission-confirmation-module',
        'student-exam-id-group'
    ];
    
    modulesToHide.forEach(id => {
        if (DOM[id]) DOM[id].classList.add('hidden');
    });

    // Show signin prompt
    if (DOM['signin-prompt-module']) {
        DOM['signin-prompt-module'].classList.remove('hidden');
    }

    // Reset input fields
    if (DOM['exam-pin-input']) {
        DOM['exam-pin-input'].value = '';
        DOM['exam-pin-input'].disabled = true;
    }
    if (DOM['student-exam-id-input']) DOM['student-exam-id-input'].value = '';
    if (DOM['student-name']) DOM['student-name'].value = '';
    if (DOM['student-email']) DOM['student-email'].value = '';

    // Reset buttons
    if (DOM['load-exam-btn']) {
        DOM['load-exam-btn'].disabled = true;
        DOM['load-exam-btn'].classList.remove('hidden');
        DOM['load-exam-btn'].innerHTML = '<i class="fas fa-download"></i> Load Exam';
    }
    if (DOM['start-exam-btn']) DOM['start-exam-btn'].disabled = true;
    if (DOM['start-exam-btn-alt']) {
        DOM['start-exam-btn-alt'].classList.add('hidden');
        DOM['start-exam-btn-alt'].disabled = true;
    }
    if (DOM['submit-exam-btn']) {
        DOM['submit-exam-btn'].disabled = true;
        DOM['submit-exam-btn'].innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)';
    }

    // Reset displays
    const na = 'N/A';
    const displays = {
        'exam-code-display': na,
        'exam-duration-display': na,
        'exam-start-time-display': na,
        'exam-name-header': 'Please sign in to load the exam',
        'exam-name-detail': '',
        'exam-course-code-detail': '',
        'exam-mode-detail': '',
        'exam-duration-detail': '',
        'exam-start-time-detail': ''
    };
    
    Object.entries(displays).forEach(([id, value]) => {
        if (DOM[id]) DOM[id].textContent = value;
    });

    // Clear questions and timer
    if (DOM['exam-questions-area']) {
        DOM['exam-questions-area'].innerHTML = '<p>Exam questions will appear here...</p>';
    }
    stopTimer();
    if (DOM['timer-display']) DOM['timer-display'].textContent = '--:--';

    // Reset counters
    STATE.totalQuestions = 0;
    STATE.confirmedQuestionsCount = 0;
}

function updateAuthUI() {
    console.log('Updating Auth UI - SignedIn:', STATE.isSignedIn, 'CurrentUser:', !!STATE.currentUser);
    document.body.classList.toggle('is-admin', STATE.isAdmin);

    if (STATE.isSignedIn && STATE.currentUser) {
        // Logged-in state
        console.log('Showing logged-in UI.');
        DOM['login-container'].style.display = 'none';
        DOM['user-container'].style.display = 'flex';
        DOM['signin-prompt-module'].classList.add('hidden');

        // Show exam start module if no exam is active
        if (DOM['exam-start-module'] && !STATE.examDetails && 
            DOM['exam-questions-module'].classList.contains('hidden')) {
            DOM['exam-start-module'].classList.remove('hidden');
        }

        // Enable inputs
        if (DOM['exam-pin-input']) DOM['exam-pin-input'].disabled = false;
        if (DOM['load-exam-btn']) {
            DOM['load-exam-btn'].disabled = DOM['exam-pin-input'].value.trim() === '' || !STATE.isOnline;
        }

        // Populate user details
        if (DOM['student-name']) DOM['student-name'].value = STATE.currentUser.name || 'N/A';
        if (DOM['student-email']) DOM['student-email'].value = STATE.currentUser.email || 'N/A';
        if (DOM['user-name']) DOM['user-name'].textContent = STATE.currentUser.name || '';
        if (DOM['user-avatar']) DOM['user-avatar'].src = STATE.currentUser.picture || '';
    } else {
        // Logged-out state
        console.log('Showing logged-out UI.');
        DOM['login-container'].style.display = 'flex';
        DOM['user-container'].style.display = 'none';
        resetExamState();
        DOM['signin-prompt-module'].classList.remove('hidden');
    }
}

// === Exam Handling ===
async function handleLoadExam() {
    STATE.studentPINEntered = DOM['exam-pin-input'].value.trim();
    if (!STATE.studentPINEntered) {
        showImprovedNotification('warning', 'Missing PIN', 'Please Get your Exam ID from the attendance sheet.');
        return;
    }
    
    DOM['load-exam-btn'].disabled = true;
    DOM['load-exam-btn'].innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';

    await fetchExamDetails(STATE.studentPINEntered);

    DOM['load-exam-btn'].disabled = false;
    DOM['load-exam-btn'].innerHTML = '<i class="fas fa-download"></i> Load Exam';

    if (DOM['start-exam-btn']) DOM['start-exam-btn'].disabled = !STATE.examDetails || !STATE.isOnline;
    if (DOM['start-exam-btn-alt']) DOM['start-exam-btn-alt'].disabled = !STATE.examDetails || !STATE.isOnline;
}

async function fetchExamDetails(pin) {
    showImprovedNotification('info', 'Fetching Exam', `Loading details for PIN: ${pin}...`);
    setSyncing(true);

    STATE.examDetails = null;
    STATE.examEndTime = null;

    try {
        const fetchUrl = `${CONFIG.BACKEND_URL}?pin=${encodeURIComponent(pin)}&action=getDetails`;
        console.log(`Fetching exam details from backend: ${fetchUrl}`);

        const response = await fetch(fetchUrl);
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const result = await response.json();
        console.log("Backend response (Exam Details):", result);

        if (result.success && result.examData) {
            const fetchedData = result.examData;
            const shuffleQuestions = String(fetchedData.ShuffleQuestions || 'yes').trim().toLowerCase();

            // Validate data
            const duration = parseInt(fetchedData.Duration, 10);
            const startTimestampUTC = fetchedData.StartTimestampUTC;
            const mode = String(fetchedData.Mode || 'Quiz').trim().toLowerCase();
            const questionsJson = String(fetchedData.Questions || '[]').trim();
            const startDateStr = String(fetchedData.StartDate || '').trim();
            const startTimeStr = String(fetchedData.StartTime || '').trim();

            if (isNaN(duration) || duration <= 0) {
                throw new Error("Invalid exam duration received from backend.");
            }
            if (typeof startTimestampUTC !== 'number' || isNaN(startTimestampUTC)) {
                throw new Error("Invalid StartTimestampUTC received from backend.");
            }
            
            // Basic JSON check for questions
            try {
                JSON.parse(questionsJson);
            } catch (e) {
                throw new Error(`Invalid questions JSON received: ${e.message}`);
            }

            // Calculate exam end time
            try {
                const startTimeFromSheet = startTimestampUTC;
                const durationMillis = duration * 60 * 1000;
                STATE.examEndTime = startTimeFromSheet + durationMillis;

                console.log(`[TIMER CALC] StartDate: ${startDateStr}, StartTime: ${startTimeStr}, ` +
                           `Received Start TS (UTC ms): ${startTimeFromSheet}, ` +
                           `Duration(ms): ${durationMillis}, ` +
                           `Calculated End TS (UTC ms): ${STATE.examEndTime} ` +
                           `(${new Date(STATE.examEndTime).toLocaleString()})`);
            } catch (e) {
                throw new Error(`Could not calculate exam end time: ${e.message}`);
            }

            // Store the loaded exam details
            STATE.examDetails = {
                PIN: fetchedData.PIN,
                Code: fetchedData.Code,
                Name: fetchedData.Name,
                Duration: duration,
                StartDate: startDateStr,
                StartTime: startTimeStr,
                Mode: mode,
                Questions: questionsJson,
                OriginalOrderMap: null,
                StartTimestampUTC: startTimestampUTC,
                shuffleQuestions: shuffleQuestions
            };
            
            console.log("Exam details processed successfully:", STATE.examDetails);

            displayExamDetailsHeader();
            showImprovedNotification('success', 'Exam Loaded', `Details for "${STATE.examDetails.Name}" loaded successfully.`);

            // Adjust UI based on exam mode
            if (STATE.examDetails.Mode === 'exam') {
                console.log("Exam Mode detected: Showing Student Exam ID input.");
                DOM['exam-start-module'].classList.remove('hidden');
                DOM['student-exam-id-group'].classList.remove('hidden');
                DOM['student-exam-id-input'].value = '';
                DOM['exam-details-module'].classList.add('hidden');
                DOM['start-exam-btn-alt'].classList.remove('hidden');
                DOM['start-exam-btn'].classList.add('hidden');
                DOM['start-exam-btn'].disabled = true;
                DOM['load-exam-btn'].classList.add('hidden');
                validateStudentExamIdInput();
            } else {
                // Quiz Mode
                console.log("Quiz Mode detected: Showing Exam Information module.");
                DOM['student-exam-id-group'].classList.add('hidden');
                DOM['student-exam-id-input'].value = '';
                STATE.studentExamIdEntered = '';
                DOM['exam-start-module'].classList.add('hidden');
                displayExamDetailsFull();
                DOM['exam-details-module'].classList.remove('hidden');
                DOM['start-exam-btn-alt'].classList.add('hidden');
                DOM['start-exam-btn'].classList.remove('hidden');
                DOM['start-exam-btn'].disabled = !STATE.isOnline;
                DOM['load-exam-btn'].disabled = true;
                DOM['load-exam-btn'].classList.remove('hidden');
            }
            
            saveAppState();
        } else {
            throw new Error(result.message || "Exam details not found or backend error.");
        }
    } catch (error) {
        console.error(`Error fetching/processing exam details for PIN ${pin}:`, error);
        showImprovedNotification('error', 'Exam Load Failed', `Could not load exam: ${error.message}`);
        STATE.examDetails = null;
        
        // Reset UI
        DOM['exam-details-module'].classList.add('hidden');
        DOM['exam-start-module'].classList.remove('hidden');
        if (DOM['load-exam-btn']) DOM['load-exam-btn'].disabled = !STATE.isOnline;
        resetExamState();
    } finally {
        setSyncing(false);
    }
}

// Validates the Student Exam ID input for Exam mode
function validateStudentExamIdInput() {
    const startButtonToUse = DOM['start-exam-btn-alt'];
    
    if (!startButtonToUse || !DOM['student-exam-id-input'] || 
        !STATE.examDetails || STATE.examDetails.Mode !== 'exam') return;

    const idValue = DOM['student-exam-id-input'].value.trim();
    const isValid = idValue.length === 5;

    // Enable/disable button based on validity
    startButtonToUse.disabled = !isValid || !STATE.isOnline;

    // Visual feedback
    DOM['student-exam-id-input'].style.borderColor = (isValid || idValue === '') ? '#ccc' : 'red';
}

// Updates the header with exam details
function displayExamDetailsHeader() {
    if (!STATE.examDetails) return;
    
    if (DOM['exam-code-display']) {
        DOM['exam-code-display'].textContent = STATE.examDetails.Code || 'N/A';
    }
    
    if (DOM['exam-duration-display']) {
        DOM['exam-duration-display'].textContent = `${STATE.examDetails.Duration} minutes`;
    }
    
    const startTimeString = `${STATE.examDetails.StartDate || ''} ${STATE.examDetails.StartTime || ''}`.trim();
    if (DOM['exam-start-time-display']) {
        DOM['exam-start-time-display'].textContent = startTimeString || 'N/A';
    }
    
    if (DOM['exam-name-header']) {
        DOM['exam-name-header'].textContent = STATE.examDetails.Name || 'Exam Loaded';
    }
}

// Populates the "Exam Information" module (Quiz mode)
function displayExamDetailsFull() {
    if (!STATE.examDetails) return;
    
    if (DOM['exam-name-detail']) {
        DOM['exam-name-detail'].textContent = STATE.examDetails.Name || 'N/A';
    }
    
    if (DOM['exam-course-code-detail']) {
        DOM['exam-course-code-detail'].textContent = STATE.examDetails.Code || 'N/A';
    }
    
    // Capitalize mode for display
    const displayMode = STATE.examDetails.Mode ? 
                      (STATE.examDetails.Mode.charAt(0).toUpperCase() + 
                       STATE.examDetails.Mode.slice(1)) : 'N/A';
    
    if (DOM['exam-mode-detail']) {
        DOM['exam-mode-detail'].textContent = displayMode;
    }
    
    if (DOM['exam-duration-detail']) {
        DOM['exam-duration-detail'].textContent = `${STATE.examDetails.Duration} minutes`;
    }
    
    const startTimeString = `${STATE.examDetails.StartDate || ''} ${STATE.examDetails.StartTime || ''}`.trim();
    if (DOM['exam-start-time-detail']) {
        DOM['exam-start-time-detail'].textContent = startTimeString || 'N/A';
    }
}

// Starts the exam
async function handleStartExam() {
    if (!STATE.examDetails || !STATE.currentUser) {
        showImprovedNotification('error', 'Start Error', 'Cannot start the exam. User or exam details are missing.');
        return;
    }

    const currentMode = STATE.examDetails.Mode.toLowerCase();
    let identifierForCheck = null;

    // Validate Student Exam ID for Exam mode
    if (currentMode === 'exam') {
        const currentStudentExamId = DOM['student-exam-id-input'].value.trim();
        if (currentStudentExamId.length !== 5) {
            showImprovedNotification('error', 'Invalid ID', 'Please enter the 5-character Student Exam ID.');
            DOM['student-exam-id-input'].focus();
            return;
        }
        STATE.studentExamIdEntered = currentStudentExamId;
        identifierForCheck = STATE.studentExamIdEntered;
        console.log(`Exam Mode: Using StudentExamID '${identifierForCheck}' for existence check.`);
    } else {
        // Quiz mode: Use email
        STATE.studentExamIdEntered = '';
        identifierForCheck = STATE.currentUser.email;
        console.log(`Quiz Mode: Using Email '${identifierForCheck}' for existence check.`);
    }

    console.log("Performing pre-start checks...");

    // Check if already submitted
    const alreadySubmitted = await checkIfAttemptExists(
        STATE.currentUser.email,
        STATE.examDetails.PIN,
        identifierForCheck,
        currentMode
    );
    
    if (alreadySubmitted) {
        showImprovedNotification('error', 'Already Submitted', `This exam (${STATE.examDetails.PIN}) has already been submitted and cannot be retaken.`, 0);
        if (DOM['start-exam-btn']) DOM['start-exam-btn'].disabled = true;
        if (DOM['start-exam-btn-alt']) DOM['start-exam-btn-alt'].disabled = true;
        return;
    }

    // Check exam timing
    try {
        const startTimestampUTC = STATE.examDetails.StartTimestampUTC;
        if (!startTimestampUTC || isNaN(startTimestampUTC)) {
            throw new Error("Start timestamp missing or invalid.");
        }
        const startTime = startTimestampUTC;

        if (Date.now() < startTime) {
            showImprovedNotification('error', 'Exam Not Yet Available', `This exam is scheduled to start at ${new Date(startTime).toLocaleString()}. Please wait.`);
            return;
        }
        
        if (!STATE.examEndTime || isNaN(STATE.examEndTime)) {
            throw new Error("Could not determine the exam end time.");
        }
        
        if (Date.now() >= STATE.examEndTime) {
            showImprovedNotification('error', 'Exam Deadline Passed', `The deadline (${new Date(STATE.examEndTime).toLocaleString()}) for starting or resuming this exam has passed.`, 0);
            return;
        }
    } catch (e) {
        console.error("Exam timing check error:", e);
        showImprovedNotification('warning', 'Timing Check Warning', `Could not fully verify exam timing: ${e.message}. Proceeding cautiously.`);
    }

    // Proceed to show questions
    console.log(`Starting ${currentMode} mode. PIN: ${STATE.examDetails.PIN}` + 
               (currentMode === 'exam' ? `, Student Exam ID: ${STATE.studentExamIdEntered}` : ''));
    
    STATE.confirmedQuestionsCount = 0;
    DOM['exam-start-module'].classList.add('hidden');
    DOM['exam-details-module'].classList.add('hidden');
    DOM['exam-questions-module'].classList.remove('hidden');
    DOM['submission-confirmation-module'].classList.add('hidden');
    
    displayQuestions(STATE.examDetails.Questions);
	updateExamModeClass();
    startTimer();
    saveAppState();
    checkAllConfirmed();
    stopAutoSave();
    startAutoSave();
}

// Check if attempt exists
async function checkIfAttemptExists(email, pin, studentExamId, mode) {
    console.log("Checking backend for existing 'submit' record...");
    setSyncing(true);
    
    try {
        // Construct URL parameters
        const params = new URLSearchParams({
            action: 'checkExists',
            pin: pin,
            mode: mode
        });
        
        if (mode === 'quiz') {
            params.append('email', email);
        } else if (mode === 'exam') {
            params.append('studentExamId', studentExamId);
        }

        const fetchUrl = `${CONFIG.BACKEND_URL}?${params.toString()}`;
        console.log(`Checking existence via backend: ${fetchUrl}`);

        const response = await fetch(fetchUrl, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) {
            let errorMsg = `Backend check error! Status: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg = errorData.message || errorMsg;
            } catch (e) {}
            throw new Error(errorMsg);
        }

        const result = await response.json();
        console.log("Backend check response:", result);

        if (result.success) {
            return result.exists;
        } else {
            throw new Error(result.message || "Backend error during existence check.");
        }
    } catch (error) {
        console.error('Error checking submission existence via backend:', error);
        showImprovedNotification('error', 'Check Failed', `Could not verify previous submissions: ${error.message}. Assuming none exist.`);
        return false;
    } finally {
        setSyncing(false);
    }
}

// === Display Questions ===
// === Display Questions ===
// MODIFIED: Added async and returns a Promise
async function displayQuestions(questionsJsonString) {
    console.log("Parsing and displaying exam questions...");
    DOM['exam-questions-area'].innerHTML = '';
    STATE.totalQuestions = 0;
    STATE.codeEditors = {}; // Reset code editors state

    // Return a Promise that resolves after rendering and editor init attempt
    return new Promise((resolve, reject) => {
        try {
            let questionsArray = [];
            try {
                questionsArray = JSON.parse(questionsJsonString);
                if (!Array.isArray(questionsArray)) {
                    throw new Error("Parsed data is not an array.");
                }
            } catch (parseError) {
                console.warn("Could not parse questions JSON. Displaying as a single block.", parseError);
                questionsArray = [{
                    type: "text_only", // Treat as text_only if JSON invalid
                    prompt: "Exam Instructions / Questions",
                    content: questionsJsonString // Show raw content
                }];
            }

            STATE.totalQuestions = questionsArray.length;
            console.log(`Total questions loaded: ${STATE.totalQuestions}`);

            // --- Shuffle Logic (as before) ---
            const shuffleSetting = String(STATE.examDetails?.shuffleQuestions || 'yes').trim().toLowerCase();
            const shuffleDisabled = ['no', 'false', '0'].includes(shuffleSetting);
            const skipShuffle = Boolean(STATE.isAdmin) || shuffleDisabled;
            console.log(`Shuffle Setting: ${shuffleSetting}, Skip Shuffle: ${skipShuffle}`);
            const seed = hashString(STATE.currentUser?.email || Date.now().toString());
            const originalIndices = Array.from(questionsArray.keys());
            const displayIndices = skipShuffle
                ? originalIndices
                : seededShuffle(originalIndices.slice(), seed);
            console.log("Display order:", displayIndices);

            // --- Create Mapping (as before) ---
            STATE.examDetails.OriginalOrderMap = {};
            questionsArray.forEach((q, index) => {
                STATE.examDetails.OriginalOrderMap[index] = q;
            });

            // Reset confirmed count before rendering
            STATE.confirmedQuestionsCount = 0;

            // --- Display Questions Loop (as before) ---
            displayIndices.forEach((originalIndex, displayIndex) => {
                const q = questionsArray[originalIndex];
                if (!q) {
                    console.warn(`Question data missing for original index ${originalIndex}`);
                    return; // Skip if question data is somehow missing
                }
                const displayQNum = displayIndex + 1;
                const originalQNum = originalIndex + 1;
                const questionId = `q-${originalQNum}`;
                const answerId = `ans-${originalQNum}`; // Used as input ID/Name
                const answerName = `ans-${originalQNum}`;

                const questionDiv = document.createElement('div');
                questionDiv.className = 'question form-group';
                if (q.type === 'text_only') {
                    questionDiv.className = 'question form-group text-only-question';
                }
                questionDiv.id = questionId;
                questionDiv.dataset.originalIndex = originalIndex;
                questionDiv.dataset.displayIndex = displayIndex;

                // --- Process Prompt & Formatting (as before) ---
                let promptText = q.prompt || `Question`;
                promptText = escapeHtml(promptText);
                let questionLabel = `Question ${displayQNum}`;
                if (q.points && q.type !== 'text_only') {
                     questionLabel += ` (${q.points} ${q.points == 1 ? 'point' : 'points'})`;
                }
                questionLabel += ": ";
                if (q.type !== 'text_only') {
                     promptText = `<strong>${questionLabel}</strong>${promptText}`;
                }
                promptText = processPromptFormatting(promptText); // Apply term highlighting etc.


                let questionContentHtml = '<div class="question-content">';
                let labelClass = '';
                let labelTag = 'label';
                if (q.type === 'text_only') {
                    labelTag = 'div';
                    labelClass = 'text-content';
                } else if (q.type === 'code') {
                    // The main prompt goes in the label/div above the editor
                    // labelClass remains default here, input generated below
                }

                // Generate input HTML based on question type
                questionContentHtml += generateQuestionInput(q, answerId, answerName, skipShuffle, seed, originalIndex);
                questionContentHtml += '</div>'; // End question-content

                // Add confirm/edit actions - not for text_only type
                let actionsHtml = '';
                if (q.type !== 'text_only') {
                    actionsHtml = `
                        <div class="question-actions">
                            <button type="button" class="btn-sm btn-confirm" onclick="confirmAnswer('${questionId}')">
                                <i class="fas fa-check"></i> Confirm
                            </button>
                            <button type="button" class="btn-sm btn-edit" onclick="editAnswer('${questionId}')">
                                <i class="fas fa-pencil-alt"></i> Edit
                            </button>
                        </div>
                    `;
                }

                // Target the input ID for the label's 'for' attribute
                const labelTargetId = (q.type !== 'text_only' && q.type !== 'multiple_select') ? answerId : '';
                questionDiv.innerHTML = `<${labelTag} ${labelTargetId ? `for="${labelTargetId}"` : ''} class="${labelClass}">${promptText}</${labelTag}>${questionContentHtml}${actionsHtml}`;

                DOM['exam-questions-area'].appendChild(questionDiv);

                // Mark text_only as confirmed automatically and count it
                if (q.type === 'text_only') {
                    STATE.confirmedQuestionsCount++;
                    questionDiv.classList.add('confirmed', 'text-only-confirmed');
                }
            }); // End displayIndices.forEach

            // --- Initialize Code Editors and Resolve Promise ---
            // Use setTimeout to allow DOM to update before initializing editors
            setTimeout(() => {
                try {
                    const codeTextareas = document.querySelectorAll('.code-editor');
                    codeTextareas.forEach(textarea => {
                        initializeCodeEditor(textarea.id, 'python'); // Assumes Python, adjust if needed
                    });
                    enhanceExamUI(); // Apply other UI enhancements
                    checkAllConfirmed(); // Update submit button state based on initial render
                    console.log("Questions displayed and editors initialized.");
                    resolve(); // Resolve the promise successfully
                } catch(editorError) {
                     console.error("Error during post-render enhancements:", editorError);
                     reject(editorError); // Reject the promise if enhancements fail
                }
            }, 100); // Short delay for DOM update

        } catch (e) {
            console.error("Error displaying questions:", e);
            DOM['exam-questions-area'].innerHTML = '<p>Error loading questions.</p>';
            reject(e); // Reject the promise on primary error
        }
    }); // End Promise constructor
}

// Helper function to process prompt text formatting
function processPromptFormatting(promptText) {
    // Process formatting
    promptText = promptText.replace(/\*\*\*(.*?)\*\*\*/g, '<strong>$1</strong>');
    promptText = promptText.replace(/(?<!\*)\*\*(?!\*)(.*?)\*\*(?!\*)/g, '<strong>$1</strong>');
    
    // Process special terms
    const termsToEmphasise = ['sep', 'end', 'print()', 'input()', 'range\\(5\\)', 
                              'range\\(2, 8, 2\\)', 'TypeError', 'IDE'];
    
    termsToEmphasise.forEach(term => {
        const termForRegex = (term.includes('\\(')) ? term : term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(`(?<![=\\"'>])(\\b${termForRegex}\\b)(?![<\\(\\"'])`, 'g');
        promptText = promptText.replace(regex, (match) => `<em class="term">${match}</em>`);
    });
    
    // Additional replacements
    const replacements = {
        'print\'Hello World\'': () => '<em class="term">print\'Hello World\'</em>',
        'x = 5 \\+ \'3\'': () => '<em class="term">x = 5 + \'3\'</em>',
        'print\\("Value:", value, sep = \':\'\\)': () => '<em class="term">print("Value:", value, sep = \':\')</em>',
        'print\\(My variable is, x\\)': () => '<em class="term">print(My variable is, x)</em>',
        '"My variable is"': () => '<em class="term">"My variable is"</em>'
    };
    
    Object.entries(replacements).forEach(([pattern, replacer]) => {
        promptText = promptText.replace(new RegExp(pattern, 'g'), replacer);
    });
    
    // Handle newlines
    promptText = promptText.replace(/\n/g, '<br>');
    
    return promptText;
}

// Generate input HTML based on question type
function generateQuestionInput(question, answerId, answerName, skipShuffle, seed, originalIndex) {
    let html = '';
    
    switch (question.type) {
        case 'text_only':
            html += `<div class="text-only-content"></div>`;
            break;
            
        case 'short_answer':
            html += `<input type="text" id="${answerId}" name="${answerName}" class="form-control" placeholder="Enter your answer">`;
            break;
            
        case 'long_answer':
            html += `<textarea id="${answerId}" name="${answerName}" class="form-control" rows="5" placeholder="Enter your detailed answer">${escapeHtml(question.content || '')}</textarea>`;
            break;
            
        case 'code':
            html += `<textarea id="${answerId}" name="${answerName}" class="form-control code-editor" rows="8" placeholder="Enter your code">${escapeHtml(question.content || '')}</textarea>`;
            break;
            
        case 'attachment':
            html += `<input type="file" id="${answerId}" name="${answerName}" class="form-control">`;
            break;
            
        case 'multiple_select':
            html += `<div class="checkbox-group" id="${answerId}">`;
            
            if (Array.isArray(question.options) && question.options.length > 0) {
                // Store original options
                question.originalOptions = [...question.options];
                
                // Shuffle options for students
                const optionIndices = [...Array(question.options.length).keys()];
                const shuffledOptionIndices = skipShuffle ? 
                    [...optionIndices] : 
                    seededShuffle(optionIndices, seed + originalIndex);
                    
                // Store shuffle mapping
                question.shuffledOptionIndices = shuffledOptionIndices;
                
                // Render options in shuffled order
                shuffledOptionIndices.forEach((originalOptIndex, displayOptIndex) => {
                    const option = question.options[originalOptIndex];
                    const optionId = `${answerId}-opt${originalOptIndex}`;
                    const escapedOption = escapeHtml(option);
                    
                    html += `<div class="checkbox-item">
                        <input type="radio" id="${optionId}" name="${answerName}" 
                            value="${escapedOption}" class="form-control-checkbox" 
                            data-original-index="${originalOptIndex}">
                        <label for="${optionId}">${escapedOption}</label>
                    </div>`;
                });
            } else {
                html += `<p style="color:red;">Error: Options missing or empty.</p>`;
            }
            html += `</div>`;
            break;
            
        default:
            html += `<p>${escapeHtml(question.content || '')}</p>`;
            break;
    }
    
    return html;
}

// Initialize CodeMirror editor
function initializeCodeEditor(textareaId, language = 'python') {
    const textarea = document.getElementById(textareaId);
    if (!textarea) {
        console.warn(`Cannot initialize code editor: textarea #${textareaId} not found`);
        return null;
    }
    
    if (typeof CodeMirror === 'undefined') {
        console.warn('CodeMirror library not loaded. Using regular textarea.');
        return null;
    }
    
    console.log(`Initializing code editor for ${textareaId} with language ${language}`);
    
    try {
        // Initialize CodeMirror
        const editor = CodeMirror.fromTextArea(textarea, {
            mode: language || "python",
            theme: "monokai",
            lineNumbers: true,
            indentUnit: 4,
            tabSize: 4,
            indentWithTabs: false,
            matchBrackets: true,
            autoCloseBrackets: true,
            lineWrapping: true,
            extraKeys: {
                "Tab": function(cm) {
                    if (cm.somethingSelected()) {
                        cm.indentSelection("add");
                    } else {
                        cm.replaceSelection("    ", "end");
                    }
                }
            }
        });
        
        // Make the editor taller
        editor.setSize(null, 150);
        
        // Store the editor instance
        STATE.codeEditors[textareaId] = editor;
        console.log(`Code editor initialized for ${textareaId}`);
        
        return editor;
    } catch (e) {
        console.error(`Error initializing CodeMirror for ${textareaId}:`, e);
        textarea.style.display = 'block';
        return null;
    }
}

// UI enhancements after questions are displayed
function enhanceExamUI() {
    // Add points badges to questions
    enhancePointLabels();
    
    // Add syntax highlighting for Python code
    highlightPythonKeywords();
    
    // Add in-exam class when exam is active
    updateExamModeClass();
    
    // Make multiple choice options more responsive
    adjustMultipleChoiceLayout();
}

function enhancePointLabels() {
    const questionLabels = document.querySelectorAll('#exam-questions-area .question > label');
    questionLabels.forEach(label => {
        const labelText = label.innerHTML;
        const pointsMatch = labelText.match(/\((\d+)\s+points?\)/i);
        
        if (pointsMatch && pointsMatch[1]) {
            const points = pointsMatch[1];
            const pointsText = points === "1" ? "point" : "points";
            
            // Create points badge
            const pointsBadge = document.createElement('span');
            pointsBadge.className = 'question-points';
            pointsBadge.innerHTML = `${points} ${pointsText}`;
            
            // Add badge to label
            label.appendChild(pointsBadge);
            
            // Remove points from text
            label.innerHTML = label.innerHTML.replace(/\s*\(\d+\s+points?\)/i, '');
        }
    });
}

function highlightPythonKeywords() {
    const codeElements = document.querySelectorAll('#exam-questions-area .code-prompt, #exam-questions-area em.term');
    
    const pythonKeywords = ['if', 'else', 'elif', 'while', 'for', 'in', 'def', 'return', 'class', 
                          'import', 'from', 'as', 'try', 'except', 'finally', 'with', 'pass', 
                          'break', 'continue', 'and', 'or', 'not', 'is', 'None', 'True', 'False', 
                          'lambda', 'yield', 'assert', 'del', 'global', 'nonlocal', 'raise'];
    
    const pythonBuiltins = ['print', 'input', 'len', 'range', 'str', 'int', 'float', 'list', 'dict', 
                          'set', 'tuple', 'sum', 'min', 'max', 'sorted', 'type', 'open', 'file', 
                          'enumerate', 'zip', 'map', 'filter', 'any', 'all', 'iter', 'next', 'sep', 'end'];
    
    codeElements.forEach(element => {
        let html = element.innerHTML;
        
        // Highlight keywords
        pythonKeywords.forEach(keyword => {
            const regex = new RegExp(`\\b(${keyword})\\b`, 'g');
            html = html.replace(regex, '<span class="py-keyword">$1</span>');
        });
        
        // Highlight builtins
        pythonBuiltins.forEach(builtin => {
            const regex = new RegExp(`\\b(${builtin})\\b`, 'g');
            html = html.replace(regex, '<span class="py-builtin">$1</span>');
        });
        
        // Highlight function calls
        html = html.replace(/\b(\w+)\s*\(/g, '<span class="py-function">$1</span>(');
        
        // Highlight strings
        html = html.replace(/"([^"]*)"/g, '"<span class="py-string">$1</span>"');
        html = html.replace(/'([^']*)'/g, "'<span class=\"py-string\">$1</span>'");
        
        // Highlight numbers
        html = html.replace(/\b(\d+)\b/g, '<span class="py-number">$1</span>');
        
        element.innerHTML = html;
    });
}

function updateExamModeClass() {
    if (DOM['exam-questions-module'] && !DOM['exam-questions-module'].classList.contains('hidden')) {
        document.body.classList.add('in-exam');
    } else {
        document.body.classList.remove('in-exam');
    }
}

function adjustMultipleChoiceLayout() {
    const checkboxGroups = document.querySelectorAll('#exam-questions-area .checkbox-group');
    
    checkboxGroups.forEach(group => {
        const items = group.querySelectorAll('.checkbox-item');
        const count = items.length;
        
        // Adjust flex-basis based on number of items
        if (count <= 2) {
            items.forEach(item => {
                item.style.flexBasis = '48%';
                item.style.minWidth = '180px';
            });
        } else if (count <= 4) {
            items.forEach(item => {
                item.style.flexBasis = '23%';
                item.style.minWidth = '150px';
            });
        }
    });
}

// Function to create sticky timer
function createStickyTimer() {
    // Remove any existing sticky timer
    const existingTimer = document.querySelector('.sticky-timer');
    if (existingTimer) existingTimer.remove();
    
    // Create new sticky timer
    const stickyTimer = document.createElement('div');
    stickyTimer.className = 'sticky-timer';
    stickyTimer.innerHTML = `<i class="fas fa-stopwatch"></i> <span id="sticky-timer-display">--:--</span>`;
    document.body.appendChild(stickyTimer);
    
    return stickyTimer;
}

// Starts the countdown timer
function startTimer() {
    if (STATE.examTimerInterval) {
        console.warn("Timer is already running.");
        return;
    }
    
    if (!STATE.examEndTime || isNaN(STATE.examEndTime) || STATE.examEndTime <= Date.now()) {
        console.error("Cannot start timer: Invalid or past exam end time.", STATE.examEndTime);
        if (DOM['timer-display']) DOM['timer-display'].textContent = "Error";
        
        if (STATE.examEndTime && STATE.examEndTime <= Date.now()) {
            showImprovedNotification('error', 'Deadline Passed', 'The time for this exam has already expired.', 0);
            handleSubmitExam(true);
        }
        return;
    }
    
    // Create sticky timer
    createStickyTimer();
    
    console.log(`Timer starting. Target end time: ${new Date(STATE.examEndTime).toLocaleString()}`);
    updateTimerDisplay();
    STATE.examTimerInterval = setInterval(updateTimerDisplay, 1000);
}

// Updates the timer display
function updateTimerDisplay() {
    if (!STATE.examEndTime) {
        console.warn("Timer update called without a valid end time.");
        stopTimer();
        
        if (DOM['timer-display']) DOM['timer-display'].textContent = "--:--";
        const stickyDisplay = document.getElementById('sticky-timer-display');
        if (stickyDisplay) stickyDisplay.textContent = "--:--";
        return;
    }

    const now = Date.now();
    const timeLeft = Math.max(0, STATE.examEndTime - now);
    const minutesLeft = Math.floor(timeLeft / (1000 * 60));
    const seconds = Math.floor((timeLeft / 1000) % 60);
    const timeString = `${String(minutesLeft).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

    // Update both displays
    if (DOM['timer-display']) DOM['timer-display'].textContent = timeString;
    const stickyDisplay = document.getElementById('sticky-timer-display');
    if (stickyDisplay) stickyDisplay.textContent = timeString;
    
    // Update visual cues
    updateTimeVisualCues(minutesLeft, seconds, timeLeft);
    
    // Check if time is up
    if (timeLeft <= 0) {
        console.log("Exam time has expired!");
        stopTimer();
        showImprovedNotification('warning', "Time's Up!", 'The exam time has expired. Submitting automatically.', 0);
        handleSubmitExam(true);
    }
}

function updateTimeVisualCues(minutesLeft, seconds, timeLeft) {
    const stickyTimer = document.querySelector('.sticky-timer');
    
    if (timeLeft <= 0) {
        // Time's up
        document.body.classList.remove('time-warning', 'time-danger');
        document.body.classList.add('time-expired');
        if (stickyTimer) {
            stickyTimer.classList.remove('warning', 'danger');
            stickyTimer.classList.add('expired');
        }
    } else if (minutesLeft <= 5) {
        // Danger - 5 minutes or less
        document.body.classList.remove('time-warning');
        document.body.classList.add('time-danger');
        if (stickyTimer) {
            stickyTimer.classList.remove('warning');
            stickyTimer.classList.add('danger');
        }
    } else if (minutesLeft <= 10) {
        // Warning - 10 minutes or less
        document.body.classList.add('time-warning');
        document.body.classList.remove('time-danger');
        if (stickyTimer) {
            stickyTimer.classList.add('warning');
            stickyTimer.classList.remove('danger');
        }
    } else {
        // Normal time
        document.body.classList.remove('time-warning', 'time-danger');
        if (stickyTimer) {
            stickyTimer.classList.remove('warning', 'danger');
        }
    }
}

// Stops the timer
function stopTimer() {
    if (STATE.examTimerInterval) {
        clearInterval(STATE.examTimerInterval);
        STATE.examTimerInterval = null;
        console.log("Timer stopped.");
    }
}

// Start, stop, and save auto timer functions
function startAutoSave() {
    stopAutoSave();
    
    console.log("Starting auto-save timer");
    STATE.autoSaveTimer = setInterval(() => {
        if (DOM['exam-questions-module'] && !DOM['exam-questions-module'].classList.contains('hidden')) {
            autoSaveAnswers();
        }
    }, CONFIG.AUTO_SAVE_INTERVAL);
}

function stopAutoSave() {
    if (STATE.autoSaveTimer) {
        clearInterval(STATE.autoSaveTimer);
        STATE.autoSaveTimer = null;
    }
}

function autoSaveAnswers() {
    if (!DOM['exam-questions-module'] || 
        DOM['exam-questions-module'].classList.contains('hidden') || 
        !STATE.examDetails) {
        return;
    }
    
    console.log("Auto-saving current answers...");
    try {
        const currentAnswers = {};
        const confirmationStatus = {};
        
        // Use original indices to collect answers
        const originalIndices = Object.keys(STATE.examDetails.OriginalOrderMap)
                             .map(Number)
                             .sort((a, b) => a - b);
                             
        originalIndices.forEach(originalIndex => {
            const originalQNum = originalIndex + 1;
            const answerName = `ans-${originalQNum}`;
            const questionDivId = `q-${originalQNum}`;
            const questionDiv = document.getElementById(questionDivId);
            
            // Get confirmation status
            if (questionDiv) {
                confirmationStatus[questionDivId] = questionDiv.classList.contains('confirmed');
            }
            
            // Get answer value based on question type
            const questionData = STATE.examDetails.OriginalOrderMap[originalIndex];
            if (!questionData) return;
            
            const formElement = DOM['exam-form'].elements[answerName];
            if (formElement) {
                switch (questionData.type) {
                    case 'multiple_select':
                        currentAnswers[answerName] = formElement.value || '';
                        break;
                    case 'attachment':
                        // Just save "has file" status
                        currentAnswers[answerName] = (formElement.files && formElement.files.length > 0) 
                            ? 'FILE_SELECTED' : '';
                        break;
                    case 'code':
                        // Get value from code editor if available
                        if (STATE.codeEditors[answerName]) {
                            currentAnswers[answerName] = STATE.codeEditors[answerName].getValue() || '';
                        } else {
                            currentAnswers[answerName] = formElement.value || '';
                        }
                        break;
                    default:
                        currentAnswers[answerName] = formElement.value || '';
                }
            }
        });
        
        // Update saved state with current answers and confirmation status
        const currentState = JSON.parse(localStorage.getItem(CONFIG.APP_STATE_KEY) || '{}');
        currentState.currentAnswers = currentAnswers;
        currentState.confirmationStatus = confirmationStatus;
        localStorage.setItem(CONFIG.APP_STATE_KEY, JSON.stringify(currentState));
        
        console.log("Answers auto-saved successfully");
    } catch (e) {
        console.error("Error auto-saving answers:", e);
    }
}

// === Answer Confirmation ===
function confirmAnswer(questionId) {
    const questionDiv = document.getElementById(questionId);
    if (!questionDiv || questionDiv.classList.contains('confirmed')) return;
    
    // Add confirmed class
    questionDiv.classList.add('confirmed');
    STATE.confirmedQuestionsCount++;

    // Disable inputs
    const inputs = questionDiv.querySelectorAll('.form-control, .form-control-checkbox');
    inputs.forEach(input => { input.disabled = true; });
    
    // Handle CodeMirror editor if present
    const cmTextarea = questionDiv.querySelector('.code-editor');
    if (cmTextarea && cmTextarea.id && STATE.codeEditors[cmTextarea.id]) {
        STATE.codeEditors[cmTextarea.id].setOption('readOnly', true);
        
        // Add visual indicator
        const cmElement = STATE.codeEditors[cmTextarea.id].getWrapperElement();
        if (cmElement) {
            cmElement.classList.add('cm-confirmed');
        }
    }

    console.log(`Confirmed answer for question: ${questionId}`);
    checkAllConfirmed();
}

function editAnswer(questionId) {
    const questionDiv = document.getElementById(questionId);
    if (!questionDiv || !questionDiv.classList.contains('confirmed')) return;

    // Remove confirmed class
    questionDiv.classList.remove('confirmed');
    STATE.confirmedQuestionsCount--;

    // Re-enable inputs
    const inputs = questionDiv.querySelectorAll('.form-control, .form-control-checkbox');
    inputs.forEach(input => { input.disabled = false; });
    
    // Handle CodeMirror editor if present
    const cmTextarea = questionDiv.querySelector('.code-editor');
    if (cmTextarea && cmTextarea.id && STATE.codeEditors[cmTextarea.id]) {
        STATE.codeEditors[cmTextarea.id].setOption('readOnly', false);
        
        // Remove visual indicator
        const cmElement = STATE.codeEditors[cmTextarea.id].getWrapperElement();
        if (cmElement) {
            cmElement.classList.remove('cm-confirmed');
        }
    }

    console.log(`Enabled editing for question: ${questionId}`);
    checkAllConfirmed();
}

// Checks if all questions are confirmed
function checkAllConfirmed() {
    // Only proceed if questions area is visible and we know the total count
    if (!DOM['exam-questions-area'] || 
        DOM['exam-questions-module'].classList.contains('hidden') || 
        STATE.totalQuestions <= 0) {
        if (DOM['submit-exam-btn']) {
            DOM['submit-exam-btn'].disabled = true;
            DOM['submit-exam-btn'].innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)';
        }
        return;
    }

    // Count questions requiring confirmation (excluding text-only)
    const questionsRequiringConfirmation = document.querySelectorAll('.question:not(.text-only-question)').length;
    const confirmedNonTextOnly = document.querySelectorAll('.question.confirmed:not(.text-only-question)').length;
    
    const allConfirmed = confirmedNonTextOnly === questionsRequiringConfirmation;
    console.log(`Confirmed ${confirmedNonTextOnly}/${questionsRequiringConfirmation} questions. All confirmed: ${allConfirmed}`);

    if (DOM['submit-exam-btn']) {
        // Enable button only if all confirmed AND online
        DOM['submit-exam-btn'].disabled = !allConfirmed || !STATE.isOnline;

        // Update button text
        if (allConfirmed && STATE.isOnline) {
            DOM['submit-exam-btn'].innerHTML = '<i class="fas fa-check-circle"></i> Submit Exam Now';
        } else if (!STATE.isOnline) {
            DOM['submit-exam-btn'].innerHTML = '<i class="fas fa-wifi"></i> Submit Exam (Offline)';
        } else {
            DOM['submit-exam-btn'].innerHTML = `<i class="fas fa-lock"></i> Submit Exam (${confirmedNonTextOnly}/${questionsRequiringConfirmation} Confirmed)`;
        }
    }
}

// === Exam Submission ===
async function handleSubmitExam(isAutoSubmit = false) {
    const timeIsUp = STATE.examEndTime && Date.now() >= STATE.examEndTime;
    if (timeIsUp && !isAutoSubmit) {
        console.warn("Manual submit clicked after deadline. Treating as auto-submit.");
        showImprovedNotification('warning', 'Deadline Passed', 'Time expired. Submitting automatically.');
        isAutoSubmit = true;
    }

    stopTimer();

    // Disable submit button
    if (DOM['submit-exam-btn']) {
        DOM['submit-exam-btn'].disabled = true;
        DOM['submit-exam-btn'].innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';
    }

    // Confirmation check for manual submit
    if (!isAutoSubmit) {
        if (STATE.confirmedQuestionsCount !== STATE.totalQuestions) {
            showImprovedNotification('error', 'Not All Confirmed', 
                `Please confirm all ${STATE.totalQuestions} questions before submitting. You have confirmed ${STATE.confirmedQuestionsCount}.`, 5000);
            checkAllConfirmed();
            return;
        }
        
        // Final confirmation
        if (!confirm("You have confirmed all answers. Are you absolutely sure you want to submit your exam?\nThis action cannot be undone.")) {
            checkAllConfirmed();
            if (STATE.examEndTime && Date.now() < STATE.examEndTime) {
                startTimer();
            }
            return;
        }
    }

    console.log("Processing submission..." + (isAutoSubmit ? " (Auto)" : " (Manual - All Confirmed)"));
    const answers = {};
    const fingerprintObject = getFingerprintData();

    // Collect answers respecting original order
    if (!STATE.examDetails || !STATE.examDetails.OriginalOrderMap || STATE.totalQuestions <= 0) {
        showImprovedNotification('error', 'Submission Error', 'Cannot collect answers. Exam data or question count is invalid.', 0);
        checkAllConfirmed();
        return;
    }

    collectAnswers(answers, isAutoSubmit);

    // Create backup data
    const backupData = createBackupData(answers, fingerprintObject, timeIsUp, isAutoSubmit);
    const backupFilename = `exam_backup_${STATE.examDetails?.PIN || 'unknown'}_${(STATE.currentUser?.email || STATE.studentExamIdEntered || 'anon').replace(/@.*/, '')}_${Date.now()}.json`;
    downloadJsonBackup(backupData, backupFilename);

    // Prepare data payload for backend
    const submissionData = prepareSubmissionData(answers, fingerprintObject, isAutoSubmit, timeIsUp);

    // Send data to backend
    let submissionSuccess = await sendSubmissionToBackend(submissionData);

    // Final UI update based on success
    updateUIAfterSubmission(submissionSuccess, isAutoSubmit);
}

// Helper functions for submission process
function collectAnswers(answers, isAutoSubmit) {
    const originalIndices = Object.keys(STATE.examDetails.OriginalOrderMap)
                         .map(Number)
                         .sort((a, b) => a - b);
                         
    originalIndices.forEach(originalIndex => {
        const originalQNum = originalIndex + 1;
        const questionData = STATE.examDetails.OriginalOrderMap[originalIndex];
        const answerName = `ans-${originalQNum}`;
        const questionDivId = `q-${originalQNum}`;
        const questionDiv = document.getElementById(questionDivId);
        
        if (questionData.type === 'text_only') {
            answers[answerName] = "[TEXT_ONLY_NO_ANSWER_REQUIRED]";
            return;
        }
        
        // Check confirmation status
        const isConfirmed = questionDiv ? questionDiv.classList.contains('confirmed') : false;

        // For auto submit, only collect confirmed answers
        if (isAutoSubmit && !isConfirmed) {
            answers[answerName] = "[NOT CONFIRMED]";
            console.log(`Auto-submit: Answer for ${answerName} was not confirmed.`);
        } else {
            collectSingleAnswer(answers, questionData, answerName);
        }
    });
}

function collectSingleAnswer(answers, questionData, answerName) {
    const formElement = DOM['exam-form'].elements[answerName];
    if (!formElement) {
        console.warn(`Could not find form element for answer name: "${answerName}"`);
        answers[answerName] = 'ERROR_ELEMENT_NOT_FOUND';
        return;
    }
    
    switch (questionData.type) {
        case 'attachment':
            answers[answerName] = (formElement.files && formElement.files.length > 0)
                ? `FILE_UPLOADED:${formElement.files[0].name}`
                : '';
            break;
            
        case 'multiple_select':
            let selectedValue = formElement.value || null;
            
            // Store metadata for non-admins with shuffled options
            if (!STATE.isAdmin && questionData.shuffledOptionIndices && selectedValue) {
                const selectedOptionEl = document.querySelector(`input[name="${answerName}"]:checked`);
                if (selectedOptionEl && selectedOptionEl.dataset.originalIndex) {
                    answers[`${answerName}_metadata`] = {
                        originalIndex: selectedOptionEl.dataset.originalIndex
                    };
                }
            }
            
            answers[answerName] = selectedValue;
            break;
            
        case 'code':
            // Get value from code editor if available
            if (STATE.codeEditors[answerName]) {
                answers[answerName] = STATE.codeEditors[answerName].getValue();
            } else {
                answers[answerName] = formElement.value || '';
            }
            break;
            
        default:
            answers[answerName] = formElement.value || '';
    }
    
    console.log(`Collected answer for ${answerName} (${questionData.type}): ` + 
              (typeof answers[answerName] === 'string' ? 
               `"${answers[answerName].substring(0, 50)}${answers[answerName].length > 50 ? '...' : ''}"` : 
               answers[answerName]));
}

function createBackupData(answers, fingerprintObject, timeIsUp, isAutoSubmit) {
    return {
        submissionTimestamp: new Date().toISOString(),
        examDetails: {
            PIN: STATE.examDetails?.PIN,
            Name: STATE.examDetails?.Name,
            Mode: STATE.examDetails?.Mode,
            Code: STATE.examDetails?.Code
        },
        studentInfo: {
            pinEntered: STATE.studentPINEntered,
            studentExamId: STATE.examDetails?.Mode === 'exam' ? STATE.studentExamIdEntered : undefined,
            name: STATE.currentUser?.name,
            email: STATE.currentUser?.email
        },
        answers: answers,
        fingerprint: fingerprintObject,
        submittedLate: timeIsUp,
        autoSubmitted: isAutoSubmit,
        confirmedCountOnSubmit: STATE.confirmedQuestionsCount,
        totalQuestionsOnSubmit: STATE.totalQuestions,
        examEndTime: STATE.examEndTime
    };
}

function prepareSubmissionData(answers, fingerprintObject, isAutoSubmit, timeIsUp) {
    return {
        timestamp: new Date().toISOString(),
        pin: STATE.examDetails?.PIN,
        courseCode: STATE.examDetails?.Code,
        mode: STATE.examDetails?.Mode,
        studentEmail: (STATE.examDetails?.Mode === 'quiz' ? STATE.currentUser?.email : undefined),
        studentName: (STATE.examDetails?.Mode === 'quiz' ? STATE.currentUser?.name : undefined),
        studentExamId: (STATE.examDetails?.Mode === 'exam' ? STATE.studentExamIdEntered : undefined),
        answers: answers,
        fingerprint: fingerprintObject,
        isAutoSubmit: isAutoSubmit,
        timeIsUp: timeIsUp
    };
}

async function sendSubmissionToBackend(submissionData) {
    try {
        console.log(`Sending data to backend: ${CONFIG.BACKEND_URL}`);
        const response = await fetch(CONFIG.BACKEND_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json', // Send as JSON
                'Accept': 'application/json'      // Expect JSON response
            },
            body: JSON.stringify({ submission: submissionData }) // Ensure body is JSON string
        });

        // Check if the response status is OK (e.g., 200-299)
        if (!response.ok) {
            // Try to get error message from backend response body
            let errorMsg = `Backend error! Status: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg = errorData.error || errorData.message || errorMsg;
            } catch (e) {
                // Could not parse error JSON, use status text
                errorMsg = `${errorMsg} - ${response.statusText}`;
            }
            throw new Error(errorMsg);
        }

        // Parse the JSON response from the backend
        const result = await response.json();
        console.log("Backend submission response:", result);

        // Check the success flag from the backend response
        if (result && result.success === true) {
            console.log("Submission successfully processed by backend.");
            return true; // Indicate success
        } else {
            // Backend indicated failure
            throw new Error(result.error || result.message || "Backend reported an unspecified error.");
        }

    } catch (error) {
        console.error('Error submitting data to backend:', error);
        // Keep the notification about backup download
        showImprovedNotification('error', 'Submission Error', `Could not send submission: ${error.message}. A backup file was downloaded.`, 0);
        return false; // Indicate failure
    }
}

function updateUIAfterSubmission(success, isAutoSubmit) {
    if (success) {
        showImprovedNotification('success', 'Exam Submitted Successfully!', `Your submission has been sent.`, 0);
        DOM['exam-questions-module'].classList.add('hidden');
        DOM['submission-confirmation-module'].classList.remove('hidden');
        localStorage.removeItem(CONFIG.APP_STATE_KEY);
        
        // Reset state variables
        STATE.examDetails = null;
        STATE.studentPINEntered = '';
        STATE.studentExamIdEntered = '';
        STATE.examEndTime = null;
        STATE.totalQuestions = 0;
        STATE.confirmedQuestionsCount = 0;
    } else {
        console.error("Online submission failed after backup.");
        
        // Re-enable button only if manual submit failed
        if (!isAutoSubmit) {
            checkAllConfirmed();
        } else {
            showImprovedNotification('error', 'Auto-Submit Failed', 'Could not automatically send submission online. Backup downloaded.', 0);
        }
    }
}

// === Utility Functions ===
function getFingerprintData() {
    const webglFp = getWebglFingerprint();
    const data = {
        // Basic Browser & Config
        ua: navigator.userAgent || 'N/A',
        lang: navigator.language || 'N/A',
        vendor: navigator.vendor || 'N/A',
        cookieEnabled: navigator.cookieEnabled || false,
        doNotTrack: navigator.doNotTrack || 'unknown',
        plugins: Array.from(navigator.plugins || [])
                   .map(p => ({ name: p.name, filename: p.filename }))
                   .sort((a,b) => a.name.localeCompare(b.name)),
        mimeTypes: Array.from(navigator.mimeTypes || [])
                      .map(m => ({ type: m.type, description: m.description }))
                      .sort((a,b) => a.type.localeCompare(b.type)),

        // Hardware / OS
        platform: navigator.platform || 'N/A',
        cores: navigator.hardwareConcurrency || undefined,
        memory: navigator.deviceMemory || undefined,
        maxTouchPoints: navigator.maxTouchPoints || 0,

        // Screen & Display
        screenRes: `${screen.width || 0}x${screen.height || 0}x${screen.colorDepth || 0}`,
        availScreenRes: `${screen.availWidth || 0}x${screen.availHeight || 0}`,
        windowInnerSize: `${window.innerWidth || 0}x${window.innerHeight || 0}`,
        timezoneOffset: new Date().getTimezoneOffset(),

        // GPU Info (from WebGL)
        webglAvailable: webglFp.available,
        webglVendor: webglFp.vendor,
        webglRenderer: webglFp.renderer,

        // Timestamp
        ts: Date.now()
    };
    
    console.log("Collected Fingerprint Data:", data);
    return data;
}

// Helper for WebGL fingerprinting
function getWebglFingerprint() {
    try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            return { available: false, vendor: 'N/A', renderer: 'N/A' };
        }
        
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        const vendor = gl.getParameter(debugInfo ? debugInfo.UNMASKED_VENDOR_WEBGL : gl.VENDOR);
        const renderer = gl.getParameter(debugInfo ? debugInfo.UNMASKED_RENDERER_WEBGL : gl.RENDERER);
        
        return {
            available: true,
            vendor: vendor || 'unknown',
            renderer: renderer || 'unknown'
        };
    } catch (e) {
        console.warn("WebGL fingerprinting failed:", e);
        return { available: false, vendor: 'error', renderer: 'error', errorMsg: e.message };
    }
}

// JSON file download helper
function downloadJsonBackup(data, filename) {
    try {
        const jsonString = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonString], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        console.log("JSON backup download initiated:", filename);
        showImprovedNotification('info', 'Backup Saved', 'A JSON backup file of your submission has been downloaded.');
    } catch (e) {
        console.error("Error creating or triggering JSON backup download:", e);
        showImprovedNotification('error', 'Backup Error', 'Could not create the backup file. Please manually copy your answers if needed.');
    }
}

// Function to create a consistent hash from a string (for seeding)
function hashString(str) {
    let hash = 0;
    if (!str || str.length === 0) return Math.floor(Math.random() * 1000000);
    
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    
    return Math.abs(hash);
}

// Deterministic (seeded) in-place Fisher–Yates shuffle
function seededShuffle(array, seed) {
    let m = array.length, t, i;
    // Simple PRNG: linear congruential
    while (m > 0) {
        seed = (seed * 1664525 + 1013904223) >>> 0;     // update seed
        i = seed % m;                                   // pick an index
        m--;
        // swap array[m] and array[i]
        t = array[m];
        array[m] = array[i];
        array[i] = t;
    }
    return array;
}

// Utility function to escape HTML
function escapeHtml(unsafe) {
    if (typeof unsafe !== 'string') return unsafe;
    return unsafe
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}

// Updates online status and related UI elements
function updateOnlineStatus() {
    STATE.isOnline = navigator.onLine;
    console.log('Connection Status:', STATE.isOnline ? 'Online' : 'Offline');
    
    if (!DOM['sync-status'] || !DOM.syncIcon || !DOM.syncText) {
        console.warn("Missing sync status elements");
        return;
    }

    if (STATE.isOnline) {
        DOM['sync-status'].className = 'sync-status online';
        DOM.syncIcon.style.color = 'var(--success-color)';
        DOM.syncText.textContent = 'Online';
    } else {
        DOM['sync-status'].className = 'sync-status offline';
        DOM.syncIcon.style.color = 'var(--warning-color)';
        DOM.syncText.textContent = 'Offline';
        if (!STATE.isInitializing) {
            showImprovedNotification('warning', 'Offline', 'You are currently offline. Features requiring connection may be limited.', 5000);
        }
    }

    if (DOM.syncIcon && !STATE.isSyncing) {
        DOM.syncIcon.className = 'fas fa-circle';
        DOM.syncIcon.style.color = STATE.isOnline ? 'var(--success-color)' : 'var(--warning-color)';
    }

    // Update button states based on online status
    if (DOM['load-exam-btn']) {
        DOM['load-exam-btn'].disabled = !STATE.isOnline || 
                                     !STATE.isSignedIn || 
                                     (DOM['exam-pin-input'] && DOM['exam-pin-input'].value.trim() === '');
    }
    
    let startDisabled = !STATE.isOnline || !STATE.isSignedIn || !STATE.examDetails;
    const isExamModeActive = STATE.examDetails && STATE.examDetails.Mode === 'exam';
    
    if (isExamModeActive) {
        startDisabled = startDisabled || 
                      (DOM['student-exam-id-input'] && 
                       DOM['student-exam-id-input'].value.trim().length !== 5);
                       
        if (DOM['start-exam-btn-alt']) DOM['start-exam-btn-alt'].disabled = startDisabled;
        if (DOM['start-exam-btn']) DOM['start-exam-btn'].disabled = true;
    } else {
        if (DOM['start-exam-btn']) DOM['start-exam-btn'].disabled = startDisabled;
        if (DOM['start-exam-btn-alt'] && STATE.examDetails) DOM['start-exam-btn-alt'].classList.add('hidden');
    }

    // Update submit button status
    checkAllConfirmed();

    if (STATE.isInitializing && (typeof gapi !== 'undefined')) {
        STATE.isInitializing = false;
        console.log("Initialization process complete.");
    }
}

// Updates the sync status indicator UI
function setSyncing(syncing) {
    STATE.isSyncing = syncing;
    console.log("Network Syncing:", STATE.isSyncing);
    
    if (!DOM.syncIcon) return;
    
    if (syncing) {
        DOM.syncIcon.className = 'fas fa-spinner fa-spin';
        DOM.syncIcon.style.color = 'var(--info-color)';
        if (DOM.syncText) DOM.syncText.textContent = 'Syncing...';
    } else {
        updateOnlineStatus();
    }
}

// Displays dismissible notifications
function showImprovedNotification(type, title, message, duration = 5000) {
    const container = DOM['in-page-notification-area'];
    if (!container) {
        console.error("Notification container element not found in the DOM.");
        return;
    }

    // Create notification element
    const notification = document.createElement('div');
    notification.className = `in-page-notification in-page-notification-${type}`;

    // Determine icon based on type
    let iconClass;
    switch (type) {
        case 'success': iconClass = 'fa-check-circle'; break;
        case 'error':   iconClass = 'fa-times-circle'; break;
        case 'warning': iconClass = 'fa-exclamation-triangle'; break;
        default:        iconClass = 'fa-info-circle';
    }

    // Set inner HTML
    notification.innerHTML = `
        <i class="fas ${iconClass} fa-icon"></i>
        <div class="notification-content">
            <strong>${title}</strong><br>${message.replace(/\n/g, '<br>')}
        </div>
        <button type="button" class="notification-close" aria-label="Close">&times;</button>
    `;

    container.appendChild(notification);

    // Add close functionality
    const closeBtn = notification.querySelector('.notification-close');
    const removeNotification = () => {
        notification.classList.add('removing');
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    };

    closeBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        removeNotification();
    });

    // Auto-dismiss if duration > 0
    if (duration > 0) {
        setTimeout(removeNotification, duration);
    }
}

// === State Persistence ===
function saveAppState() {
    // Only save state if an exam is actively loaded or in progress
    if (!STATE.examDetails || 
        (DOM['exam-questions-module'] && 
         DOM['exam-questions-module'].classList.contains('hidden') && 
         !DOM['submission-confirmation-module'].classList.contains('hidden'))) {
        
        // Don't save if no exam loaded, or if exam is finished
        if (DOM['exam-questions-module'] && 
            DOM['exam-questions-module'].classList.contains('hidden') && 
            DOM['submission-confirmation-module'].classList.contains('hidden')) {
            // Proceed to save setup state
        } else {
            console.log("Not saving state: Exam not active or already submitted.");
            return;
        }
    }

    try {
        const state = {
            // Auth info
            isSignedIn: STATE.isSignedIn,
            currentUserEmail: STATE.currentUser?.email,

            // Exam progress info
            examDetails: STATE.examDetails,
            studentPINEntered: STATE.studentPINEntered,
            studentExamIdEntered: STATE.studentExamIdEntered,
            examEndTime: STATE.examEndTime
        };
        
        localStorage.setItem(CONFIG.APP_STATE_KEY, JSON.stringify(state));
        console.log("Application state saved to localStorage.");
    } catch (e) {
        console.error("Error saving application state to localStorage:", e);
    }
}

// Loads state from localStorage on initial page load
function loadAppState() {
    const savedStateString = localStorage.getItem(CONFIG.APP_STATE_KEY);
    if (!savedStateString) {
        console.log("No saved application state found in localStorage.");
        return;
    }
    
    try {
        const state = JSON.parse(savedStateString);
        console.log("Found saved application state:", state);
        // tokenObtained function will check this state against the current user
    } catch (e) {
        console.error("Error parsing saved application state from localStorage:", e);
        localStorage.removeItem(CONFIG.APP_STATE_KEY);
    }
}

// Restores the application UI and state
async function restoreAppState(state) {
    console.log("Restoring application state...");

    // Restore key state variables
    STATE.examDetails = state.examDetails;
    STATE.studentPINEntered = state.studentPINEntered;
    STATE.studentExamIdEntered = state.studentExamIdEntered;
    STATE.examEndTime = state.examEndTime;

    // Validate restored end time
    if (!STATE.examEndTime || isNaN(STATE.examEndTime) || Date.now() >= STATE.examEndTime) {
        console.warn("Restored exam state has expired or end time is invalid. Clearing state.");
        localStorage.removeItem(CONFIG.APP_STATE_KEY);
        resetExamState(); // Reset UI fully
        updateAuthUI();   // Ensure auth UI is correct
        showImprovedNotification('warning', 'Session Expired', 'Your previous exam session has expired.', 0);
        return; // Stop restoration
    }

    showImprovedNotification('info', 'Exam Session Restored', 'Resuming your previous exam session.', 5000);

    // Rebuild UI to match the restored state
    DOM['signin-prompt-module'].classList.add('hidden');
    DOM['exam-start-module'].classList.add('hidden');
    DOM['exam-details-module'].classList.add('hidden');
    DOM['submission-confirmation-module'].classList.add('hidden');
    DOM['exam-questions-module'].classList.remove('hidden');

    // Display header info
    displayExamDetailsHeader();

    // Await the display of questions before proceeding
    try {
        if (STATE.examDetails && STATE.examDetails.Questions && STATE.examDetails.OriginalOrderMap) {
            // Wait for questions to be rendered and editors initialized
            await displayQuestions(STATE.examDetails.Questions);
            console.log("Questions displayed, proceeding to restore answers.");

            // Restore saved answers if available (Now happens AFTER await)
            if (state.currentAnswers) {
                console.log("Restoring saved answers...");
                // Use try-catch specifically around answer/confirmation restoration
                try {
                    // Restore answers
                    for (const answerName in state.currentAnswers) {
                         // Check if the property belongs to the object itself
                        if (!Object.hasOwnProperty.call(state.currentAnswers, answerName)) continue;

                        const formElement = DOM['exam-form']?.elements[answerName];
                        const answerValue = state.currentAnswers[answerName];

                        if (formElement && answerValue !== 'FILE_SELECTED' && answerValue !== '[NOT CONFIRMED]') {
                            if (formElement.classList?.contains('code-editor') && STATE.codeEditors[answerName]) {
                                 // Restore CodeMirror content
                                STATE.codeEditors[answerName].setValue(answerValue || '');
                                console.log(`Restored CodeMirror for ${answerName}`);
                            } else if (formElement.type === 'radio') {
                                // Restore radio button selection
                                const radioToSelect = document.querySelector(`input[name="${answerName}"][value="${CSS.escape(answerValue)}"]`);
                                if (radioToSelect) {
                                     radioToSelect.checked = true;
                                     console.log(`Restored radio selection for ${answerName} to value "${answerValue}"`);
                                } else {
                                     console.warn(`Radio option with value "${answerValue}" not found for ${answerName}`);
                                }
                            } else if (formElement.type !== 'file') {
                                 // Restore other input/textarea values
                                formElement.value = answerValue || '';
                                console.log(`Restored value for ${answerName}`);
                            }
                        } else if (!formElement) {
                             console.warn(`Form element not found for restoring answer: ${answerName}`);
                        }
                    } // End answer loop

                    // Restore confirmation status
                    STATE.confirmedQuestionsCount = 0; // Recalculate based on restored state
                     const textOnlyCount = document.querySelectorAll('.text-only-confirmed').length;
                     STATE.confirmedQuestionsCount += textOnlyCount; // Add auto-confirmed text_only

                    if (state.confirmationStatus) {
                        for (const questionId in state.confirmationStatus) {
                             // Check if the property belongs to the object itself
                            if (!Object.hasOwnProperty.call(state.confirmationStatus, questionId)) continue;

                            const questionDiv = document.getElementById(questionId);
                            // Only confirm if the backup state says it was confirmed AND it's not text-only (already counted)
                            if (questionDiv && state.confirmationStatus[questionId] && !questionDiv.classList.contains('text-only-question')) {
                                // Re-apply confirmed class and disable inputs
                                questionDiv.classList.add('confirmed');
                                const inputs = questionDiv.querySelectorAll('.form-control, .form-control-checkbox');
                                inputs.forEach(input => { input.disabled = true; });

                                // Disable CodeMirror if present in this question
                                const cmTextarea = questionDiv.querySelector('.code-editor');
                                if (cmTextarea && cmTextarea.id && STATE.codeEditors[cmTextarea.id]) {
                                    STATE.codeEditors[cmTextarea.id].setOption('readOnly', true);
                                    STATE.codeEditors[cmTextarea.id].getWrapperElement()?.classList.add('cm-confirmed');
                                }
                                STATE.confirmedQuestionsCount++; // Increment counter
                                console.log(`Restored confirmed status for ${questionId}`);
                            } else if (questionDiv && !state.confirmationStatus[questionId] && !questionDiv.classList.contains('text-only-question')) {
                                // Ensure non-confirmed questions are editable
                                questionDiv.classList.remove('confirmed');
                                const inputs = questionDiv.querySelectorAll('.form-control, .form-control-checkbox');
                                inputs.forEach(input => { input.disabled = false; });
                                const cmTextarea = questionDiv.querySelector('.code-editor');
                                if (cmTextarea && cmTextarea.id && STATE.codeEditors[cmTextarea.id]) {
                                    STATE.codeEditors[cmTextarea.id].setOption('readOnly', false);
                                     STATE.codeEditors[cmTextarea.id].getWrapperElement()?.classList.remove('cm-confirmed');
                                }
                            }
                        } // End confirmation loop
                    } // End if (state.confirmationStatus)

                    // Update submit button state AFTER restoring answers/confirmations
                    checkAllConfirmed();
                    console.log(`Restored state: ${STATE.confirmedQuestionsCount}/${STATE.totalQuestions} confirmed answers`);

                } catch (restoreError) {
                    console.error("Error applying restored answers/confirmations:", restoreError);
                    showImprovedNotification('error', 'Restore Warning', 'Could not fully restore saved answers. Please check carefully.', 5000);
                     checkAllConfirmed(); // Still update button state
                }
            } else {
                 checkAllConfirmed(); // Update button state even if no answers were saved
            } // End if (state.currentAnswers)

        } else {
            console.error("Cannot restore questions display: Missing Questions or Order Map in saved state.");
            showImprovedNotification('error', 'Restore Failed', 'Could not restore exam questions. State might be corrupted.', 0);
            localStorage.removeItem(CONFIG.APP_STATE_KEY);
            resetExamState(); // Reset UI
            updateAuthUI();
            return; // Stop restoration
        }
    } catch (displayError) {
        console.error("Error awaiting displayQuestions in restoreAppState:", displayError);
        showImprovedNotification('error', 'Restore Failed', 'Could not display exam questions during restore.', 0);
        localStorage.removeItem(CONFIG.APP_STATE_KEY);
        resetExamState(); // Reset UI
        updateAuthUI();
        return; // Stop restoration
    }

    // Restart the timer
    startTimer();
    // Start auto-save again for the restored session
    startAutoSave();
    console.log("Application state restored successfully.");
}

// === Backup Import Feature ===
function setupBackupImportFeature() {
    const userAvatar = DOM['user-avatar'];
    if (!userAvatar) return;
    
    // Track clicks for triple-click detection
    let clickCount = 0;
    let clickTimer = null;
    
    userAvatar.addEventListener('click', function() {
        clickCount++;
        
        if (clickCount === 1) {
            clickTimer = setTimeout(() => {
                clickCount = 0;
                clickTimer = null;
            }, 500);
        }
        
        if (clickCount === 3) {
            // Triple click detected
            clearTimeout(clickTimer);
            clickCount = 0;
            clickTimer = null;
            
            // Show import backup dialog
            showBackupImportDialog();
        }
    });
    
    // Create backup import dialog if it doesn't exist
    if (!document.getElementById('backup-import-modal')) {
        createBackupImportDialog();
    }
}

// Create the backup import dialog
function createBackupImportDialog() {
    const modalDiv = document.createElement('div');
    modalDiv.id = 'backup-import-modal';
    modalDiv.className = 'backup-modal';
    
    modalDiv.innerHTML = `
        <div class="backup-modal-content">
            <div class="backup-modal-header">
                <h3><i class="fas fa-file-import"></i> Import Backup</h3>
                <button type="button" class="backup-close-btn" id="backup-close-btn">&times;</button>
            </div>
            <div class="backup-modal-body">
                <p>You can restore a previously saved exam backup JSON file here.</p>
                <div class="form-group">
                    <label for="backup-file-input">Select Backup File:</label>
                    <input type="file" id="backup-file-input" class="form-control" accept=".json">
                </div>
                <div class="backup-info" id="backup-info"></div>
                <div class="backup-preview" id="backup-preview"></div>
            </div>
            <div class="backup-modal-footer">
                <button type="button" class="btn-orange" id="backup-cancel-btn">Cancel</button>
                <button type="button" class="btn-green" id="backup-import-btn" disabled>Import Backup</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modalDiv);
    
    // Setup event listeners
    document.getElementById('backup-close-btn').addEventListener('click', hideBackupImportDialog);
    document.getElementById('backup-cancel-btn').addEventListener('click', hideBackupImportDialog);
    document.getElementById('backup-file-input').addEventListener('change', handleBackupFileSelected);
    document.getElementById('backup-import-btn').addEventListener('click', importBackupData);
}

// Show/hide backup import dialog
function showBackupImportDialog() {
    const modal = document.getElementById('backup-import-modal');
    if (modal) {
        // Reset dialog state
        document.getElementById('backup-file-input').value = '';
        document.getElementById('backup-info').innerHTML = '';
        document.getElementById('backup-preview').innerHTML = '';
        document.getElementById('backup-import-btn').disabled = true;
        
        modal.classList.add('visible');
    }
}

function hideBackupImportDialog() {
    const modal = document.getElementById('backup-import-modal');
    if (modal) {
        modal.classList.remove('visible');
    }
}

// Handle backup file selection
function handleBackupFileSelected(event) {
    const fileInput = event.target;
    const file = fileInput.files[0];
    const infoDiv = document.getElementById('backup-info');
    const previewDiv = document.getElementById('backup-preview');
    const importBtn = document.getElementById('backup-import-btn');
    
    // Reset display areas
    infoDiv.innerHTML = '';
    previewDiv.innerHTML = '';
    importBtn.disabled = true;
    
    if (!file) return;
    
    // Check file type
    if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
        infoDiv.innerHTML = '<p class="backup-error">Error: Selected file is not a JSON file.</p>';
        return;
    }
    
    // Read file content
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const backupData = JSON.parse(e.target.result);
            
            // Validate structure
            if (!backupData.examDetails || !backupData.studentInfo || !backupData.answers) {
                throw new Error('Invalid backup file structure');
            }
            
            // Show details
            infoDiv.innerHTML = `
                <p><strong>Exam:</strong> ${escapeHtml(backupData.examDetails.Name || 'N/A')}</p>
                <p><strong>PIN:</strong> ${escapeHtml(backupData.examDetails.PIN || 'N/A')}</p>
                <p><strong>Student:</strong> ${escapeHtml(backupData.studentInfo.name || 'N/A')}</p>
                <p><strong>Timestamp:</strong> ${escapeHtml(backupData.submissionTimestamp || 'N/A')}</p>
                <p><strong>Questions:</strong> ${backupData.totalQuestionsOnSubmit || 'N/A'}</p>
                <p><strong>Confirmed:</strong> ${backupData.confirmedCountOnSubmit || 'N/A'}</p>
            `;
            
            // Show preview
            const answerKeys = Object.keys(backupData.answers || {}).slice(0, 3);
            if (answerKeys.length > 0) {
                let previewHtml = '<p><strong>Answer Preview:</strong></p><ul>';
                answerKeys.forEach(key => {
                    const value = backupData.answers[key];
                    const truncatedValue = typeof value === 'string' && value.length > 50 
                        ? value.substring(0, 50) + '...' 
                        : value;
                    previewHtml += `<li>${escapeHtml(key)}: ${escapeHtml(String(truncatedValue))}</li>`;
                });
                
                if (Object.keys(backupData.answers).length > 3) {
                    previewHtml += `<li>... and ${Object.keys(backupData.answers).length - 3} more</li>`;
                }
                
                previewHtml += '</ul>';
                previewDiv.innerHTML = previewHtml;
            } else {
                previewDiv.innerHTML = '<p>No answers found in backup.</p>';
            }
            
            // Enable import
            fileInput.dataset.validBackup = 'true';
            importBtn.disabled = false;
            
        } catch (error) {
            console.error('Error parsing backup file:', error);
            infoDiv.innerHTML = `<p class="backup-error">Error: ${error.message}. Please select a valid backup file.</p>`;
            fileInput.dataset.validBackup = 'false';
        }
    };
    
    reader.onerror = function() {
        infoDiv.innerHTML = '<p class="backup-error">Error: Failed to read the file.</p>';
    };
    
    reader.readAsText(file);
}

// Import backup data
function importBackupData() {
    const fileInput = document.getElementById('backup-file-input');
    if (!fileInput || fileInput.dataset.validBackup !== 'true' || !fileInput.files[0]) {
        showImprovedNotification('error', 'Import Failed', 'Invalid or missing backup file.', 3000);
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const backupData = JSON.parse(e.target.result);
            
            // Confirm with user
            if (confirm(`Are you sure you want to import backup for ${backupData.examDetails.Name} (PIN: ${backupData.examDetails.PIN})?\n\nThis will replace any current exam data.`)) {
                applyBackupToForm(backupData);
                hideBackupImportDialog();
                showImprovedNotification('success', 'Backup Imported', 'Exam backup has been successfully imported.', 5000);
            }
        } catch (error) {
            console.error('Error importing backup:', error);
            showImprovedNotification('error', 'Import Failed', `Error: ${error.message}`, 5000);
        }
    };
    
    reader.readAsText(fileInput.files[0]);
}

// Apply backup data to the form
function applyBackupToForm(backupData) {
    // Load exam if needed
    if (!STATE.examDetails || STATE.examDetails.PIN !== backupData.examDetails.PIN) {
        // Load exam
        STATE.examDetails = backupData.examDetails;
        STATE.studentPINEntered = backupData.studentInfo.pinEntered || '';
        STATE.studentExamIdEntered = backupData.studentInfo.studentExamId || '';
        
        // Update UI
        displayExamDetailsHeader();
        DOM['exam-start-module'].classList.add('hidden');
        DOM['exam-details-module'].classList.add('hidden');
        DOM['exam-questions-module'].classList.remove('hidden');
        
        // Display questions
        displayQuestions(STATE.examDetails.Questions);
    }
    
    // Apply answers to the form
    setTimeout(() => {
        const answers = backupData.answers || {};
        
        for (const answerName in answers) {
            const formElement = DOM['exam-form'].elements[answerName];
            if (!formElement) continue;
            
            const answerValue = answers[answerName];
            
            // Skip file uploads and [NOT CONFIRMED] placeholders
            if (formElement.type === 'file' || answerValue === '[NOT CONFIRMED]') continue;
            
            // Handle different input types
            if (formElement.classList.contains('code-editor') && STATE.codeEditors[answerName]) {
                STATE.codeEditors[answerName].setValue(answerValue || '');
            } else if (formElement.type === 'radio') {
                const radioOptions = document.querySelectorAll(`input[name="${answerName}"]`);
                radioOptions.forEach(radio => {
                    if (radio.value === answerValue) {
                        radio.checked = true;
                    }
                });
            } else {
                formElement.value = answerValue || '';
            }
            
            // Handle confirmation status
            const questionId = answerName.replace('ans-', 'q-');
            const wasConfirmed = backupData.confirmedCountOnSubmit === backupData.totalQuestionsOnSubmit;
            if (wasConfirmed) {
                confirmAnswer(questionId);
            }
        }
        
        // Update timer if time info available
        if (backupData.examEndTime) {
            STATE.examEndTime = backupData.examEndTime;
            startTimer();
        }
        
        checkAllConfirmed();
    }, 500);
}

// Make these functions globally available for HTML onclick handlers
window.confirmAnswer = confirmAnswer;
window.editAnswer = editAnswer;

// Initialize when the document is fully loaded
document.addEventListener('DOMContentLoaded', enhanceExamUI);

</script>

</body>
</html>