<!DOCTYPE html>
<html lang="en-GB"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Exam Portal</title>
    <link rel="icon" type="image/png" href="https://bredliplaku.github.io/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/monokai.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/python/python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/matchbrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/closebrackets.min.js"></script>
<style>
        /* --- CSS --- */
        :root {
        --primary-color: #3949ab;
        --primary-dark: #1a237e;
        --secondary-color: #ffa726;
        --background-color: #f4f4f4;
        --card-background: #ffffff;
        --text-color: #333333;
        --text-light: #ffffff;
        --warning-color: #fb8c00;
        --info-color: #2196F3;
        --danger-color: #f44336;
        --confirmed-bg: #f0f0f0;
        --confirmed-text: transparent;
        --confirmed-opacity: 0.1;
        --confirmed-border: #e0e0e0;
        --confirmed-placeholder: transparent;
        }
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body, html {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            background: var(--background-color, #ffffff);
            color: var(--text-color, #333);
			line-height: 1.5;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        .app-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }
        .app-loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loading-spinner {
            border: 5px solid rgba(57, 73, 171, 0.2);
            border-top: 5px solid #3949ab;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0%   { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(5px); }
  to   { opacity: 1; transform: translateY(0); }
}
@keyframes glow {
    from { box-shadow: 0 0 5px rgba(0,0,0,0.1); }
    to { box-shadow: 0 0 15px rgba(0,0,0,0.2); }
}
        .content-hidden {
            visibility: hidden;
            opacity: 0;
        }
        .content-visible {
            visibility: visible;
            opacity: 1;
            transition: opacity 0.5s ease-in;
        }
    .app-header {
        background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
        color: var(--text-light); 
        padding: 30px;
        border-radius: 20px;
        margin-bottom: 10px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        -webkit-user-select: none;
        -khtml-user-select: none;
    }
    .app-header h1 { 
        font-weight: 700;
        font-size: 2.0em; 
    }
    .app-header h2 {
        margin: 0 0 2px 0;
        font-weight: 400
        font-size: 1.0em
        opacity: 1.0;
    }
    .app-info { 
        display: flex; flex-wrap: wrap; margin-top: 15px; gap: 10px;
    }
    .info-item {
        background-color: rgba(255,255,255,0.1); 
        padding: 10px 15px; 
        border-radius: 10px;
        font-size: 0.9em;
        align-items: center; 
        display: inline-flex;
        gap: 5px;
        line-height: 30px;
    }
    .module {
        background-color: var(--card-background, #fff);
        border-radius: 20px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        margin-bottom: 20px;
        overflow: hidden;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .module-header {
        background-color: var(--primary-color);
        color: var(--text-light);
        padding: 15px;
        font-weight: 500;
        display: flex;
        justify-content: space-between;
        align-items: center;
        -webkit-user-select: none; 
        -khtml-user-select: none; 
        flex-wrap: wrap; 
        position: relative; 
    }
    .module-title {
        font-size: 1.1em; display: flex; align-items: center;
    }
    .module-title i {
        margin-right: 10px;
    }
    .module-content {
		padding: 15px;
        max-height: 2500px; 
        transition: max-height 0.5s ease-in, padding 0.3s ease-in;
    }
	.not-signed-in-message {
		text-align: center;
		padding: 20px;
		margin-top: 15px;
		border-radius: 15px;
		background-color: rgba(57, 73, 171, 0.1);
		color: #333;
	}
	button {
		display: inline-flex; align-items: center; justify-content: center; gap: 8px; 
		background-color: var(--primary-color); color: var(--text-light);
		padding: 10px 20px;
		border-radius: 20px;
		font-size: 0.9em;
		font-weight: 500;
		transition: background-color 0.3s, transform 0.3s, opacity 0.3s, box-shadow 0.2s;
		text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
		border: 0; cursor: pointer;
		-webkit-user-select: none;
		-khtml-user-select: none;
	}
	button:hover:not(:disabled) {
		background-color: var(--primary-dark);
		transform: translateY(-1px) scale(1.05);
		 transform: scale(1.05);
		box-shadow: 0 2px 5px rgba(0,0,0,0.2);
	}
	button:disabled {
		background-color: #aaa;
		opacity: 0.6;
		cursor: not-allowed;
		transform: none;
		box-shadow: none;
	}
	.btn-green { background-color: var(--success-color); }
	.btn-green:hover:not(:disabled) { background-color: #2e7d32; }
	.btn-blue { background-color: var(--info-color); }
	.btn-blue:hover:not(:disabled) { background-color: #1e87db; }
	.btn-orange { background-color: var(--warning-color); }
	.btn-orange:hover:not(:disabled) { background-color: #ef6c00; }
	.btn-grey { background-color: #6c757d; }
	.btn-grey:hover:not(:disabled) { background-color: #5a6268; }
	.btn-sm {
		padding: 6px 12px; font-size: 0.85em; border-radius: 15px;
	}
        .in-page-notifications {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10000;
            width: 350px;
            max-width: 90%;
            pointer-events: none;
        }
        .in-page-notification {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
			animation: slide-in 0.3s ease-out, glow 2s infinite alternate;
            overflow: hidden;
            display: flex;
            align-items: center;
            opacity: 1;
            transition: transform 0.3s ease-in, opacity 0.3s ease-in;
            pointer-events: auto;
        }
        .in-page-notification.removing {
            opacity: 0;
            transform: translateX(100%);
        }
        @keyframes slide-in {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .in-page-notification i.fa-icon {
            margin-right: 10px;
            font-size: 1.2em;
            flex-shrink: 0;
        }
        .notification-content {
            flex-grow: 1;
        }
        .notification-close {
            background: none;
            border: none;
            font-size: 20px;
            line-height: 1;
            color: inherit;
            opacity: 0.7;
            padding: 0 5px;
            margin-left: 10px;
            cursor: pointer;
        }
        .notification-close:hover {
            opacity: 1;
        }
        .in-page-notification-info {
            background-color: #e3f2fd;
            color: #0d47a1;
        }
        .in-page-notification-warning {
            background-color: #fff3e0;
            color: #e65100;
        }
        .in-page-notification-error {
            background-color: #ffebee;
            color: #b71c1c;
        }
        .in-page-notification-success {
            background-color: #e8f5e9;
            color: #1b5e20;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label { /* Labels for inputs like Name, Email, PIN */
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .form-control { /* Base style for text inputs, textareas */
            width: 100%;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
            transition: opacity 0.3s, background-color 0.3s, color 0.3s, border-color 0.3s;
            background-color: #fff;
            color: #333;
            opacity: 1;
        }
        /* Basic disabled style - often overridden by .confirmed */
        input:disabled, textarea:disabled {
            background-color: #eee;
            cursor: not-allowed;
            opacity: 0.7;
        }
        textarea.form-control {
            min-height: 100px;
        }
    .footer {
        max-width: 1000px;
        text-align: center;
        padding: 20px 0;
        color: var(--primary-dark);
        border-radius: 20px;
        margin-left: auto;
        margin-right: auto;
        -webkit-user-select: none;
        -khtml-user-select: none;
    }
    
    .social-links {
        margin-bottom: 10px;
        margin-top: 10px;
    }
    
    .social-links a {
        color: var(--primary-dark);
        font-size: 1.0em;
        margin: 0 10px;
        transition: color 0.3s;
    }
    
    .social-links a:hover {
        color: var(--secondary-color);
    }
        .auth-container {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
        }
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
        }
        .sync-auth-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .sync-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .sync-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9em;
        }
        .sync-status.online i {
            color: var(--success-color);
        }
        .sync-status.offline i {
            color: var(--warning-color);
        }
        #exam-details-display p {
            margin: 8px 0;
        }
/* Add these CSS styles to the existing styles to fix CodeMirror styling */

/* Basic CodeMirror styles */
.CodeMirror {
    height: auto ;
    min-height: 150px;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.4;
}

/* Ensure highlighted text is properly colored in monokai theme */
.cm-s-monokai .cm-keyword {color: #f92672 ;}
.cm-s-monokai .cm-operator {color: #f92672 ;}
.cm-s-monokai .cm-variable-2 {color: #9effff ;}
.cm-s-monokai .cm-variable-3, .cm-s-monokai .cm-type {color: #66d9ef ;}
.cm-s-monokai .cm-builtin {color: #a6e22e ;}
.cm-s-monokai .cm-atom {color: #ae81ff ;}
.cm-s-monokai .cm-number {color: #ae81ff ;}
.cm-s-monokai .cm-def {color: #fd971f ;}
.cm-s-monokai .cm-string {color: #e6db74 ;}
.cm-s-monokai .cm-comment {color: #75715e ;}
.cm-s-monokai .cm-variable {color: #f8f8f2 ;}
.cm-s-monokai .cm-tag {color: #f92672 ;}
.cm-s-monokai .cm-attribute {color: #a6e22e ;}
.cm-s-monokai .cm-property {color: #66d9ef ;}

/* Style for confirmed state */
.cm-confirmed {
    opacity: 0.7;
}

.cm-confirmed .CodeMirror-scroll {
    background-color: rgba(0,0,0,0.1);
}

/* Ensure cursor is visible */
.CodeMirror-cursor {
    border-left: 1px solid white ;
}

/* Make sure the monokai theme is applied with proper colors */
.cm-s-monokai.CodeMirror { 
    background: #272822 ; 
    color: #f8f8f2 ;
}

/* Make sure line numbers are properly styled */
.CodeMirror-linenumber {
    color: #75715e ;
}

/* Force proper selection background */
.cm-s-monokai .CodeMirror-selected { 
    background: rgba(255,255,255,0.1) ; 
}
/* Remove all traces of the editor toolbar/controls we don't want */
.code-editor-toolbar,
.code-editor-actions,
.code-output-area,
.output-header,
.output-content {
    display: none ;
}

/* ==========================================================================
   EXAM QUESTIONS AREA
   ========================================================================== */
#exam-questions-area {
  margin-top: 20px;
  padding: 20px;
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 10px;
}

/* Base question card */
#exam-questions-area .question {
  margin-bottom: 25px;
  padding: 20px;
  background-color: #fff;
  border-bottom: 1px dashed #ddd;
  border-radius: 10px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  position: relative;
  transition:
    max-height 0.5s ease-in-out,
    opacity 0.4s ease-in-out,
    background-color 0.3s ease,
    border-left 0.3s ease,
    box-shadow 0.3s ease;
}

/* Remove dashed border on last */
#exam-questions-area .question:last-child {
  border-bottom: none;
}

/* Text‑only read‑through prompts */
#exam-questions-area .question.text-only-question {
    background-color: #fffde7;
    border-left: 4px solid #fbc02d;
}

#exam-questions-area .question.text-only-question > div.text-content {
    background: linear-gradient(to right, #fff8e1, transparent);
    font-size: 1.05em;
}

#exam-questions-area .question.text-only-question.confirmed::after {
  display: none;         /* no "✓ CONFIRMED" badge */
}

/* Prompt label */
#exam-questions-area .question > label,
#exam-questions-area .question > div.text-content {
    background: linear-gradient(to right, #f0f4ff, transparent);
    padding: 10px 15px;
    border-radius: 6px 6px 0 0;
    font-size: 1.05em;
    margin: -20px -20px 15px -20px;
    border-bottom: 1px solid #e0e6f5;
}

#exam-questions-area .question em.term {
    background-color: rgba(255, 167, 38, 0.2);
    padding: 2px 4px;
    border-radius: 3px;
    font-style: normal;
    font-weight: 500;
    color: #d84315;
}

#exam-questions-area .question .code-prompt {
    font-family: 'Consolas', 'Monaco', monospace;
    background-color: #272822;
    color: #f8f8f2;
    padding: 12px 15px;
    border-radius: 6px;
    line-height: 1.5;
    margin-bottom: 15px;
    border-left: 4px solid var(--warning-color);
}

#exam-questions-area .question strong span.points-badge {
    display: inline-block;
    background-color: var(--info-color);
    color: white;
    font-size: 0.85em;
    padding: 2px 8px;
    border-radius: 12px;
    margin-left: 8px;
    vertical-align: middle;
}

#exam-questions-area .question strong:contains("points"),
#exam-questions-area .question strong:contains("point") {
    padding-right: 5px;
}

#exam-questions-area .question strong {
    position: relative;
}

/* Main content area */
#exam-questions-area .question-content {
  margin-bottom: 15px;
  transition: opacity 0.3s ease;
}

#exam-questions-area .question {
    border-radius: 12px;
    box-shadow: 0 3px 10px rgba(0,0,0,0.08);
    border: 1px solid #e3e8f4;
    transition: all 0.3s ease;
    margin-bottom: 25px;
}

#exam-questions-area .question:hover {
    box-shadow: 0 5px 15px rgba(0,0,0,0.12);
}

/* Actions container */
#exam-questions-area .question-actions {
    display: flex ;
    justify-content: center ;
    gap: 10px ;
    margin-top: 15px;
    margin-bottom: 15px;
}

#exam-questions-area .question:not(.confirmed) .btn-edit {
    display: none ;
}



/* Make buttons slightly more prominent */
#exam-questions-area .btn-confirm,
#exam-questions-area .btn-edit {
    min-width: 100px;
    padding: 8px 15px;
}

#exam-questions-area .btn-confirm {
    background-color: var(--success-color) ;
    color: white ;
}


/* Collapse confirmed cards by default */
#exam-questions-area .question.confirmed {
    max-height: none ;
    overflow: visible ;
    background-color: #f5f8ff;
    border-left: 4px solid var(--success-color);
}

#exam-questions-area .question.confirmed {
    background-color: #f1f8e9;
    border-left: 4px solid #7cb342;
    transition: all 0.3s ease;
}

#exam-questions-area .question.confirmed > label,
#exam-questions-area .question.confirmed > div.text-content {
    background: linear-gradient(to right, #e8f5e9, transparent);
}

/* === collapse only the content, not the whole card === */
#exam-questions-area .question .question-content {
  /* default — fully visible */
  max-height: none;
  opacity: 1;
  transition: max-height 0.5s ease-in-out,
              opacity     0.4s ease-in-out;
}

#exam-questions-area .question.confirmed .question-content {
	display: none ;
}

/* make sure the actions (confirm/edit/expand) always stay visible */
#exam-questions-area .question .question-actions {
  position: relative;
  z-index: 2;
}

#exam-questions-area .checkbox-group {
    display: flex ;
    flex-wrap: wrap ;
    gap: 12px ;
    margin-top: 10px;
}

#exam-questions-area .checkbox-item {
    flex: 1 1 180px;
    margin-right: 15px ;
    margin-bottom: 8px;
    background-color: #f8f9fa; /* Light background for visibility */
    padding: 6px 10px;
    border-radius: 4px; /* Rounded corners */
    transition: background-color 0.2s; /* Smooth hover effect */
    border: 1px solid #dee2e6;
}

#exam-questions-area .checkbox-item:hover {
    background-color: #e9ecef;
    border-color: #ced4da;
}

#exam-questions-area .checkbox-item input[type="radio"]:checked + label {
    font-weight: 500;
    color: var(--primary-dark);
}

#exam-questions-area .checkbox-item:has(input[type="radio"]:checked) {
    background-color: #e3f2fd;
    border-color: #90caf9;
}

/* explicitly show the edit button once confirmed */
#exam-questions-area .question.confirmed .btn-edit {
    display: inline-flex ;
    visibility: visible ;
    opacity: 1 ;
}

#exam-questions-area .question.confirmed .btn-confirm {
    display: none ;
}

/* Confirmed badge */
#exam-questions-area .question.confirmed::after {
    font-size: 0.8em;
    background-color: #81c784;
    color: white;
    right: 10px;
    top: 10px;
    padding: 3px 10px;
    border-radius: 15px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* ==========================================================================
   STICKY TIMER (pinned to top)
   ========================================================================== */
.sticky-timer {
	position: sticky;
    top: 15px;
    left: 50%;
	transform: translateX(-50%);
	color: white;
    z-index: 1000;
    font-size: 1.1em;
    font-weight: 700;
    padding: 12px 24px;
    border-radius: 30px;
    box-shadow: 0 3px 15px rgba(0,0,0,0.15);
	background-color: var(--primary-color);
    transition: background-color 0.5s ease; /* Smooth background transition */
}
.sticky-timer i {
  font-size: 1.2em;
  margin-right: 8px; 
}
.sticky-timer.warning {
    background: linear-gradient(to right, #ff9800, #f57c00);
}

.sticky-timer.danger {
    background: linear-gradient(to right, #f44336, #d32f2f);
	animation: pulse 0.8s infinite alternate;
}
.sticky-timer.expired {
	background: #6c757d;
}

@keyframes pulse {
  from { transform: translateX(-50%) scale(1); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
  to   { transform: translateX(-50%) scale(1.03); box-shadow: 0 4px 15px rgba(211,47,47,0.4); }
}

/* 3. Time Warning Styles */
body.time-warning {
    background-color: #dbdbdb; /* Light yellow background */
    transition: background-color 1s;
}

body.time-danger {
    background-color: #8a7d7d; /* Light red background */
    transition: background-color 1s;
}

body.time-expired {
    background-color: ##2e2e2e; /* Deeper red for expired */
}

/* 4. Backup Import Modal */
.backup-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s;
}

.backup-modal.visible {
    opacity: 1;
    visibility: visible;
}

.backup-modal-content {
    background-color: white;
    border-radius: 10px;
    width: 90%;
    max-width: 600px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
    max-height: 90vh;
    transform: scale(0.9);
    transition: transform 0.3s;
}

.backup-modal.visible .backup-modal-content {
    transform: scale(1);
}

.backup-modal-header {
    padding: 15px 20px;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.backup-modal-header h3 {
    margin: 0;
    color: var(--primary-dark);
}

.backup-close-btn {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #999;
}

.backup-modal-body {
    padding: 20px;
    overflow-y: auto;
    flex-grow: 1;
}

.backup-modal-footer {
    padding: 15px 20px;
    border-top: 1px solid #eee;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.backup-preview {
    margin-top: 15px;
    padding: 15px;
    background-color: #f5f5f5;
    border-radius: 5px;
    max-height: 200px;
    overflow-y: auto;
}

.backup-info p {
    margin: 5px 0;
}

.backup-error {
    color: var(--danger-color);
}






        /* --- Multiple Select Checkbox Styling --- */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            transition: opacity 0.3s, background-color 0.3s, color 0.3s;
            padding: 5px;
            border-radius: 4px;
        }
        /* Style the checkbox input itself */
        .checkbox-item input[type="checkbox"].form-control-checkbox {
            margin-right: 8px;
            cursor: pointer;
            width: 18px;
            height: 18px;
            flex-shrink: 0; /* Prevent checkbox from shrinking */
            transition: opacity 0.3s; /* Add transition */
        }
         /* Style the label associated with the checkbox */
         .checkbox-item label {
             margin-bottom: 0;
             font-weight: normal;
             cursor: pointer;
             flex-grow: 1;
             transition: color 0.3s; /* Add transition */
         }
        /* --- End Checkbox Styling --- */

/* Style for code question prompts */
    label.code-prompt {
        white-space: pre-wrap; /* Respects whitespace and line breaks */
        font-family: monospace; /* Use a monospace font */
        display: block; /* Ensure label takes full width */
        background-color: #f8f9fa; /* Light background like code blocks */
        padding: 10px; /* Add some padding */
        border: 1px solid #eee; /* Subtle border */
        border-radius: 4px;
        line-height: 1.4; /* Adjust line spacing */
        margin-bottom: 10px; /* Add margin below prompt */
    }
    /* Style for emphasized terms */
    label em.term, div em.term { /* Target em tags with class term inside labels or divs */
        font-style: italic;
        font-weight: bold; /* Make italicized terms also bold */
        color: var(--primary-dark); /* Use a distinct color */
    }

#submit-exam-btn {
    margin-top: 30px;
    width: 100%;
    padding: 15px;
    font-size: 1.1em;
    border-radius: 30px;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

#submit-exam-btn {
    background: linear-gradient(to right, #43a047, #2e7d32);
    font-weight: 500;
    padding: 15px 30px;
    border-radius: 30px;
    box-shadow: 0 4px 12px rgba(46, 125, 50, 0.3);
    transition: all 0.3s ease;
}

#submit-exam-btn:hover:not(:disabled) {
    box-shadow: 0 6px 16px rgba(46, 125, 50, 0.4);
    transform: translateY(-2px);
}

#submit-exam-btn::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to right, rgba(255,255,255,0.1), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s ease;
}

#submit-exam-btn:hover::after {
    transform: translateX(100%);
}
        .hidden {
            display: none ;
        }
        #timer-display {
            font-weight: bold;
        }
        .confirmation-message {
            text-align: center;
            font-weight: bold;
            color: var(--success-color);
            padding: 30px;
            font-size: 1.2em;
        }
        .file-helper-text {
            display: block;
            margin-top: 5px;
            color: #666;
            font-size: 0.85em;
        }
        .length-limit-note { /* Style for the code length note */
            display: block;
            margin-top: 5px;
            color: #757575;
            font-size: 0.8em;
            font-style: italic;
        }
        @media (max-width: 768px) {
            .sync-auth-container {
                flex-direction: row;
               flex-wrap: nowrap;
                gap: 10px;
                border-bottom: none;
            }
            .auth-container,
            .sync-container {
                width: 100%;
                justify-content: flex-end;
            }
            .in-page-notifications {
                width: 90%;
                left: 50%;
                transform: translateX(-50%);
            }
			    #exam-questions-area .checkbox-group {
        flex-direction: column;
    }
    
    #exam-questions-area .checkbox-item {
        width: 100%;
        margin-right: 0 ;
    }
	
	#exam-questions-area .question.confirmed .CodeMirror {
    display: none;
}
    
    .app-info {
        flex-direction: column;
    }
    
    .info-item {
        width: 100%;
        margin-bottom: 5px;
    }
        }
    </style>

</head>
<body class="content-hidden">
    <div id="app-loading" class="app-loading">
        <img src="https://raw.githubusercontent.com/bredliplaku/bredliplaku.github.io/refs/heads/main/loading.gif" alt="Loading..." style="width: 150px; height: 150px;">
        <div style="margin-top: 10px; font-size: 14px; color: #666;">Loading Exam Portal...</div>
    </div>
    <div class="container" id="main-container">
        <div class="sync-auth-container">
            <div class="sync-container">
                 <div id="sync-status" class="sync-status offline">
                    <i class="fas fa-circle"></i>
                    <span id="sync-text">Offline</span>
                </div>
            </div>
            <div class="auth-container">
                 <div id="login-container">
                    <button id="login-btn" class="btn-blue">
                        <i class="fas fa-sign-in-alt"></i> Sign in
                    </button>
                </div>
                <div id="user-container" style="display: none">
                    <div class="user-info">
                        <img id="user-avatar" class="user-avatar" src="" alt="Avatar">
                        <span id="user-name"></span>
                         <button id="logout-btn" class="btn-sm">
                            <i class="fas fa-sign-out-alt"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <div class="app-header">
            <h1><i class="fa-solid fa-clipboard-question"></i> Exam Portal</h1>
            <h2 id="exam-name-header">Enter PIN to load exam</h2>
            <div class="app-info">
                <span class="info-item">
                     <i class="fa-solid fa-table-list"></i> Course:
                    <span id="exam-code-display">N/A</span>
                </span>
                <span class="info-item">
                    <i class="far fa-clock fa-spin"></i> Duration:
                     <span id="exam-duration-display">N/A</span>
                </span>
                <span class="info-item">
                    <i class="fas fa-calendar-alt"></i> Start Time:
                    <span id="exam-start-time-display">N/A</span>
                 </span>
            </div>
        </div>
        <div id="in-page-notification-area" class="in-page-notifications"></div>
        <div id="signin-prompt-module" class="module">
            <div class="module-content not-signed-in-message">
                <h3><i class="fas fa-info-circle"></i> Welcome</h3>
                <p>Sign in with your University Google Account.</p>
            </div>
        </div>
        <div id="exam-start-module" class="module hidden">
            <div class="module-header">
                <span class="module-title">
                    <i class="fas fa-user-check"></i> Student Details
                </span>
            </div>
            <div class="module-content">
                <div class="form-group">
                    <label for="student-name">Name:</label>
                     <input type="text" id="student-name" class="form-control" disabled>
                </div>
                <div class="form-group">
                    <label for="student-email">Email:</label>
                    <input type="email" id="student-email" class="form-control" disabled>
                </div>
                  <div class="form-group">
                    <label for="exam-pin-input">Exam PIN:</label>
                    <input type="text" id="exam-pin-input" class="form-control" placeholder="The lecturer will provide you with the PIN">
                </div>
                <div id="student-exam-id-group" class="form-group hidden">
                    <label for="student-exam-id-input">Student Exam ID (Confidential - 5 characters):</label>
                    <input type="text" id="student-exam-id-input" class="form-control" placeholder="Enter your Exam ID from the attendance sheet" maxlength="5">
                </div>
                <button id="load-exam-btn" class="btn-blue" disabled>
                     <i class="fas fa-download"></i> Load Exam
                </button>
                <button id="start-exam-btn-alt" class="btn-green hidden" disabled>
                    <i class="fas fa-play"></i> Start Exam
                </button>
             </div>
        </div>
        <div id="exam-details-module" class="module hidden">
            <div class="module-header">
                <span class="module-title">
                    <i class="fas fa-info-circle"></i> Exam Information
                </span>
             </div>
            <div class="module-content" id="exam-details-display">
                <p>
                    <strong>Exam Name:</strong>
                    <span id="exam-name-detail"></span>
                </p>
                 <p>
                    <strong>Course Code:</strong>
                    <span id="exam-course-code-detail"></span>
                </p>
                <p>
                      <strong>Mode:</strong>
                    <span id="exam-mode-detail"></span>
                </p>
                <p>
                    <strong>Duration:</strong>
                    <span id="exam-duration-detail"></span>
                 </p>
                <p>
                    <strong>Start Time:</strong>
                    <span id="exam-start-time-detail"></span>
                </p>
                 <button id="start-exam-btn" class="btn-green" disabled>
                    <i class="fas fa-play"></i> Start Exam
                </button>
            </div>
        </div>
        <div id="exam-questions-module" class="module hidden">
            <div class="module-header">
                 <span class="module-title">
                    <i class="fa-solid fa-list-ol"></i> Exercises
                </span>
                <!-- <span class="info-item" style="background-color: var(--danger-color); color: white;"> -->
                    <!-- <i class="fas fa-stopwatch"></i> Time Left: -->
                    <!-- <span id="timer-display">--:--</span> -->
                <!-- </span> -->
            </div>
            <div class="module-content">
                 <form id="exam-form">
                    <div id="exam-questions-area">
                        <p>Loading questions...</p>
                    </div>
                    <button type="button" id="submit-exam-btn" class="btn-green" disabled>
                         <i class="fas fa-check-circle"></i> Submit Exam
                    </button>
                </form>
            </div>
        </div>
        <div id="submission-confirmation-module" class="module hidden">
              <div class="module-content confirmation-message">
                <i class="fas fa-check-circle fa-3x" style="color: var(--success-color); margin-bottom: 15px;"></i><br>
                Exam Submitted Successfully!
            </div>
        </div>
    <footer class="footer">
        <div class="social-links">
            <a href="https://eis.epoka.edu.al/cv/fullcv/655" target="_blank" rel="noopener noreferrer"><i class="far fa-id-card"></i></a>
            <a href="mailto:bplaku@epoka.edu.al" target="_blank" rel="noopener noreferrer"><i class="far fa-envelope"></i></a>
        </div>
        <p style="font-size:0.7em"><i class="far fa-copyright"></i> 2023-<span id="currentYear"></span> Bredli Plaku. All Rights Reserved.</p>
    </footer>
    </div>

<script>
        // === Configuration ===
        const ADMIN_EMAILS = ['bplaku@epoka.edu.al'];
        const CLIENT_ID = '740588046540-npg0crodtcuinveu6bua9rd6c3hb2s1m.apps.googleusercontent.com'; // Keep for sign-in
        const SCOPES = "https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile";

        // --- !!! ADD YOUR DEPLOYED APPS SCRIPT URL HERE !!! ---
        const BACKEND_URL = 'https://script.google.com/macros/s/AKfycbx-jSJ9gVzM6b975hEY6bEbM3JOTawq5Av8LE61-gJV8mi7cymPq9lj3k9OZJpxCrlD/exec';

        // === App State ===
        let isAdmin = false;
        let isSignedIn = false;
        let currentUser = null;
        let tokenClient = null;
        let isOnline = navigator.onLine;
        let isSyncing = false; // Still useful for read operations
        let isInitializing = true;
        let examDetails = null;         // Holds the loaded exam data {PIN, Code, Name, Duration, StartDate, StartTime, Mode, Questions, OriginalOrderMap}
        let studentPINEntered = '';     // PIN entered by the student
        let studentExamIdEntered = '';  // 5-character ID ONLY for 'Exam' mode, entered by student
        let examTimerInterval = null;   // Interval ID for the countdown timer
        let examEndTime = null;         // Absolute end time (timestamp in ms)
        const appStateKey = 'examAppState'; // Key for localStorage
		let totalQuestions = 0; // To track total number of questions displayed
		let confirmedQuestionsCount = 0; // To track confirmed questions
		let tokenRefreshTimer = null;        // Timer for periodic token refresh
		let inactivityTimer = null;          // Timer to detect inactivity
		let lastActivityTime = Date.now();   // Timestamp of last user activity
		let autoSaveTimer = null;            // Timer for auto-saving answers
		let codeEditors = {}; // Object to store CodeMirror instances by answerId



        // === DOM Elements === (Keep all these as they are used for UI)
        const loadingIndicator      = document.getElementById('app-loading');
        const mainContainer         = document.getElementById('main-container');
        const syncStatus            = document.getElementById('sync-status');
        const syncText              = document.getElementById('sync-text');
        const loginBtn              = document.getElementById('login-btn');
        const logoutBtn             = document.getElementById('logout-btn');
        const loginContainer        = document.getElementById('login-container');
        const userContainer         = document.getElementById('user-container');
        const userName              = document.getElementById('user-name');
        const userAvatar            = document.getElementById('user-avatar');
        const notificationArea      = document.getElementById('in-page-notification-area');
        const examNameHeader        = document.getElementById('exam-name-header');
        const examCodeDisplay       = document.getElementById('exam-code-display');
        const examDurationDisplay   = document.getElementById('exam-duration-display');
        const examStartTimeDisplay  = document.getElementById('exam-start-time-display');
        const signinPromptModule    = document.getElementById('signin-prompt-module');
        const examStartModule       = document.getElementById('exam-start-module');
        const studentNameInput      = document.getElementById('student-name');
        const studentEmailInput     = document.getElementById('student-email');
        const examPinInput          = document.getElementById('exam-pin-input');
        const studentExamIdGroup    = document.getElementById('student-exam-id-group');
        const studentExamIdInput    = document.getElementById('student-exam-id-input');
        const loadExamBtn           = document.getElementById('load-exam-btn');
        const examDetailsModule     = document.getElementById('exam-details-module');
        const examDetailsDisplay    = document.getElementById('exam-details-display');
        const examNameDetail        = document.getElementById('exam-name-detail');
        const examCourseCodeDetail  = document.getElementById('exam-course-code-detail');
        const examModeDetail        = document.getElementById('exam-mode-detail');
        const examDurationDetail    = document.getElementById('exam-duration-detail');
        const examStartTimeDetail   = document.getElementById('exam-start-time-detail');
        const startExamBtn          = document.getElementById('start-exam-btn'); // Button in Details module (Quiz mode)
        const startExamBtnAlt       = document.getElementById('start-exam-btn-alt'); // Button in Start module (Exam mode)
        const examQuestionsModule   = document.getElementById('exam-questions-module');
        const examForm              = document.getElementById('exam-form');
        const examQuestionsArea     = document.getElementById('exam-questions-area');
        const submitExamBtn         = document.getElementById('submit-exam-btn');
        const timerDisplay          = document.getElementById('timer-display');
        const submissionConfirmationModule = document.getElementById('submission-confirmation-module');
		const TOKEN_REFRESH_INTERVAL = 20 * 60 * 1000; // 20 minutes in milliseconds
		const INACTIVITY_WARNING_TIME = 15 * 60 * 1000; // 15 minutes in milliseconds
		const AUTO_SAVE_INTERVAL = 3 * 60 * 1000; // 3 minutes in milliseconds


        // === Initialisation ===
        window.addEventListener('load', init);

    function init() {
        console.log("Initialising...");
        document.body.classList.remove('content-hidden');
        mainContainer.classList.add('content-visible');
        updateYear();
        setupEventListeners();
        loadAppState(); // Load any saved state early
        updateOnlineStatus();
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);
		setupBackupImportFeature();

        // Delay API init slightly
        setTimeout(() => {
            if (typeof gapi !== 'undefined' && typeof google !== 'undefined') {
                initGoogleApi();
            } else {
                handleApiInitError(new Error("Google API objects not loaded"));
            }
        }, 500);
    }

        function setupEventListeners() {
            loginBtn?.addEventListener('click', handleAuthClick);
            logoutBtn?.addEventListener('click', handleSignoutClick);
            loadExamBtn?.addEventListener('click', handleLoadExam);
            startExamBtn?.addEventListener('click', handleStartExam); // For Quiz mode
            startExamBtnAlt?.addEventListener('click', handleStartExam); // For Exam mode
            submitExamBtn?.addEventListener('click', () => handleSubmitExam(false)); // Manual submit trigger

            // Enable load button only when PIN is entered, signed in, and online
            examPinInput?.addEventListener('input', () => {
                if (loadExamBtn) {
                    loadExamBtn.disabled = examPinInput.value.trim() === '' || !isSignedIn || !isOnline;
                }
            });

            // Validate Student Exam ID input for Exam mode
            studentExamIdInput?.addEventListener('input', validateStudentExamIdInput);

            // Initial button states
            if (loadExamBtn) loadExamBtn.disabled = true;
            if (startExamBtn) startExamBtn.disabled = true;
            if (startExamBtnAlt) startExamBtnAlt.classList.add('hidden'); // Hide Exam mode button initially
            if (submitExamBtn) submitExamBtn.disabled = true;
        }
		
		setupSessionManagement();

        function showAppContent() {
            loadingIndicator?.classList.add('hidden');
            mainContainer?.classList.add('content-visible');
            console.log("App content shown.");
        }

        function updateYear() {
            const el = document.getElementById('currentYear');
            if (el) {
                el.textContent = new Date().getFullYear();
            }
        }
		
function setupSessionManagement() {
    // Setup activity tracking
    document.addEventListener('mousemove', recordUserActivity);
    document.addEventListener('keydown', recordUserActivity);
    document.addEventListener('click', recordUserActivity);
    
    // Initial activity timestamp
    lastActivityTime = Date.now();
    
    // Set up auto-save for answers
    startAutoSave();
}

function recordUserActivity() {
    const now = Date.now();
    const timeSinceLastActivity = now - lastActivityTime;
    lastActivityTime = now;
    
    // If there was a significant gap in activity, consider refreshing the token
    if (timeSinceLastActivity > 10 * 60 * 1000) { // 10 minutes
        console.log(`Detected activity after ${timeSinceLastActivity/1000}s inactivity, refreshing token...`);
        refreshTokenIfNeeded(true); // Force refresh
    }
    
    // Reset inactivity timer if it exists
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
        inactivityTimer = null;
    }
    
    // Start inactivity detection
    startInactivityDetection();
}

function initializeCodeEditor(textareaId, language = 'python') {
    const textarea = document.getElementById(textareaId);
    if (!textarea) {
        console.warn(`Cannot initialize code editor: textarea #${textareaId} not found`);
        return null;
    }
    
    if (typeof CodeMirror === 'undefined') {
        console.warn('CodeMirror library not loaded. Using regular textarea.');
        return null;
    }
    
    console.log(`Initializing simple code editor for ${textareaId} with language ${language}`);
    
    try {
        // Initialize CodeMirror directly on the textarea (replacing it)
        const editor = CodeMirror.fromTextArea(textarea, {
            mode: language || "python",
            theme: "monokai",
            lineNumbers: true,
            indentUnit: 4,
            tabSize: 4,
            indentWithTabs: false,
            matchBrackets: true,
            autoCloseBrackets: true,
            lineWrapping: true,
            extraKeys: {
                "Tab": function(cm) {
                    if (cm.somethingSelected()) {
                        cm.indentSelection("add");
                    } else {
                        cm.replaceSelection("    ", "end");
                    }
                }
            }
        });
        
        // Make the editor a bit taller for better visibility
        editor.setSize(null, 150);
        
        // Store the editor instance
        codeEditors[textareaId] = editor;
        console.log(`Code editor initialized for ${textareaId}`);
        
        return editor;
    } catch (e) {
        console.error(`Error initializing CodeMirror for ${textareaId}:`, e);
        // Show the original textarea as fallback
        textarea.style.display = 'block';
        return null;
    }
}

function enhancePointsDisplay() {
    const questionStrongs = document.querySelectorAll('#exam-questions-area .question strong');
    questionStrongs.forEach(strong => {
        if(strong.textContent.includes('point')) {
            const text = strong.textContent;
            const pointsMatch = text.match(/\((\d+) points?\)/);
            if(pointsMatch && pointsMatch[1]) {
                const points = pointsMatch[1];
                strong.innerHTML = text.replace(/\(\d+ points?\)/, `(${points} <span class="points-badge">${points} pts</span>)`);
            }
        }
    });
}

// Starts the inactivity detection timer
function startInactivityDetection() {
    // Clear any existing timer
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
    }
    
    // Set new timer to detect inactivity
    inactivityTimer = setTimeout(() => {
        const inactiveTime = Date.now() - lastActivityTime;
        if (inactiveTime >= INACTIVITY_WARNING_TIME) {
            showInactivityWarning();
        }
    }, INACTIVITY_WARNING_TIME);
}

// Shows a warning when user has been inactive
function showInactivityWarning() {
    showImprovedNotification(
        'warning', 
        'Session Expiring Soon', 
        'You appear to be inactive. Please click, type, or move your mouse to keep your session active.', 
        0 // Don't auto-dismiss
    );
    
    // Play a sound to alert the user (optional)
    try {
        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj2a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PruXI3DypsuO7Lfy4GFmS09tW0XigPRJXn8s13Hw0sbsfz4ZU+CxFVru/mtGYpDj6S5fPQgzMKFVyy9NeybCYQPZHk9dOIPAoTW7L11rVvKRE5j+P30oc9DBJZsvTYuXMqETiM4vfWjUIMEFew89e6disRNorm99SNQAwPVK/y2bt3LBE0i+X115FDDBBTrvPau3gtEDOJ5PfYk0ULDlCt8tu8ei4PMIjj+duXSAsMTarx3L56Lw8vhOP53JlKCwxKqfLdvXwwDi2C4/vem0sKCkmo8t/AfTANK3/i/OCdTQoJRqbx4MKAMgwqfeL84p9PCwhEpfDhw4IzCyl74fzjoVELCEKk8OLEgzQLKHnh/OWhUgsIPqPv5MWENComeOL96KNTCwc9oe/lxoY1CSV24v3ppVQMBzug7+bHiDYJJHTi/eulVQ0GN5/u58iJNwkic+P+66dXDQY2nu7oyos3CSBx4v7tqVkOBTWd7enLjDgJH3Di/+2rWw4FNJL9gsdlS0dlWID/q1sOBTOS/4LHZUtHZViA/6tcDgQx9f46vMG0g/iuXQ4EMfX+OrzBtIP4r14PBC/0/j+xwbKC+bBfDwMu9P8/scGygvmxYBADLvP/Q6/BsYL6s2IRBC3y/0Suwbrt+RSjqz3JkcgTKK3x/0WuwbnskRqeqT3EmcMXJ6vw/0etx8OUEhUilELQrtAeKKrv/0erycuiDQgLaTniyOUxLajt/0eqzNe2BwEEfjHxw+k8Nqbq/0qpztunAQEGkyz/uOVFP6nn/FvP3P5q/9oIC5s9nnMUNJDS/8G44zN4VxiPw/Ds/38uYvbzGI5TFhVwwO6dOnUGTUb/PYFWEQhwv/ChQIYL/Fk3/0WKPBAEb8ABqEyGA/lWMvxJlDERAHPBBaxSgAL9VCj7TJ0qEgFzwgmwWHoC/1Ij+0+kIhQDc8MNsV11Av9TIP1SmxkVA3LEELJhcAT/Uh37Vp8SFwZyxRSzZmkF/1Ia/LineRcIcsUYtGpiBf9TF/5fpHEXCXLGG7ZvWwb/VBb/ZKlpGApwxx26dFQH/1MV/2muYBkMb8cfvXlNCP9WFP9ttFgZDW3HIL98Rgj/Stb9Km2yUhsObMgiwIE/CP9F3P0bbr9KHBBqySPBhzcJ/0Di/RBvxUIdEmnKJcWMMAr/O+f+CW/KOh4UZ8wnx5EpC/8y7f8Bb88yHhVlzCrKliIM/0Tz/59w1CofFmTNLM2aGg3/Pe///HHZICAXYs4u0J8TDv8v9gDxcNwYIhlgzi/SoxMP/yf4Ad9v3xAkGl7PMdSoSxL/OvsCw27jCCQcXNAy1q5CFP8z8AOpcOYAJh1a0TTasD0V/yvxBJlv6fgnHljRNdy2ORb/JPMFiW7s9CgfVtI33bozF/8f9QZ4bO/qKSBV0zjfwCwY/xr3B2lr8uAqIVPUOuDGJhn/FPgIWWrz1SshUtU74MsgGf8S+gg4Z/TLLCJr1TzhziCJMpT+AiVA/Fxr988tI2rVN+HPQBozk/sCKFD9YW3/4C8jatU15tZlHF2P+wYygP+YdPMzLyRp1TOc42AgfIT5BiWY+/l9CDswKWnUMjr0Mg0qcPkArP4Bhh9GL0g31jF7/mz4sS5MKvxaWPg6Li3WL8F7+dDtCDe+Mx5NeA1SLSDKCJfzBJXw0jMQVY8WSS83xmBXvhSDVxdW0GceHnbfH4dTE1LjaSYZ2OQVlFcLWeRsJRHh7gqhXQBi33QcCP36BrhkljgLPgwjEP0E0SxLvzkLy3h80wxsxkfYbdUGOw0O/sMZq4yOqMfD5hQyDQr8yxyhjIyoyM7tGS0LCPvRHqCLiqnL2vIbKQgH+tghn4qJqM3h9R4lCAb42iOeiYmoz+j4IR8GA/fcJZ2JiKjP7vogHwYC9d0nnImIqM7s/CEfBgH03SiciIiozuz9Ih8I');
        audio.play().catch(e => console.warn("Could not play alert sound:", e));
    } catch(e) {
        console.warn("Could not create alert sound:", e);
    }
}

// Periodic token refresh
function startTokenRefresh() {
    // Clear any existing timer
    stopTokenRefresh();
    
    console.log("Starting token refresh timer");
    tokenRefreshTimer = setInterval(() => {
        refreshTokenIfNeeded(false);
    }, TOKEN_REFRESH_INTERVAL);
}

// Stop token refresh timer
function stopTokenRefresh() {
    if (tokenRefreshTimer) {
        clearInterval(tokenRefreshTimer);
        tokenRefreshTimer = null;
    }
}

// Refresh token if needed or if forced
async function refreshTokenIfNeeded(force = false) {
    // Only try to refresh if signed in
    if (!isSignedIn || !tokenClient) {
        console.log("Not refreshing token: not signed in or no tokenClient");
        return false;
    }
    
    // Check for stored token
    const savedTokenStr = localStorage.getItem('gapi_token');
    if (!savedTokenStr) {
        console.log("No token to refresh");
        return false;
    }
    
    try {
        const savedToken = JSON.parse(savedTokenStr);
        
        // If forced or token is older than 40 minutes, refresh it
        // Note: Google tokens typically last 1 hour
        const tokenAgeMs = Date.now() - (savedToken.issued_at || 0);
        const needsRefresh = force || tokenAgeMs > 40 * 60 * 1000;
        
        if (needsRefresh) {
            console.log(`Token age: ${tokenAgeMs / 1000}s - Refreshing token...`);
            
            // Request a new token with the same account
            tokenClient.requestAccessToken({ prompt: '' });
            return true;
        } else {
            console.log(`Token age: ${tokenAgeMs / 1000}s - No refresh needed`);
            return false;
        }
    } catch (e) {
        console.error("Error refreshing token:", e);
        return false;
    }
}

// Auto-save answers periodically
function startAutoSave() {
    // Clear any existing timer
    stopAutoSave();
    
    console.log("Starting auto-save timer");
    autoSaveTimer = setInterval(() => {
        if (examQuestionsModule && !examQuestionsModule.classList.contains('hidden')) {
            autoSaveAnswers();
        }
    }, AUTO_SAVE_INTERVAL);
}

// Stop auto-save timer
function stopAutoSave() {
    if (autoSaveTimer) {
        clearInterval(autoSaveTimer);
        autoSaveTimer = null;
    }
}

// Automatically save current answers to localStorage
function autoSaveAnswers() {
    // Only auto-save if exam is in progress
    if (!examQuestionsModule || examQuestionsModule.classList.contains('hidden') || !examDetails) {
        return;
    }
    
    console.log("Auto-saving current answers...");
    try {
        // Collect current answers
        const currentAnswers = {};
        const confirmationStatus = {};
        
        // Use the original indices to collect answers
        const originalIndices = Object.keys(examDetails.OriginalOrderMap).map(Number).sort((a, b) => a - b);
        originalIndices.forEach(originalIndex => {
            const originalQNum = originalIndex + 1;
            const answerName = `ans-${originalQNum}`;
            const questionDivId = `q-${originalQNum}`;
            const questionDiv = document.getElementById(questionDivId);
            
            // Get confirmation status
            if (questionDiv) {
                confirmationStatus[questionDivId] = questionDiv.classList.contains('confirmed');
            }
            
            // Get answer value based on question type
            const questionData = examDetails.OriginalOrderMap[originalIndex];
            if (!questionData) return;
            
            const formElement = examForm.elements[answerName];
            if (formElement) {
                switch (questionData.type) {
                    case 'multiple_select':
                        currentAnswers[answerName] = formElement.value || '';
                        break;
                    case 'attachment':
                        // Skip file inputs - just save "has file" status
                        currentAnswers[answerName] = (formElement.files && formElement.files.length > 0) 
                            ? 'FILE_SELECTED' : '';
                        break;
                    default:
                        currentAnswers[answerName] = formElement.value || '';
                }
            }
        });
        
        // Update the saved state with current answers and confirmation status
        const currentState = JSON.parse(localStorage.getItem(appStateKey) || '{}');
        currentState.currentAnswers = currentAnswers;
        currentState.confirmationStatus = confirmationStatus;
        localStorage.setItem(appStateKey, JSON.stringify(currentState));
        
        console.log("Answers auto-saved successfully");
    } catch (e) {
        console.error("Error auto-saving answers:", e);
    }
}



// === Google API & Auth === (Simplified)
function initGoogleApi() {
        console.log('Initialising Google Sign-In and GAPI client...');
        try {
            // Initialize the token client first
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: handleTokenResponse
            });

            // Load the base GAPI client library. This is needed for gapi.client.setToken/getToken.
            // We don't need to init specific APIs like 'sheets' here anymore.
            gapi.load('client', async () => {
                console.log('GAPI client library loaded.');
                // No need for gapi.client.init({apiKey: ..., discoveryDocs: ...}) here
                // unless you use other gapi.client services later.

                // Now that 'client' is loaded, check for saved token
                checkSavedTokenAndProceed();
            });

        } catch (error) {
            handleApiInitError(error);
        }
    }
	
	async function checkSavedTokenAndProceed() {
         const savedToken = localStorage.getItem('gapi_token');
            if (savedToken) {
                const token = JSON.parse(savedToken);
                if (token?.access_token /* && !isTokenExpired(token) */) {
                    try {
                        // gapi.client should be available now
                        gapi.client.setToken(token); // Set token for potential use (like fetchUserInfo originally did)
                        console.log("Using saved token.");
                        await tokenObtained(token); // Process the existing token
                    } catch (e) {
                         console.warn("Error setting saved token even after gapi.load:", e);
                         updateAuthUI(); // Show logged out UI if token can't be set
                         showAppContent();
                    }
                } else {
                    localStorage.removeItem('gapi_token');
                    console.log("Saved token invalid or expired.");
                    updateAuthUI();
                    showAppContent();
                }
            } else {
                 console.log("No saved token found.");
                 updateAuthUI();
                 showAppContent();
            }
    }

    function handleApiInitError(error) { // Keep as is
        console.error('API Initialisation Error:', error);
        showImprovedNotification('error', 'API Load Error', `Failed to load Google services: ${error.message}`);
        updateAuthUI();
        showAppContent();
    }

        // Placeholder for a proper token expiry check if needed
        function isTokenExpired(token) {
            // Implement logic to check token.expires_in or similar field
            return false;
        }

        function handleAuthClick() {
            if (tokenClient) {
                showImprovedNotification('info', 'Signing In', 'Opening Google Sign-In...');
                // Prompt the user to select an account and grant access.
                tokenClient.requestAccessToken({ prompt: 'select_account' });
            } else {
                console.error('Token client not initialised.');
                showImprovedNotification('error', 'Authentication Error', 'Authentication service is not ready. Please try again later.');
            }
        }

        // Callback function after user grants or denies access
        function handleTokenResponse(resp) {
            if (resp.error) {
			 console.error('Token response error:', resp);
			 let msg = `Authentication failed: ${resp.error}`;
			 if (resp.error === 'popup_closed_by_user') msg = 'Sign-in cancelled by user.';
			 if (resp.error === 'access_denied') msg = 'Access denied. Please grant permission to proceed.';
			 showImprovedNotification('error', 'Authentication Error', msg);
			 updateAuthUI();
			 showAppContent(); // Ensure content is visible
			 return;
            }
            console.log('Access token received.');
			localStorage.setItem('gapi_token', JSON.stringify(resp)); // Save token

        // Ensure gapi.client is loaded before setting token
        if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined') {
            gapi.client.setToken(resp); // Set token for GAPI client
            tokenObtained(resp); // Proceed with obtained token
        } else {
			console.error("handleTokenResponse: gapi.client not ready when token received!");
			showImprovedNotification('error', 'Authentication Problem', 'Could not process sign-in token properly. Please try signing out and signing back in, or reload the page.');
			// Optionally force sign-out to clear inconsistent state
			handleSignoutClick();
        }
        }

        // Called after a token is successfully obtained (new or saved)
        async function tokenObtained(token) {
			console.log("Token available, proceeding...");
			isSignedIn = true;
			// Pass the token object directly to fetchUserInfo
			await fetchUserInfo(token);
			updateAuthUI(); // Update UI to logged-in state
			showAppContent();

            // Check if there's a saved exam state for this user
            const loadedState = JSON.parse(localStorage.getItem(appStateKey) || '{}');
            if (currentUser &&
                loadedState.currentUserEmail === currentUser.email &&
                loadedState.examEndTime &&
                Date.now() < loadedState.examEndTime) {
                console.log("Attempting to restore active exam session.");
                restoreAppState(loadedState); // Try to restore the previous session
            } else if (loadedState.currentUserEmail) {
                console.log("Saved state is invalid or expired for the current user.");
                localStorage.removeItem(appStateKey); // Clear invalid/old state
                saveAppState(); // Save a clean initial state if needed
            }
			startTokenRefresh();
        }

// Modified to accept token object and use its access_token
    async function fetchUserInfo(tokenObject) { // Accepts token object
        // Use the access_token from the passed object
        const accessToken = tokenObject?.access_token;

        if (!accessToken) {
            console.warn("fetchUserInfo called without a valid access token in tokenObject.");
            // Handle error - maybe sign out?
            // Consider showing an error notification before signing out
            showImprovedNotification('error', 'Auth Error', 'Missing access token. Signing out.');
            handleSignoutClick(); // Force sign out if token is missing
            return;
        }

        console.log('Fetching user information using provided token...');
        try {
            // Use the browser's standard fetch API with the User Info endpoint
            const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                headers: {
                    // Use the access token directly from the function argument
                    'Authorization': `Bearer ${accessToken}`
                }
            });

            // Check if the fetch request itself was successful
            if (!response.ok) {
                // Handle specific errors like 401 Unauthorized (token expired/revoked)
                if (response.status === 401) {
                    console.warn("User Info fetch failed (401 - Unauthorized). Token might be invalid/expired. Signing out.");
                    showImprovedNotification('error', 'Auth Expired', 'Your session has expired. Please sign in again.');
                    handleSignoutClick(); // Force sign out if token is invalid
                    return;
                }
                // Throw an error for other HTTP issues
                throw new Error(`(${response.status}) ${await response.text()}`);
            }

            // Parse the user information from the response
            const userInfo = await response.json();

            // Store the user details in the global currentUser variable
            currentUser = {
                id: userInfo.sub,
                name: userInfo.name || 'N/A',
                email: userInfo.email || 'N/A',
                picture: userInfo.picture || ''
            };
            console.log('User details fetched:', currentUser.email);
			// Ensure isAdmin is properly updated
    isAdmin = ADMIN_EMAILS.includes(currentUser?.email);
    document.body.classList.toggle('is-admin', isAdmin);
    console.log(`User role: ${isAdmin ? 'ADMIN' : 'STUDENT'}`);

            // Update UI elements with the fetched user info
            if (studentNameInput) studentNameInput.value = currentUser.name;
            if (studentEmailInput) studentEmailInput.value = currentUser.email;
            if (userAvatar) userAvatar.src = currentUser.picture;
            if (userName) userName.textContent = currentUser.name;

            // Check admin status based on the fetched email
            isAdmin = ADMIN_EMAILS.includes(currentUser.email);
            document.body.classList.toggle('is-admin', isAdmin);

            // Enable PIN input now that user is signed in and info is fetched
            if (examPinInput) examPinInput.disabled = false;

            // Re-evaluate load button state based on PIN input and online status
            if (loadExamBtn) {
                loadExamBtn.disabled = examPinInput.value.trim() === '' || !isOnline;
            }

        } catch (e) {
            // Handle any errors during the fetch or processing
            console.error('Fetch user info error:', e);
            showImprovedNotification('error', 'User Info Error', `Could not get user details: ${e.message}. Please try signing in again.`);
            currentUser = null; // Clear user info on error
            updateAuthUI(); // Update UI to reflect error state (likely show logged out)
        }
    }
	
	// Function to create sticky timer
function createStickyTimer() {
    // Remove any existing sticky timer first
    const existingTimer = document.querySelector('.sticky-timer');
    if (existingTimer) existingTimer.remove();
    
    // Create new sticky timer
    const stickyTimer = document.createElement('div');
    stickyTimer.className = 'sticky-timer';
    stickyTimer.innerHTML = `<i class="fas fa-stopwatch"></i> <span id="sticky-timer-display">--:--</span>`;
    document.body.appendChild(stickyTimer);
    
    return stickyTimer;
}

        function handleSignoutClick() {
            console.log("Signing out...");
            const token = localStorage.getItem('gapi_token'); // Get token from storage
		if (token) {
             const parsedToken = JSON.parse(token);
             if(parsedToken?.access_token && typeof google !== 'undefined' && google.accounts?.oauth2) {
                 try {
                     google.accounts.oauth2.revoke(parsedToken.access_token, () => console.log('Token revoked successfully.'));
                 } catch (e) { console.warn("Error revoking token:", e); }
             }
        }
        // Clear token from gapi.client if it exists
        if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined') {
             try { gapi.client.setToken(''); } catch(e) { console.warn("Error clearing gapi token on signout", e);}
        }
        localStorage.removeItem('gapi_token');
        localStorage.removeItem(appStateKey);

            // Reset application state variables
            isSignedIn = false;
            isAdmin = false;
            currentUser = null;
            examDetails = null;
            studentPINEntered = '';
            studentExamIdEntered = '';
            stopTimer(); // Stop any active exam timer

            resetExamState(); // Reset UI to initial state
            updateAuthUI(); // Update UI to logged-out state
            showImprovedNotification('info', 'Signed Out', 'You have been signed out.');
			
			stopTokenRefresh();
			stopAutoSave();
			if (inactivityTimer) {
				clearTimeout(inactivityTimer);
				inactivityTimer = null;
			}
        }


        // === UI State & Reset === (Keep as is)
        function resetExamState() {
            console.log("Resetting UI to initial state.");
            // Hide modules related to active exam
            examStartModule?.classList.add('hidden');
            examDetailsModule?.classList.add('hidden');
            examQuestionsModule?.classList.add('hidden');
            submissionConfirmationModule?.classList.add('hidden');
            studentExamIdGroup?.classList.add('hidden'); // Hide Student ID input

            // Show the initial sign-in prompt if it exists
            signinPromptModule?.classList.remove('hidden');

            // Reset input fields
            if (examPinInput) {
                examPinInput.value = '';
                examPinInput.disabled = true; // Disable until signed in
            }
            if (studentExamIdInput) studentExamIdInput.value = '';
            if (studentNameInput) studentNameInput.value = '';
            if (studentEmailInput) studentEmailInput.value = '';

            // Reset buttons to initial state
            if (loadExamBtn) {
                loadExamBtn.disabled = true;
                loadExamBtn.classList.remove('hidden');
                loadExamBtn.innerHTML = '<i class="fas fa-download"></i> Load Exam';
            }
            if (startExamBtn) startExamBtn.disabled = true;
            if (startExamBtnAlt) {
                startExamBtnAlt.classList.add('hidden');
                startExamBtnAlt.disabled = true;
            }
             if (submitExamBtn) { // Ensure submit button is reset correctly
                 submitExamBtn.disabled = true;
                 submitExamBtn.innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)';
             }

            // Reset header/details display
            const na = 'N/A';
            if (examCodeDisplay) examCodeDisplay.textContent = na;
            if (examDurationDisplay) examDurationDisplay.textContent = na;
            if (examStartTimeDisplay) examStartTimeDisplay.textContent = na;
            if (examNameHeader) examNameHeader.textContent = 'Please sign in to load the exam';
            if (examNameDetail) examNameDetail.textContent = '';
            if (examCourseCodeDetail) examCourseCodeDetail.textContent = '';
            if (examModeDetail) examModeDetail.textContent = '';
            if (examDurationDetail) examDurationDetail.textContent = '';
            if (examStartTimeDetail) examStartTimeDetail.textContent = '';

            // Clear questions area and timer
            if (examQuestionsArea) examQuestionsArea.innerHTML = '<p>Exam questions will appear here...</p>';
            stopTimer();
            if (timerDisplay) timerDisplay.textContent = '--:--';

            // Reset confirmation counts
            totalQuestions = 0;
            confirmedQuestionsCount = 0;
        }


        function updateAuthUI() {
            console.log('Updating Auth UI - SignedIn:', isSignedIn, 'CurrentUser:', !!currentUser);
            document.body.classList.toggle('is-admin', isAdmin);

            if (isSignedIn && currentUser) {
                // Logged-in state
                console.log('Showing logged-in UI.');
                loginContainer.style.display = 'none';
                userContainer.style.display = 'flex';
                signinPromptModule.classList.add('hidden'); // Hide sign-in prompt

                 // Show exam start module only if no exam is active/loaded yet
                 if (examStartModule && !examDetails && examQuestionsModule.classList.contains('hidden')) {
                     examStartModule.classList.remove('hidden');
                 }

                if (examPinInput) examPinInput.disabled = false; // Enable PIN input
                if (loadExamBtn) { // Enable load button if PIN is entered and online
                    loadExamBtn.disabled = examPinInput.value.trim() === '' || !isOnline;
                }

                // Populate user details fields
                if (studentNameInput) studentNameInput.value = currentUser.name || 'N/A';
                if (studentEmailInput) studentEmailInput.value = currentUser.email || 'N/A';
                if (userName) userName.textContent = currentUser.name || '';
                if (userAvatar) userAvatar.src = currentUser.picture || '';
            } else {
                // Logged-out state
                console.log('Showing logged-out UI.');
                loginContainer.style.display = 'flex';
                userContainer.style.display = 'none';
                resetExamState(); // Reset everything to initial logged-out view
                signinPromptModule.classList.remove('hidden'); // Ensure sign-in prompt is visible
            }
        }

        // Triggered when the "Load Exam" button is clicked (Keep as is)
        async function handleLoadExam() {
            studentPINEntered = examPinInput.value.trim();
            if (!studentPINEntered) {
                showImprovedNotification('warning', 'Missing PIN', 'Please Get your Exam ID from the attendance sheet.');
                return;
            }
            loadExamBtn.disabled = true;
            loadExamBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';

            await fetchExamDetails(studentPINEntered); // Fetch details FROM BACKEND NOW

            loadExamBtn.disabled = false;
            loadExamBtn.innerHTML = '<i class="fas fa-download"></i> Load Exam';

            if (startExamBtn) startExamBtn.disabled = !examDetails || !isOnline;
            if (startExamBtnAlt) startExamBtnAlt.disabled = !examDetails || !isOnline;
        }

        // Fetches exam configuration from the 'Exams' sheet based on PIN (Keep as is)
    async function fetchExamDetails(pin) {
        showImprovedNotification('info', 'Fetching Exam', `Loading details for PIN: ${pin}...`);
        setSyncing(true);

        examDetails = null; // Reset previous details
        examEndTime = null; // Reset end time

        try {
            const fetchUrl = `${BACKEND_URL}?pin=${encodeURIComponent(pin)}&action=getDetails`; // Ensure action=getDetails is sent if needed
            console.log(`Workspaceing exam details from backend: ${fetchUrl}`);

            const response = await fetch(fetchUrl, { /* ... GET request as before ... */ });

            if (!response.ok) { /* ... handle HTTP errors ... */ }

            const result = await response.json();
            console.log("Backend response (Exam Details):", result);

            if (result.success && result.examData) {
                const fetchedData = result.examData;
				const shuffleQuestions = String(fetchedData.ShuffleQuestions || 'yes').trim().toLowerCase();

                // Validate essential data
                const duration = parseInt(fetchedData.Duration, 10);
                const startTimestampUTC = fetchedData.StartTimestampUTC; // Get the timestamp
                const mode = String(fetchedData.Mode || 'Quiz').trim().toLowerCase();
                const questionsJson = String(fetchedData.Questions || '[]').trim();
                // Keep formatted date/time strings for display if needed
                const startDateStr = String(fetchedData.StartDate || '').trim();
                const startTimeStr = String(fetchedData.StartTime || '').trim();


                if (isNaN(duration) || duration <= 0) throw new Error("Invalid exam duration received from backend.");
                if (typeof startTimestampUTC !== 'number' || isNaN(startTimestampUTC)) {
                    throw new Error("Invalid StartTimestampUTC received from backend.");
                }
                // Basic JSON check for questions
                try { JSON.parse(questionsJson); } catch (e) { throw new Error(`Invalid questions JSON received: ${e.message}`); }


                // --- Calculate exam end time using the UTC timestamp ---
                try {
                    const startTimeFromSheet = startTimestampUTC; // USE THE TIMESTAMP DIRECTLY!
                    const durationMillis = duration * 60 * 1000;
                    examEndTime = startTimeFromSheet + durationMillis; // Calculate end timestamp in UTC ms

                    // Log using the reliable timestamp and formatted strings for clarity
                    console.log(`[TIMER CALC] StartDate: ${startDateStr}, StartTime: ${startTimeStr}, Received Start TS (UTC ms): ${startTimeFromSheet}, Duration(ms): ${durationMillis}, Calculated End TS (UTC ms): ${examEndTime} (${new Date(examEndTime).toLocaleString()})`); // Log local string representation of end time
                } catch (e) {
                    throw new Error(`Could not calculate exam end time: ${e.message}`);
                }


                // Store the loaded exam details
            examDetails = {
                PIN: fetchedData.PIN,
                Code: fetchedData.Code,
                Name: fetchedData.Name,
                Duration: duration,
                StartDate: startDateStr,
                StartTime: startTimeStr,
                Mode: mode,
                Questions: questionsJson,
                OriginalOrderMap: null,
                StartTimestampUTC: startTimestampUTC,
                shuffleQuestions: shuffleQuestions // Add the shuffle setting
            };
                console.log("Exam details processed successfully:", examDetails);

                displayExamDetailsHeader(); // Update header info (uses formatted strings)
                showImprovedNotification('success', 'Exam Loaded', `Details for "${examDetails.Name}" loaded successfully.`);

                     // Adjust UI based on exam mode (same logic as before)
                     if (examDetails.Mode === 'exam') {
                         console.log("Exam Mode detected: Showing Student Exam ID input.");
                         examStartModule.classList.remove('hidden'); studentExamIdGroup.classList.remove('hidden');
                         studentExamIdInput.value = ''; examDetailsModule.classList.add('hidden');
                         startExamBtnAlt.classList.remove('hidden'); startExamBtn.classList.add('hidden');
                         startExamBtn.disabled = true; loadExamBtn.classList.add('hidden');
                         validateStudentExamIdInput();
                     } else { // Quiz Mode
                         console.log("Quiz Mode detected: Showing Exam Information module.");
                         studentExamIdGroup.classList.add('hidden'); studentExamIdInput.value = '';
                         studentExamIdEntered = ''; examStartModule.classList.add('hidden');
                         displayExamDetailsFull(); examDetailsModule.classList.remove('hidden');
                         startExamBtnAlt.classList.add('hidden'); startExamBtn.classList.remove('hidden');
                         startExamBtn.disabled = !isOnline; loadExamBtn.disabled = true;
                         loadExamBtn.classList.remove('hidden');
                     }
                     saveAppState(); // Save the loaded state

                 } else {
                     // Backend reported failure (e.g., PIN not found)
                     throw new Error(result.message || "Exam details not found or backend error.");
                 }

            } catch (error) {
                 console.error(`Error fetching/processing exam details for PIN ${pin}:`, error);
                 showImprovedNotification('error', 'Exam Load Failed', `Could not load exam: ${error.message}`);
                 examDetails = null; // Ensure details are null on error
                 // Reset UI elements if needed
                 examDetailsModule.classList.add('hidden');
                 examStartModule.classList.remove('hidden'); // Show start module for retry
                 if (loadExamBtn) loadExamBtn.disabled = !isOnline;
                 resetExamState(); // Consider full reset on load failure
            } finally {
                setSyncing(false); // End network activity indication
            }
        }

        // Checks if all questions are confirmed and updates the main submit button (Keep as is)
function checkAllConfirmed() {
    // Only proceed if the questions area is visible and we know the total count
    if (!examQuestionsArea || examQuestionsModule.classList.contains('hidden') || totalQuestions <= 0) {
        if(submitExamBtn) {
            submitExamBtn.disabled = true;
            submitExamBtn.innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)';
        }
        return;
    }

    // Count questions that need confirmation (excluding text-only)
    const questionsRequiringConfirmation = document.querySelectorAll('.question:not(.text-only-question)').length;
    const confirmedNonTextOnly = document.querySelectorAll('.question.confirmed:not(.text-only-question)').length;
    
    const allConfirmed = confirmedNonTextOnly === questionsRequiringConfirmation;
    console.log(`Confirmed ${confirmedNonTextOnly}/${questionsRequiringConfirmation} questions. All confirmed: ${allConfirmed}`);

    if (submitExamBtn) {
        // Enable button only if all questions are confirmed AND user is online
        submitExamBtn.disabled = !allConfirmed || !isOnline;

        // Update button text for clarity
        if (allConfirmed && isOnline) {
            submitExamBtn.innerHTML = '<i class="fas fa-check-circle"></i> Submit Exam Now';
        } else if (!isOnline) {
             submitExamBtn.innerHTML = '<i class="fas fa-wifi"></i> Submit Exam (Offline)';
        } else {
             submitExamBtn.innerHTML = `<i class="fas fa-lock"></i> Submit Exam (${confirmedNonTextOnly}/${questionsRequiringConfirmation} Confirmed)`;
        }
    }
}

        // Validates the 5-character input for Student Exam ID in Exam mode (Keep as is)
        function validateStudentExamIdInput() {
            const startButtonToUse = startExamBtnAlt; // Use the Exam mode start button
            // Ensure button, input, and exam details (in exam mode) exist
            if (!startButtonToUse || !studentExamIdInput || !examDetails || examDetails.Mode !== 'exam') return;

            const idValue = studentExamIdInput.value.trim();
            const isValid = idValue.length === 5; // Simple length check

            // Enable/disable the Exam mode start button based on validity and online status
            startButtonToUse.disabled = !isValid || !isOnline;

            // Visual feedback for the input field
            studentExamIdInput.style.borderColor = (isValid || idValue === '') ? '#ccc' : 'red'; // Red border if invalid and not empty
        }

        // Updates the header section with basic exam details (Keep as is)
        function displayExamDetailsHeader() {
            if (!examDetails) return;
            if (examCodeDisplay) examCodeDisplay.textContent = examDetails.Code || 'N/A';
            if (examDurationDisplay) examDurationDisplay.textContent = `${examDetails.Duration} minutes`;
            const startTimeString = `${examDetails.StartDate || ''} ${examDetails.StartTime || ''}`.trim();
            if (examStartTimeDisplay) examStartTimeDisplay.textContent = startTimeString || 'N/A';
            if (examNameHeader) examNameHeader.textContent = examDetails.Name || 'Exam Loaded';
        }

        // Populates the dedicated "Exam Information" module (Quiz mode) (Keep as is)
        function displayExamDetailsFull() {
            if (!examDetails) return;
            if (examNameDetail) examNameDetail.textContent = examDetails.Name || 'N/A';
            if (examCourseCodeDetail) examCourseCodeDetail.textContent = examDetails.Code || 'N/A';
            // Capitalize mode for display
            const displayMode = examDetails.Mode ? (examDetails.Mode.charAt(0).toUpperCase() + examDetails.Mode.slice(1)) : 'N/A';
            if (examModeDetail) examModeDetail.textContent = displayMode;
            if (examDurationDetail) examDurationDetail.textContent = `${examDetails.Duration} minutes`;
            const startTimeString = `${examDetails.StartDate || ''} ${examDetails.StartTime || ''}`.trim();
            if (examStartTimeDetail) examStartTimeDetail.textContent = startTimeString || 'N/A';
        }


         // Checks if a 'submit' record already exists for this attempt (Keep as is, uses read-only)
async function checkIfAttemptExists(email, pin, studentExamId, mode) {
            console.log("Checking backend for existing 'submit' record...");
            setSyncing(true);
            try {
                // Construct URL parameters for the check
                const params = new URLSearchParams({
                    action: 'checkExists',
                    pin: pin,
                    mode: mode
                });
                if (mode === 'quiz') {
                    params.append('email', email);
                } else if (mode === 'exam') {
                    params.append('studentExamId', studentExamId);
                }

                const fetchUrl = `${BACKEND_URL}?${params.toString()}`;
                console.log(`Checking existence via backend: ${fetchUrl}`);

                const response = await fetch(fetchUrl, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });

                if (!response.ok) {
                    let errorMsg = `Backend check error! Status: ${response.status}`;
                    try { const errorData = await response.json(); errorMsg = errorData.message || errorMsg; } catch (e) {}
                    throw new Error(errorMsg);
                }

                const result = await response.json();
                console.log("Backend check response:", result);

                if (result.success) {
                    return result.exists; // Return true if backend found existing submission, false otherwise
                } else {
                    // Backend reported an error during the check
                    throw new Error(result.message || "Backend error during existence check.");
                }

            } catch (error) {
                console.error('Error checking submission existence via backend:', error);
                showImprovedNotification('error', 'Check Failed', `Could not verify previous submissions: ${error.message}. Assuming none exist.`);
                return false; // Default to false (allow starting) if the check fails, to avoid blocking students unfairly
            } finally {
                setSyncing(false);
            }
        }

        // Triggered when "Start Exam" button (Quiz or Exam mode) is clicked (Keep mostly as is)
async function handleStartExam() {
        if (!examDetails || !currentUser) {
            showImprovedNotification('error', 'Start Error', 'Cannot start the exam. User or exam details are missing.');
            return;
        }

        const currentMode = examDetails.Mode.toLowerCase();
        let identifierForCheck = null; // Variable to hold email or studentExamId

        // Validate and store Student Exam ID if in Exam mode
        if (currentMode === 'exam') {
            const currentStudentExamId = studentExamIdInput.value.trim(); // Read input value
            if (currentStudentExamId.length !== 5) {
                showImprovedNotification('error', 'Invalid ID', 'Please enter the 5-character Student Exam ID.');
                studentExamIdInput.focus(); // Focus the input for correction
                return;
            }
            // Store the validated ID globally AND use it for the check
            studentExamIdEntered = currentStudentExamId;
            identifierForCheck = studentExamIdEntered; // Use the ID for the check
            console.log(`Exam Mode: Using StudentExamID '${identifierForCheck}' for existence check.`);
        } else {
            // Quiz mode: Use email for the check
            studentExamIdEntered = ''; // Ensure global variable is clear for quiz mode
            identifierForCheck = currentUser.email;
             console.log(`Quiz Mode: Using Email '${identifierForCheck}' for existence check.`);
        }

        console.log("Performing pre-start checks...");

        // --- Check if already SUBMITTED (Uses the correct identifier now) ---
        const alreadySubmitted = await checkIfAttemptExists(
            currentUser.email, // Keep passing email for potential logging or future use
            examDetails.PIN,
            identifierForCheck, // Pass the correct identifier (email or studentExamId)
            currentMode
        );
        if (alreadySubmitted) {
            showImprovedNotification('error', 'Already Submitted', `This exam (${examDetails.PIN}) has already been submitted and cannot be retaken.`, 0);
            if (startExamBtn) startExamBtn.disabled = true;
            if (startExamBtnAlt) startExamBtnAlt.disabled = true;
            return; // Stop if already submitted
        }
        // --- End Check ---


        // 2. Check Exam Timing (Keep this check)
        try {
            // ... existing timing check logic ...
            const startTimestampUTC = examDetails.StartTimestampUTC; // Use stored timestamp
            if (!startTimestampUTC || isNaN(startTimestampUTC)) { throw new Error("Start timestamp missing or invalid.");}
            const startTime = startTimestampUTC; // Already in UTC ms

            if (Date.now() < startTime) {
                 showImprovedNotification('error', 'Exam Not Yet Available', `This exam is scheduled to start at ${new Date(startTime).toLocaleString()}. Please wait.`);
                 return;
            }
            if (!examEndTime || isNaN(examEndTime)) { throw new Error("Could not determine the exam end time."); }
            if (Date.now() >= examEndTime) {
                 showImprovedNotification('error', 'Exam Deadline Passed', `The deadline (${new Date(examEndTime).toLocaleString()}) for starting or resuming this exam has passed.`, 0);
                 return;
             }
        } catch (e) {
             console.error("Exam timing check error:", e);
             showImprovedNotification('warning', 'Timing Check Warning', `Could not fully verify exam timing: ${e.message}. Proceeding cautiously.`);
        }

        // Proceed to show questions
        console.log(`Starting ${currentMode} mode. PIN: ${examDetails.PIN}` + (currentMode === 'exam' ? `, Student Exam ID: ${studentExamIdEntered}` : ''));
        confirmedQuestionsCount = 0;
        examStartModule.classList.add('hidden');
        examDetailsModule.classList.add('hidden');
        examQuestionsModule.classList.remove('hidden');
        submissionConfirmationModule.classList.add('hidden');
        displayQuestions(examDetails.Questions);
        startTimer();
        saveAppState();
        checkAllConfirmed();
		stopAutoSave();
		startAutoSave();
    }

function displayQuestions(questionsJsonString) {
    // Return a new Promise
    return new Promise((resolve, reject) => {
        console.log("Parsing and displaying exam questions...");
        examQuestionsArea.innerHTML = ''; // Clear previous questions
        totalQuestions = 0;
        confirmedQuestionsCount = 0; // Reset confirmed count when displaying
        codeEditors = {}; // Clear old editor instances

        try {
            let questionsArray = [];
            try {
                questionsArray = JSON.parse(questionsJsonString);
                if (!Array.isArray(questionsArray)) {
                    throw new Error("Parsed data is not an array.");
                }
            } catch (parseError) {
                // ... (fallback logic remains the same) ...
                 console.warn("Could not parse questions JSON. Displaying as a single block.", parseError);
                 questionsArray = [{
                     type: "long_answer",
                     prompt: "Exam Instructions / Questions",
                     content: questionsJsonString
                 }];
            }

            totalQuestions = questionsArray.length;
            console.log(`Total questions loaded: ${totalQuestions}`);

            // --- Shuffling Logic (remains the same) ---
            const maybe = String(examDetails.shuffleQuestions).trim().toLowerCase();
		    const shuffleDisabled = ['no','false','0'].includes(maybe);
            const skipShuffle = Boolean(isAdmin) || shuffleDisabled;
            console.log(`User role: ${skipShuffle ? 'ADMIN/NO-SHUFFLE - KEEPING ORDER' : 'STUDENT - RANDOMIZING'}`);
            const seed = hashString(currentUser?.email || Date.now().toString());
            const originalIndices = Array.from(questionsArray.keys());
		    const displayIndices = skipShuffle ? originalIndices : seededShuffle(originalIndices.slice(), seed); // Use email hash for seed
            console.log("Display order:", displayIndices);

            examDetails.OriginalOrderMap = {};
            questionsArray.forEach((q, index) => {
                examDetails.OriginalOrderMap[index] = q;
            });

            // --- Question Rendering Loop (remains mostly the same) ---
            let codeEditorInitPromises = []; // Array to hold promises for CodeMirror init

            displayIndices.forEach((originalIndex, displayIndex) => {
                const q = questionsArray[originalIndex];
                const displayQNum = displayIndex + 1;
                const originalQNum = originalIndex + 1;
                const questionId = `q-${originalQNum}`;
                const answerId = `ans-${originalQNum}`;
                const answerName = `ans-${originalQNum}`;

                const questionDiv = document.createElement('div');
                // ... (setting class, id, dataset remains the same) ...
                 questionDiv.className = 'question form-group';
                 if (q.type === 'text_only') {
                     questionDiv.className = 'question form-group text-only-question';
                 }
                 questionDiv.id = questionId;
                 questionDiv.dataset.originalIndex = originalIndex;
                 questionDiv.dataset.displayIndex = displayIndex;


                // --- Process Prompt Text (remains the same) ---
                 let promptText = q.prompt || `Question`;
                 promptText = escapeHtml(promptText);
                 let questionLabel = `Question ${displayQNum}`;
                 if (q.points && q.type !== 'text_only') {
                     questionLabel += ` (${q.points} ${q.points == 1 ? 'point' : 'points'})`;
                 }
                 questionLabel += ": ";
                 if (q.type !== 'text_only') {
                     promptText = `<strong>${questionLabel}</strong>${promptText}`;
                 }
                 // ... (term emphasis logic remains the same) ...
                 promptText = promptText.replace(/\*\*\*(.*?)\*\*\*/g, '<strong>$1</strong>');
                 promptText = promptText.replace(/(?<!\*)\*\*(?!\*)(.*?)\*\*(?!\*)/g, '<strong>$1</strong>');
                 const termsToEmphasise = ['sep', 'end', 'print()', 'input()', 'range\\(5\\)', 'range\\(2, 8, 2\\)', 'TypeError', 'IDE'];
                 termsToEmphasise.forEach(term => {
                     const termForRegex = (term.includes('\\(')) ? term : term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                     const regex = new RegExp(`(?<![=\\"'>])(\\b${termForRegex}\\b)(?![<\\(\\"'])`, 'g');
                     promptText = promptText.replace(regex, (match) => `<em class="term">${match}</em>`);
                 });
                 promptText = promptText.replace(/print'Hello World'/g, () => '<em class="term">print\'Hello World\'</em>');
                 promptText = promptText.replace(/x = 5 \+ '3'/g, () => '<em class="term">x = 5 + \'3\'</em>');
                 promptText = promptText.replace(/print\("Value:", value, sep = ':'\)/g, () => '<em class="term">print("Value:", value, sep = \':\')</em>');
                 promptText = promptText.replace(/print\(My variable is, x\)/g, () => '<em class="term">print(My variable is, x)</em>');
                 promptText = promptText.replace(/"My variable is"/g, () => '<em class="term">"My variable is"</em>');
                 promptText = promptText.replace(/\n/g, '<br>');


                // --- Generate Question Content HTML (remains mostly the same) ---
                let questionContentHtml = '<div class="question-content">';
                let labelClass = '';
                let labelTag = 'label';
                if (q.type === 'text_only') { labelTag = 'div'; labelClass = 'text-content'; }
                else if (q.type === 'code') { labelClass = 'code-prompt'; }

                // --- MODIFIED: CodeMirror init inside a Promise ---
                switch (q.type) {
                    // ... (cases for text_only, short_answer, long_answer, attachment remain same) ...
                     case 'text_only': questionContentHtml += `<div class="text-only-content"></div>`; break;
                     case 'short_answer': questionContentHtml += `<input type="text" id="${answerId}" name="${answerName}" class="form-control" placeholder="Enter your answer">`; break;
                     case 'long_answer': questionContentHtml += `<textarea id="${answerId}" name="${answerName}" class="form-control" rows="5" placeholder="Enter your detailed answer">${escapeHtml(q.content || '')}</textarea>`; break;
                     case 'attachment': questionContentHtml += `<input type="file" id="${answerId}" name="${answerName}" class="form-control">`; break;

                    case 'code':
                        questionContentHtml += `<textarea id="${answerId}" name="${answerName}" class="form-control code-editor" rows="8" placeholder="Enter your code">${escapeHtml(q.content || '')}</textarea>`;
                        // Add a promise that resolves after CodeMirror init timeout
                        codeEditorInitPromises.push(new Promise(resolveEditor => {
                             setTimeout(() => {
                                 initializeCodeEditor(answerId, q.language || 'python');
                                 resolveEditor(); // Resolve after attempting init
                             }, 300); // Keep the slight delay
                        }));
                        break;

                    // ... (case for multiple_select remains same) ...
                    case 'multiple_select':
                         questionContentHtml += `<div class="checkbox-group" id="${answerId}">`;
                         if (Array.isArray(q.options) && q.options.length > 0) {
                             q.originalOptions = [...q.options];
                             const optionIndices = [...Array(q.options.length).keys()];
                             const shuffledOptionIndices = skipShuffle ? [...optionIndices] : seededShuffle(optionIndices, seed + originalIndex);
                             q.shuffledOptionIndices = shuffledOptionIndices;
                             shuffledOptionIndices.forEach((originalOptIndex, displayOptIndex) => {
                                 const option = q.options[originalOptIndex];
                                 const optionId = `${answerId}-opt${originalOptIndex}`;
                                 const escapedOption = escapeHtml(option);
                                 questionContentHtml += `<div class="checkbox-item"><input type="radio" id="${optionId}" name="${answerName}" value="${escapedOption}" class="form-control-checkbox" data-original-index="${originalOptIndex}"><label for="${optionId}">${escapedOption}</label></div>`;
                            });
                         } else { questionContentHtml += `<p style="color:red;">Error: Options missing or empty.</p>`; }
                         questionContentHtml += `</div>`;
                         break;

                    default: questionContentHtml += `<p>${escapeHtml(q.content || '')}</p>`; break;
                }
                questionContentHtml += '</div>'; // End question-content

                // --- Action Buttons HTML (remains the same) ---
                 let actionsHtml = '';
                 if (q.type !== 'text_only') {
                     actionsHtml = `<div class="question-actions"><button type="button" class="btn-sm btn-confirm" onclick="confirmAnswer('${questionId}')"><i class="fas fa-check"></i> Confirm</button><button type="button" class="btn-sm btn-edit" onclick="editAnswer('${questionId}')"><i class="fas fa-pencil-alt"></i> Edit</button></div>`;
                 }


                // --- Assemble and Append Question (remains the same) ---
                 const labelTargetId = answerId;
                 questionDiv.innerHTML = `<${labelTag} for="${labelTargetId}" class="${labelClass}">${promptText}</${labelTag}>${questionContentHtml}${actionsHtml}`;
                 examQuestionsArea.appendChild(questionDiv);


                // --- Auto-confirm text_only (remains the same) ---
                if (q.type === 'text_only') {
                    confirmedQuestionsCount++;
                    questionDiv.classList.add('confirmed', 'text-only-confirmed');
                }
            }); // End of displayIndices.forEach

            // --- Wait for all CodeMirror initializations before resolving ---
            Promise.all(codeEditorInitPromises).then(() => {
                console.log("All CodeMirror editors initialized (or timed out).");
                // Enhance UI elements like points AFTER main rendering
                enhancePointsDisplay(); // Example: If you have points badges
                // Update confirmation status based on rendered questions
                checkAllConfirmed();
                resolve(); // Resolve the main Promise from displayQuestions
            }).catch(editorError => {
                 console.error("Error during CodeMirror initialization batch:", editorError);
                 reject(editorError); // Reject main promise if any editor init fails badly (unlikely with setTimeout)
            });

        } catch (e) {
            console.error("Error displaying questions:", e);
            examQuestionsArea.innerHTML = '<p>Error loading questions.</p>';
            reject(e); // Reject the Promise on error
        }
    }); // End of Promise constructor
}


// Function to create a consistent hash from a string (for seeding)
function hashString(str) {
    let hash = 0;
    if (!str || str.length === 0) return Math.floor(Math.random() * 1000000);
    
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    
    return Math.abs(hash);
}

/**
 * Deterministic (seeded) in‐place Fisher–Yates shuffle.
 *
 * @param {any[]} array
 * @param {number} seed  // e.g. hashString(userEmail)
 * @returns the same array, shuffled
 */
function seededShuffle(array, seed) {
  let m = array.length, t, i;
  // very simple PRNG: linear congruential
  while (m > 0) {
    seed = (seed * 1664525 + 1013904223) >>> 0;     // update seed
    i = seed % m;                                   // pick an index
    m--;
    // swap array[m] and array[i]
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }
  return array;
}


    // Utility function to escape HTML (Ensure this exists)
    function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return unsafe;
        return unsafe
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
     }


function confirmAnswer(questionId) {
    const questionDiv = document.getElementById(questionId);
    if (!questionDiv || questionDiv.classList.contains('confirmed')) return;
    
    // Add confirmed class
    questionDiv.classList.add('confirmed');
    confirmedQuestionsCount++;

    // Disable all relevant input elements within this question
    const inputs = questionDiv.querySelectorAll('.form-control, .form-control-checkbox');
    inputs.forEach(input => { input.disabled = true; });
    
    // Handle CodeMirror editor if present
    const cmTextarea = questionDiv.querySelector('.code-editor');
    if (cmTextarea && cmTextarea.id && codeEditors[cmTextarea.id]) {
        codeEditors[cmTextarea.id].setOption('readOnly', true);
        
        // Add visual indicator for confirmed state
        const cmElement = codeEditors[cmTextarea.id].getWrapperElement();
        if (cmElement) {
            cmElement.classList.add('cm-confirmed');
        }
    }

    console.log(`Confirmed answer for question: ${questionId}`);
    checkAllConfirmed();
}

// Add triple click handler for user avatar (import backup)
function setupBackupImportFeature() {
    const userAvatar = document.getElementById('user-avatar');
    if (!userAvatar) return;
    
    // Track clicks for triple-click detection
    let clickCount = 0;
    let clickTimer = null;
    
    userAvatar.addEventListener('click', function() {
        clickCount++;
        
        if (clickCount === 1) {
            clickTimer = setTimeout(() => {
                clickCount = 0;
                clickTimer = null;
            }, 500); // Reset after 500ms
        }
        
        if (clickCount === 3) {
            // Triple click detected!
            clearTimeout(clickTimer);
            clickCount = 0;
            clickTimer = null;
            
            // Show import backup dialog
            showBackupImportDialog();
        }
    });
    
    // Create backup import dialog if it doesn't exist
    if (!document.getElementById('backup-import-modal')) {
        createBackupImportDialog();
    }
}

// Create the backup import dialog
function createBackupImportDialog() {
    const modalDiv = document.createElement('div');
    modalDiv.id = 'backup-import-modal';
    modalDiv.className = 'backup-modal';
    
    modalDiv.innerHTML = `
        <div class="backup-modal-content">
            <div class="backup-modal-header">
                <h3><i class="fas fa-file-import"></i> Import Backup</h3>
                <button type="button" class="backup-close-btn" id="backup-close-btn">&times;</button>
            </div>
            <div class="backup-modal-body">
                <p>You can restore a previously saved exam backup JSON file here.</p>
                <div class="form-group">
                    <label for="backup-file-input">Select Backup File:</label>
                    <input type="file" id="backup-file-input" class="form-control" accept=".json">
                </div>
                <div class="backup-info" id="backup-info"></div>
                <div class="backup-preview" id="backup-preview"></div>
            </div>
            <div class="backup-modal-footer">
                <button type="button" class="btn-orange" id="backup-cancel-btn">Cancel</button>
                <button type="button" class="btn-green" id="backup-import-btn" disabled>Import Backup</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modalDiv);
    
    // Setup event listeners
    document.getElementById('backup-close-btn').addEventListener('click', hideBackupImportDialog);
    document.getElementById('backup-cancel-btn').addEventListener('click', hideBackupImportDialog);
    document.getElementById('backup-file-input').addEventListener('change', handleBackupFileSelected);
    document.getElementById('backup-import-btn').addEventListener('click', importBackupData);
}

// Show the backup import dialog
function showBackupImportDialog() {
    const modal = document.getElementById('backup-import-modal');
    if (modal) {
        // Reset dialog state
        document.getElementById('backup-file-input').value = '';
        document.getElementById('backup-info').innerHTML = '';
        document.getElementById('backup-preview').innerHTML = '';
        document.getElementById('backup-import-btn').disabled = true;
        
        // Show modal
        modal.classList.add('visible');
    }
}

// Hide the backup import dialog
function hideBackupImportDialog() {
    const modal = document.getElementById('backup-import-modal');
    if (modal) {
        modal.classList.remove('visible');
    }
}

// Handle backup file selection
function handleBackupFileSelected(event) {
    const fileInput = event.target;
    const file = fileInput.files[0];
    const infoDiv = document.getElementById('backup-info');
    const previewDiv = document.getElementById('backup-preview');
    const importBtn = document.getElementById('backup-import-btn');
    
    // Reset display areas
    infoDiv.innerHTML = '';
    previewDiv.innerHTML = '';
    importBtn.disabled = true;
    
    if (!file) return;
    
    // Check file type
    if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
        infoDiv.innerHTML = '<p class="backup-error">Error: Selected file is not a JSON file.</p>';
        return;
    }
    
    // Read file content
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const backupData = JSON.parse(e.target.result);
            
            // Validate backup data structure
            if (!backupData.examDetails || !backupData.studentInfo || !backupData.answers) {
                throw new Error('Invalid backup file structure');
            }
            
            // Show backup details
            infoDiv.innerHTML = `
                <p><strong>Exam:</strong> ${escapeHtml(backupData.examDetails.Name || 'N/A')}</p>
                <p><strong>PIN:</strong> ${escapeHtml(backupData.examDetails.PIN || 'N/A')}</p>
                <p><strong>Student:</strong> ${escapeHtml(backupData.studentInfo.name || 'N/A')}</p>
                <p><strong>Timestamp:</strong> ${escapeHtml(backupData.submissionTimestamp || 'N/A')}</p>
                <p><strong>Questions:</strong> ${backupData.totalQuestionsOnSubmit || 'N/A'}</p>
                <p><strong>Confirmed:</strong> ${backupData.confirmedCountOnSubmit || 'N/A'}</p>
            `;
            
            // Show preview of answers
            const answerKeys = Object.keys(backupData.answers || {}).slice(0, 3);
            if (answerKeys.length > 0) {
                let previewHtml = '<p><strong>Answer Preview:</strong></p><ul>';
                answerKeys.forEach(key => {
                    const value = backupData.answers[key];
                    const truncatedValue = typeof value === 'string' && value.length > 50 
                        ? value.substring(0, 50) + '...' 
                        : value;
                    previewHtml += `<li>${escapeHtml(key)}: ${escapeHtml(String(truncatedValue))}</li>`;
                });
                if (Object.keys(backupData.answers).length > 3) {
                    previewHtml += `<li>... and ${Object.keys(backupData.answers).length - 3} more</li>`;
                }
                previewHtml += '</ul>';
                previewDiv.innerHTML = previewHtml;
            } else {
                previewDiv.innerHTML = '<p>No answers found in backup.</p>';
            }
            
            // Store backup data for import
            fileInput.dataset.validBackup = 'true';
            importBtn.disabled = false;
            
        } catch (error) {
            console.error('Error parsing backup file:', error);
            infoDiv.innerHTML = `<p class="backup-error">Error: ${error.message}. Please select a valid backup file.</p>`;
            fileInput.dataset.validBackup = 'false';
        }
    };
    
    reader.onerror = function() {
        infoDiv.innerHTML = '<p class="backup-error">Error: Failed to read the file.</p>';
    };
    
    reader.readAsText(file);
}

// Import backup data
function importBackupData() {
    const fileInput = document.getElementById('backup-file-input');
    if (!fileInput || fileInput.dataset.validBackup !== 'true' || !fileInput.files[0]) {
        showImprovedNotification('error', 'Import Failed', 'Invalid or missing backup file.', 3000);
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const backupData = JSON.parse(e.target.result);
            
            // Confirm with user
            if (confirm(`Are you sure you want to import backup for ${backupData.examDetails.Name} (PIN: ${backupData.examDetails.PIN})?\n\nThis will replace any current exam data.`)) {
                // Apply backup data to form
                applyBackupToForm(backupData);
                hideBackupImportDialog();
                showImprovedNotification('success', 'Backup Imported', 'Exam backup has been successfully imported.', 5000);
            }
        } catch (error) {
            console.error('Error importing backup:', error);
            showImprovedNotification('error', 'Import Failed', `Error: ${error.message}`, 5000);
        }
    };
    
    reader.readAsText(fileInput.files[0]);
}

// Apply backup data to the form
function applyBackupToForm(backupData) {
    // 1. Load exam first if needed
    if (!examDetails || examDetails.PIN !== backupData.examDetails.PIN) {
        // We need to load the exam first
        examDetails = backupData.examDetails;
        studentPINEntered = backupData.studentInfo.pinEntered || '';
        studentExamIdEntered = backupData.studentInfo.studentExamId || '';
        
        // Update UI to show the exam
        displayExamDetailsHeader();
        examStartModule.classList.add('hidden');
        examDetailsModule.classList.add('hidden');
        examQuestionsModule.classList.remove('hidden');
        
        // Display questions
        displayQuestions(examDetails.Questions);
    }
    
    // 2. Apply answers to the form
    setTimeout(() => {
        const answers = backupData.answers || {};
        
        for (const answerName in answers) {
            const formElement = examForm.elements[answerName];
            if (!formElement) continue;
            
            const answerValue = answers[answerName];
            
            // Skip file uploads, they can't be restored
            if (formElement.type === 'file') continue;
            
            // Skip [NOT CONFIRMED] placeholders
            if (answerValue === '[NOT CONFIRMED]') continue;
            
            // Handle CodeMirror editors
            if (formElement.classList.contains('code-editor') && codeEditors[answerName]) {
                codeEditors[answerName].setValue(answerValue || '');
            } 
            // Handle radio buttons
            else if (formElement.type === 'radio') {
                const radioOptions = document.querySelectorAll(`input[name="${answerName}"]`);
                radioOptions.forEach(radio => {
                    if (radio.value === answerValue) {
                        radio.checked = true;
                    }
                });
            } 
            // Handle text inputs and textareas
            else {
                formElement.value = answerValue || '';
            }
            
            // If it was confirmed in the backup, confirm it now
            const questionId = answerName.replace('ans-', 'q-');
            const wasConfirmed = backupData.confirmedCountOnSubmit === backupData.totalQuestionsOnSubmit;
            if (wasConfirmed) {
                confirmAnswer(questionId);
            }
        }
        
        // Update timer if time info available
        if (backupData.examEndTime) {
            examEndTime = backupData.examEndTime;
            startTimer();
        }
        
        checkAllConfirmed();
        
    }, 500); // Give time for the questions to render first
}

function editAnswer(questionId) {
    const questionDiv = document.getElementById(questionId);
    if (!questionDiv || !questionDiv.classList.contains('confirmed')) return;

    // Remove both confirmed and expanded classes
    questionDiv.classList.remove('confirmed');
    confirmedQuestionsCount--;

    // Re-enable all inputs
    const inputs = questionDiv.querySelectorAll('.form-control, .form-control-checkbox');
    inputs.forEach(input => { input.disabled = false; });
    
    // Handle CodeMirror editor if present
    const cmTextarea = questionDiv.querySelector('.code-editor');
    if (cmTextarea && cmTextarea.id && codeEditors[cmTextarea.id]) {
        codeEditors[cmTextarea.id].setOption('readOnly', false);
        
        // Remove visual indicator for confirmed state
        const cmElement = codeEditors[cmTextarea.id].getWrapperElement();
        if (cmElement) {
            cmElement.classList.remove('cm-confirmed');
        }
    }

    console.log(`Enabled editing for question: ${questionId}`);
    checkAllConfirmed();
}


        // Adds validation listeners to file input elements (Keep as is)
        function addAttachmentValidation(inputId) {
            const fileInput = document.getElementById(inputId);
            if (!fileInput || fileInput.type !== 'file') return;

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return; // No file selected

                const maxSize = parseInt(fileInput.getAttribute('data-max-size'), 10);
                const allowedTypes = JSON.parse(fileInput.getAttribute('data-allowed-types') || '[]');

                // Check file size
                if (maxSize && file.size > maxSize) {
                    const maxSizeMB = (maxSize / (1024 * 1024)).toFixed(1);
                    showImprovedNotification('error', 'File Too Large', `The file "${file.name}" (${(file.size / (1024 * 1024)).toFixed(1)}MB) exceeds the maximum allowed size of ${maxSizeMB}MB.`);
                    fileInput.value = ''; // Clear the invalid selection
                    return;
                }

                // Check file type
                if (allowedTypes.length > 0 && !allowedTypes.includes(file.type) && !allowedTypes.includes('.' + file.name.split('.').pop())) {
                    // Check both MIME type and extension as a fallback
                     showImprovedNotification('error', 'Invalid File Type', `The file type of "${file.name}" (${file.type || 'unknown'}) is not allowed. Allowed types: ${allowedTypes.join(', ')}`);
                     fileInput.value = ''; // Clear the invalid selection
                     return;
                 }

                // File is valid (passed checks)
                showImprovedNotification('success', 'File Selected', `Selected file: "${file.name}" (${(file.size / 1024).toFixed(1)}KB)`);
            });
        }

        // Starts the countdown timer (Keep as is)
function startTimer() {
    if (examTimerInterval) {
        console.warn("Timer is already running.");
        return;
    }
    
    if (!examEndTime || isNaN(examEndTime) || examEndTime <= Date.now()) {
        console.error("Cannot start timer: Invalid or past exam end time.", examEndTime);
        timerDisplay.textContent = "Error";
        if (examEndTime && examEndTime <= Date.now()) {
            showImprovedNotification('error', 'Deadline Passed', 'The time for this exam has already expired.', 0);
            handleSubmitExam(true);
        }
        return;
    }
    
    // Create sticky timer
    createStickyTimer();
    
    console.log(`Timer starting. Target end time: ${new Date(examEndTime).toLocaleString()}`);
    updateTimerDisplay(); // Initial display update
    examTimerInterval = setInterval(updateTimerDisplay, 1000);
}

        // Updates the timer display every second (Keep as is)
function updateTimerDisplay() {
    if (!examEndTime) {
        console.warn("Timer update called without a valid end time.");
        stopTimer();
        timerDisplay.textContent = "--:--";
        const stickyDisplay = document.getElementById('sticky-timer-display');
        if (stickyDisplay) stickyDisplay.textContent = "--:--";
        return;
    }

    const now = Date.now();
    const timeLeft = Math.max(0, examEndTime - now);
    const minutesLeft = Math.floor(timeLeft / (1000 * 60));
    const seconds = Math.floor((timeLeft / 1000) % 60);
    const timeString = `${String(minutesLeft).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

    // Update both regular and sticky timer displays
    timerDisplay.textContent = timeString;
    const stickyDisplay = document.getElementById('sticky-timer-display');
    if (stickyDisplay) stickyDisplay.textContent = timeString;
    
    // Update visual cues based on time remaining
    updateTimeVisualCues(minutesLeft, seconds, timeLeft);
    
    // Check if time is up
    if (timeLeft <= 0) {
        console.log("Exam time has expired!");
        stopTimer();
        showImprovedNotification('warning', "Time's Up!", 'The exam time has expired. Submitting automatically.', 0);
        handleSubmitExam(true);
    }
}

function updateTimeVisualCues(minutesLeft, seconds, timeLeft) {
    const stickyTimer = document.querySelector('.sticky-timer');
    // --- ADDED: Get the icon element inside the timer ---
    const timerIcon = stickyTimer ? stickyTimer.querySelector('i') : null;

    if (!stickyTimer || !timerIcon) return; // Exit if timer or icon not found

    if (timeLeft <= 0) {
        // Time's up
        document.body.classList.remove('time-warning', 'time-danger');
        document.body.classList.add('time-expired');
        stickyTimer.classList.remove('warning', 'danger');
        stickyTimer.classList.add('expired');
        timerIcon.className = 'fas fa-hourglass-end'; // Or keep 'fa-stopwatch'

    } else if (minutesLeft <= 5) {
        // Danger - 5 minutes or less
        document.body.classList.remove('time-warning');
        document.body.classList.add('time-danger');
        stickyTimer.classList.remove('warning');
        stickyTimer.classList.add('danger');
        // --- ADDED: Change icon to warning triangle ---
        timerIcon.className = 'fas fa-exclamation-triangle';

    } else if (minutesLeft <= 10) {
        // Warning - 10 minutes or less
        document.body.classList.add('time-warning');
        document.body.classList.remove('time-danger');
        stickyTimer.classList.add('warning');
        stickyTimer.classList.remove('danger');
        // --- ADDED: Ensure icon is stopwatch ---
        timerIcon.className = 'fas fa-stopwatch';

    } else {
        // Normal time
        document.body.classList.remove('time-warning', 'time-danger');
        stickyTimer.classList.remove('warning', 'danger');
         timerIcon.className = 'fas fa-stopwatch';
    }
}

        // Stops the countdown timer interval (Keep as is)
        function stopTimer() {
            if (examTimerInterval) {
                clearInterval(examTimerInterval);
                examTimerInterval = null; // Clear the interval ID
                console.log("Timer stopped.");
            }
        }

        // Collects browser/device fingerprint data (basic) (Keep as is)
        function getFingerprintData() {
            const webglFp = getWebglFingerprint();
            const data = {
                // --- Category 1: Basic Browser & Config ---
                ua: navigator.userAgent || 'N/A',
                lang: navigator.language || 'N/A',
                vendor: navigator.vendor || 'N/A',
                cookieEnabled: navigator.cookieEnabled || false,
                doNotTrack: navigator.doNotTrack || 'unknown',
                plugins: Array.from(navigator.plugins || []).map(p => ({ name: p.name, filename: p.filename })).sort((a,b) => a.name.localeCompare(b.name)),
                mimeTypes: Array.from(navigator.mimeTypes || []).map(m => ({ type: m.type, description: m.description })).sort((a,b) => a.type.localeCompare(b.type)),

                // --- Category 2: Hardware / OS ---
                platform: navigator.platform || 'N/A',
                cores: navigator.hardwareConcurrency || undefined,
                memory: navigator.deviceMemory || undefined,
                maxTouchPoints: navigator.maxTouchPoints || 0,

                // --- Category 3: Screen & Display ---
                screenRes: `${screen.width || 0}x${screen.height || 0}x${screen.colorDepth || 0}`,
                availScreenRes: `${screen.availWidth || 0}x${screen.availHeight || 0}`,
                windowInnerSize: `${window.innerWidth || 0}x${window.innerHeight || 0}`,
                timezoneOffset: new Date().getTimezoneOffset(),

                // --- Category 4: GPU Info (from WebGL) ---
                webglAvailable: webglFp.available, // Was WebGL context available?
                webglVendor: webglFp.vendor,       // GPU Vendor string
                webglRenderer: webglFp.renderer,   // GPU Renderer string (often the model)

                // --- Timestamp ---
                ts: Date.now()
            };
            console.log("Collected Fingerprint Data:", data);
            // Return as OBJECT now, will be stringified before sending
            return data;
        }

        // Helper function for WebGL fingerprinting (Keep as is)
        function getWebglFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                // Try both standard and experimental contexts
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    return { available: false, vendor: 'N/A', renderer: 'N/A' }; // WebGL not supported
                }
                // Get debug extension to potentially unmask renderer/vendor info
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                const vendor = gl.getParameter(debugInfo ? debugInfo.UNMASKED_VENDOR_WEBGL : gl.VENDOR);
                const renderer = gl.getParameter(debugInfo ? debugInfo.UNMASKED_RENDERER_WEBGL : gl.RENDERER);
                return {
                    available: true,
                    vendor: vendor || 'unknown',
                    renderer: renderer || 'unknown'
                };
            } catch (e) {
                console.warn("WebGL fingerprinting failed:", e);
                return { available: false, vendor: 'error', renderer: 'error', errorMsg: e.message };
            }
        }

        // Triggers a download of JSON data as a file (Keep as is, useful backup)
        function downloadJsonBackup(data, filename) {
            try {
                const jsonString = JSON.stringify(data, null, 2); // Pretty-print JSON
                const blob = new Blob([jsonString], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename; // Set the download filename
                document.body.appendChild(link); // Append link to body
                link.click(); // Programmatically click the link to trigger download
                document.body.removeChild(link); // Remove link from body
                URL.revokeObjectURL(url); // Release the object URL
                console.log("JSON backup download initiated:", filename);
                showImprovedNotification('info', 'Backup Saved', 'A JSON backup file of your submission has been downloaded.');
            } catch (e) {
                console.error("Error creating or triggering JSON backup download:", e);
                showImprovedNotification('error', 'Backup Error', 'Could not create the backup file. Please manually copy your answers if needed.');
            }
        }


// Handles the final exam submission process by sending data to the backend
async function handleSubmitExam(isAutoSubmit = false) {
    const timeIsUp = examEndTime && Date.now() >= examEndTime;
    if (timeIsUp && !isAutoSubmit) {
         console.warn("Manual submit clicked after deadline. Treating as auto-submit.");
         showImprovedNotification('warning', 'Deadline Passed', 'Time expired. Submitting automatically.');
         isAutoSubmit = true;
     }

    stopTimer(); // Stop the timer immediately

    // Disable submit button and show submitting state (always)
    submitExamBtn.disabled = true;
    submitExamBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';

    // --- Mandatory Confirmation Check for MANUAL submit ---
    if (!isAutoSubmit) {
        if (confirmedQuestionsCount !== totalQuestions) {
            showImprovedNotification('error', 'Not All Confirmed', `Please confirm all ${totalQuestions} questions before submitting. You have confirmed ${confirmedQuestionsCount}.`, 5000);
            // Do not re-enable timer here, just update button state
            checkAllConfirmed(); // This will keep it disabled but update text
            return; // Stop submission
        }
        // If all confirmed manually, ask for final user confirmation
        if (!confirm("You have confirmed all answers. Are you absolutely sure you want to submit your exam?\nThis action cannot be undone.")) {
             checkAllConfirmed(); // Re-enable button if online/all confirmed
             // Restart timer only if time still remains
             if (examEndTime && Date.now() < examEndTime) { startTimer(); }
             return; // Abort submission
        }
    }
    // --- End Manual Confirmation Check ---

    console.log("Processing submission..." + (isAutoSubmit ? " (Auto)" : " (Manual - All Confirmed)"));
    const answers = {}; // Object to hold answers
    const fingerprintObject = getFingerprintData(); // Get fingerprint OBJECT

    // Collect Answers - respecting ORIGINAL order AND confirmation status for auto-submit
    if (!examDetails || !examDetails.OriginalOrderMap || totalQuestions <= 0) {
        showImprovedNotification('error', 'Submission Error', 'Cannot collect answers. Exam data or question count is invalid.', 0);
        checkAllConfirmed(); // Reset button state
        return;
    }

    const originalIndices = Object.keys(examDetails.OriginalOrderMap).map(Number).sort((a, b) => a - b);
    originalIndices.forEach(originalIndex => {
        const originalQNum = originalIndex + 1;
        const questionData = examDetails.OriginalOrderMap[originalIndex];
        const answerName = `ans-${originalQNum}`;
        const questionDivId = `q-${originalQNum}`;
        const questionDiv = document.getElementById(questionDivId);
		if (questionData.type === 'text_only') {
            // Add a marker that this was a text-only item, but don't require an answer
            answers[answerName] = "[TEXT_ONLY_NO_ANSWER_REQUIRED]";
            return; // Skip the rest of this iteration
        }
        // Check confirmation status *reliably*
        const isConfirmed = questionDiv ? questionDiv.classList.contains('confirmed') : false;

        // For AUTO submit, ONLY collect CONFIRMED answers.
        // For MANUAL submit, collect ALL (we already checked they are all confirmed).
        if (isAutoSubmit && !isConfirmed) {
            answers[answerName] = "[NOT CONFIRMED]"; // Mark unconfirmed answers explicitly
            console.log(`Auto-submit: Answer for ${answerName} was not confirmed.`);
        } else {
            // Collect answer normally (manual submit OR confirmed auto-submit)
            const formElementsWithName = examForm.elements[answerName];
            if (formElementsWithName) {
                switch (questionData.type) {
                    case 'attachment':
                        const fileInput = formElementsWithName;
                        answers[answerName] = (fileInput.files && fileInput.files.length > 0)
                            ? `FILE_UPLOADED:${fileInput.files[0].name}`
                            : '';
                        console.log(`Collected answer for ${answerName} (attachment):`, answers[answerName]);
                        break; // Ends attachment case

                    case 'multiple_select': // Handles RADIO BUTTONS
                        const radioGroup = formElementsWithName;
                        let selectedValue = null; // Default to null

                        if (radioGroup && typeof radioGroup.value !== 'undefined') {
                            if (radioGroup.value !== "") {
                                selectedValue = radioGroup.value;
                                
                                // If we're working with shuffled options, store additional metadata
                                // This helps with grading on the admin side
                                if (!isAdmin && questionData.shuffledOptionIndices) {
                                    // Find which original option index this value corresponds to
                                    const selectedOptionEl = document.querySelector(`input[name="${answerName}"]:checked`);
                                    if (selectedOptionEl && selectedOptionEl.dataset.originalIndex) {
                                        // Add metadata to track original option index
                                        answers[`${answerName}_metadata`] = {
                                            originalIndex: selectedOptionEl.dataset.originalIndex
                                        };
                                    }
                                }
                            }
                        } else {
                             console.warn(`Could not find radio button group or its value property for name: "${answerName}"`);
                        }
                        answers[answerName] = selectedValue;
                        console.log(`Collected answer for ${answerName} (radio):`, selectedValue);
                        break; // Ends multiple_select case

                    default: // Handles short_answer, long_answer, code, etc.
                        // For code questions using CodeMirror
                        if (questionData.type === 'code' && codeEditors[answerName]) {
                            answers[answerName] = codeEditors[answerName].getValue();
                            console.log(`Collected answer for ${answerName} (code editor): "${answers[answerName].substring(0,50)}..."`);
                        } else if (typeof formElementsWithName.value !== 'undefined') {
                            answers[answerName] = formElementsWithName.value;
                            console.log(`Collected answer for ${answerName} (default): "${answers[answerName].substring(0,50)}..."`);
                        } else {
                            console.warn(`Element "${answerName}" found but has no 'value' property.`);
                            answers[answerName] = 'ERROR_NO_VALUE_PROP';
                        }
                        break; // Ends default case
                }
                // --- End of switch statement ---

            } else {
                // This block executes if element not found (Keep this)
                console.warn(`Could not find form element for answer name: "${answerName}"`);
                answers[answerName] = 'ERROR_ELEMENT_NOT_FOUND';
            }
        }
    });


    // --- Create Backup Data --- (Keep this local backup)
     const backupData = {
         submissionTimestamp: new Date().toISOString(),
         examDetails: { PIN: examDetails?.PIN, Name: examDetails?.Name, Mode: examDetails?.Mode, Code: examDetails?.Code },
         studentInfo: { pinEntered: studentPINEntered, studentExamId: examDetails?.Mode === 'exam' ? studentExamIdEntered : undefined, name: currentUser?.name, email: currentUser?.email },
         answers: answers, // Keep raw answers object
         fingerprint: fingerprintObject, // Keep parsed object
         submittedLate: timeIsUp,
         autoSubmitted: isAutoSubmit, // Flag if it was an auto-submit
         confirmedCountOnSubmit: confirmedQuestionsCount, // Record how many were confirmed
         totalQuestionsOnSubmit: totalQuestions // Record total questions
     };
     const backupFilename = `exam_backup_${examDetails?.PIN || 'unknown'}_${(currentUser?.email || studentExamIdEntered || 'anon').replace(/@.*/, '')}_${Date.now()}.json`;
     downloadJsonBackup(backupData, backupFilename);

    // --- Prepare data payload for the backend ---
    const submissionData = {
        timestamp: backupData.submissionTimestamp, // Use consistent timestamp
        pin: examDetails?.PIN,
        courseCode: examDetails?.Code,
        mode: examDetails?.Mode,
        // Include identifiers based on mode
        studentEmail: (examDetails?.Mode === 'quiz' ? currentUser?.email : undefined),
        studentName: (examDetails?.Mode === 'quiz' ? currentUser?.name : undefined),
        studentExamId: (examDetails?.Mode === 'exam' ? studentExamIdEntered : undefined),
        answers: answers, // The collected answers object
        fingerprint: fingerprintObject, // Send parsed fingerprint object
        isAutoSubmit: isAutoSubmit, // Let backend know if it was auto
        timeIsUp: timeIsUp     // Let backend know if time was up
    };

    // --- Send data to Backend using Fetch ---
    let submissionSuccess = false;
    try {
        console.log(`Sending data to backend: ${BACKEND_URL}`);
        const response = await fetch(BACKEND_URL, {
            method: 'POST',
            mode: 'no-cors', // Simpler, but hides response details. Change to 'cors' if backend handles it.
            headers: {
                // 'Content-Type': 'application/json', // Not needed with Blobs/FormData or text/plain for Apps Script simple POST
                'Content-Type': 'text/plain;charset=utf-8', // Required for Apps Script e.postData.contents
            },
            // Send data within a 'submission' object, stringified
            body: JSON.stringify({ submission: submissionData })
        });

        // NOTE: With mode: 'no-cors', we CANNOT reliably check response.ok or response.status here.
        // We assume success if the fetch promise resolves without a network error.
        // The real confirmation is seeing the data appear in the Sheet.
        console.log("Fetch request sent to backend (response status hidden due to no-cors).");
        submissionSuccess = true; // Assume success after sending

         /* // If using mode: 'cors' and backend returns JSON:
         if (!response.ok) {
             let errorMsg = `Backend error! Status: ${response.status}`;
             try { const errorData = await response.json(); errorMsg += ` - ${errorData.message || 'Unknown error'}`; } catch (e) {}
             throw new Error(errorMsg);
         }
         const result = await response.json();
         console.log('Backend response:', result);
         submissionSuccess = result.success; // Check success flag from backend
         if (!submissionSuccess) {
            showImprovedNotification('error', 'Submission Failed', `Backend reported: ${result.message || 'Unknown error'} (backup downloaded).`, 0);
         }
         */

    } catch (error) {
        console.error('Error submitting data to backend:', error);
        showImprovedNotification('error', 'Submission Error', `Could not send submission: ${error.message}. A backup file was downloaded.`, 0);
        submissionSuccess = false; // Explicitly set failure
    }

    // --- Final UI Update based on assumed/checked success ---
    if (submissionSuccess) {
        showImprovedNotification('success', 'Exam Submitted Successfully!', `Your submission has been sent.`, 0);
        examQuestionsModule.classList.add('hidden');
        submissionConfirmationModule.classList.remove('hidden');
        localStorage.removeItem(appStateKey); // Clear state on successful send
        // Reset state variables fully
        examDetails = null;
        studentPINEntered = ''; studentExamIdEntered = ''; examEndTime = null; totalQuestions = 0; confirmedQuestionsCount = 0;
    } else {
         // Error notifications were already shown in the catch block or CORS success check
         console.error("Online submission failed after backup.");
         // Re-enable button ONLY if manual submit failed, allowing retry
         if (!isAutoSubmit) {
             checkAllConfirmed(); // Update button state (might remain disabled if offline)
         } else {
             showImprovedNotification('error', 'Auto-Submit Failed', 'Could not automatically send submission online. Backup downloaded.', 0);
             // Keep button disabled for auto-submit failure
         }
    }
}


        // Updates online status and related UI elements (Keep as is)
        function updateOnlineStatus() {
            isOnline = navigator.onLine;
            console.log('Connection Status:', isOnline ? 'Online' : 'Offline');
            const statusIcon = syncStatus?.querySelector('i');

            if (isOnline) {
                syncStatus.className = 'sync-status online';
                if (statusIcon) statusIcon.style.color = 'var(--success-color)';
                if (syncText) syncText.textContent = 'Online';
            } else {
                syncStatus.className = 'sync-status offline';
                if (statusIcon) statusIcon.style.color = 'var(--warning-color)';
                if (syncText) syncText.textContent = 'Offline';
                if (!isInitializing) {
                    showImprovedNotification('warning', 'Offline', 'You are currently offline. Features requiring connection may be limited.', 5000);
                }
            }

            if (statusIcon && !isSyncing) { // Reset icon if not syncing
                statusIcon.className = 'fas fa-circle';
                if(isOnline) statusIcon.style.color = 'var(--success-color)'; else statusIcon.style.color = 'var(--warning-color)';
            }


            // Update button states based on online status
            if (loadExamBtn) {
                 loadExamBtn.disabled = !isOnline || !isSignedIn || (examPinInput && examPinInput.value.trim() === '');
             }
             let startDisabled = !isOnline || !isSignedIn || !examDetails;
             const isExamModeActive = examDetails && examDetails.Mode === 'exam';
             if (isExamModeActive) {
                 startDisabled = startDisabled || (studentExamIdInput && studentExamIdInput.value.trim().length !== 5);
                 if (startExamBtnAlt) startExamBtnAlt.disabled = startDisabled;
                 if (startExamBtn) startExamBtn.disabled = true;
             } else {
                 if (startExamBtn) startExamBtn.disabled = startDisabled;
                 if (startExamBtnAlt && examDetails) startExamBtnAlt.classList.add('hidden');
            }

            // Let checkAllConfirmed handle the submit button state considering online status
            checkAllConfirmed();

            if (isInitializing && (typeof gapi !== 'undefined')) {
                isInitializing = false;
                console.log("Initialisation process complete.");
            }
        }

        // Updates the sync status indicator UI (Still useful for Reads)
        function setSyncing(syncing) {
            isSyncing = syncing;
            console.log("Network Syncing:", isSyncing);
            const statusIcon = syncStatus?.querySelector('i');
            if (statusIcon) {
                if (syncing) {
                    statusIcon.className = 'fas fa-spinner fa-spin'; // Spinning icon
                    statusIcon.style.color = 'var(--info-color)'; // Use info color for syncing
                    if (syncText) syncText.textContent = 'Syncing...';
                } else {
                    // Revert to online/offline status display
                    updateOnlineStatus(); // This will set the correct icon/text/color
                }
            }
        }

        // Displays dismissible notifications at the bottom-right (Keep as is)
        function showImprovedNotification(type, title, message, duration = 5000) {
            const container = notificationArea;
            if (!container) {
                console.error("Notification container element not found in the DOM.");
                return; // Cannot display notification
            }

            // Create notification element
            const notification = document.createElement('div');
            notification.className = `in-page-notification in-page-notification-${type}`; // Base + type class

            // Determine icon based on type
            let iconClass;
            switch (type) {
                case 'success': iconClass = 'fa-check-circle'; break;
                case 'error':   iconClass = 'fa-times-circle'; break;
                case 'warning': iconClass = 'fa-exclamation-triangle'; break;
                default:        iconClass = 'fa-info-circle'; // Default to info
            }

            // Set inner HTML with icon, title, message, and close button
            notification.innerHTML = `<i class="fas ${iconClass} fa-icon"></i>
                                      <div class="notification-content"><strong>${title}</strong><br>${message.replace(/\n/g, '<br>')}</div>
                                      <button type="button" class="notification-close" aria-label="Close">&times;</button>`;

            container.appendChild(notification); // Add to the DOM

            // Get close button and add click listener for manual dismissal
            const closeBtn = notification.querySelector('.notification-close');
            const removeNotification = () => {
                notification.classList.add('removing'); // Add class to trigger slide-out animation
                // Remove the element after the animation completes
                setTimeout(() => {
                    // Check if parentNode still exists before removing
                    if (notification.parentNode) {
                         notification.parentNode.removeChild(notification);
                    }
                }, 300); // Match timeout to CSS animation duration
            };

            closeBtn?.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                removeNotification();
            });

            // Auto-dismiss after duration (if duration > 0)
            if (duration > 0) {
                setTimeout(removeNotification, duration);
            }
        }

        // === State Persistence === (Keep as is, still useful for resuming sessions)

        // Saves the current relevant state to localStorage
        function saveAppState() {
             // Only save state if an exam is actively loaded or in progress
            if (!examDetails || (examQuestionsModule && examQuestionsModule.classList.contains('hidden') && !submissionConfirmationModule.classList.contains('hidden'))) {
                 // Don't save if no exam loaded, or if exam is finished (confirmation shown)
                 // If questions module is hidden but confirmation is also hidden, it means we are in setup phase, safe to save.
                 if (examQuestionsModule && examQuestionsModule.classList.contains('hidden') && submissionConfirmationModule.classList.contains('hidden')) {
                     // Proceed to save setup state (PIN entered etc.)
                 } else {
                    console.log("Not saving state: Exam not active or already submitted.");
                    // Consider explicitly clearing state if submission occurred but wasn't cleared?
                    // localStorage.removeItem(appStateKey);
                    return;
                 }
             }

            try {
                const state = {
                    // Auth info
                    isSignedIn: isSignedIn,
                    currentUserEmail: currentUser?.email, // Save email to match state to user

                    // Exam progress info
                    examDetails: examDetails, // Includes PIN, Mode, Questions JSON, OriginalOrderMap etc.
                    studentPINEntered: studentPINEntered, // PIN used to load this exam
                    studentExamIdEntered: studentExamIdEntered, // Student ID if Exam mode
                    examEndTime: examEndTime, // Crucial for resuming timer
                    // Potentially save current answers periodically here if needed (more complex)
                    // currentAnswers: collectCurrentAnswers() // Example placeholder
                };
                localStorage.setItem(appStateKey, JSON.stringify(state));
                console.log("Application state saved to localStorage.");
            } catch (e) {
                console.error("Error saving application state to localStorage:", e);
                // Handle potential storage limits or errors
            }
        }

        // Loads state from localStorage on initial page load
        function loadAppState() {
            const savedStateString = localStorage.getItem(appStateKey);
            if (!savedStateString) {
                console.log("No saved application state found in localStorage.");
                return; // Nothing to load
            }
            try {
                const state = JSON.parse(savedStateString);
                console.log("Found saved application state:", state);
                // **Important:** Don't automatically apply the state here.
                // The `tokenObtained` function will check this loaded state against the
                // *currently signed-in user* before deciding whether to restore it.
                // This prevents loading User A's state if User B signs in.
                // We just load it here so it's available for that check later.
            } catch (e) {
                console.error("Error parsing saved application state from localStorage:", e);
                localStorage.removeItem(appStateKey); // Clear corrupted state
            }
        }

        // Restores the application UI and state based on loaded data (called after user signs in and state matches)
async function restoreAppState(state) { // Added async
    console.log("Restoring application state...");
    // Restore key state variables
    examDetails = state.examDetails;
    studentPINEntered = state.studentPINEntered;
    studentExamIdEntered = state.studentExamIdEntered;
    examEndTime = state.examEndTime;

    // Validate restored end time (remains the same)
    if (!examEndTime || isNaN(examEndTime) || Date.now() >= examEndTime) {
        console.warn("Restored exam state has expired or end time is invalid. Clearing state.");
        localStorage.removeItem(appStateKey);
        resetExamState();
        showImprovedNotification('warning', 'Session Expired', 'Your previous exam session has expired.', 0);
        return;
    }

    showImprovedNotification('info', 'Exam Session Restored', 'Resuming your previous exam session.', 5000);

    // Rebuild UI (remains the same)
    signinPromptModule.classList.add('hidden');
    examStartModule.classList.add('hidden');
    examDetailsModule.classList.add('hidden');
    submissionConfirmationModule.classList.add('hidden');
    examQuestionsModule.classList.remove('hidden');
    displayExamDetailsHeader();

    // --- MODIFIED: Wait for questions to display before restoring answers ---
    try {
        if (examDetails && examDetails.Questions && examDetails.OriginalOrderMap) {
            console.log("Waiting for questions to display before restoring answers...");
            await displayQuestions(examDetails.Questions); // Wait for the promise here
            console.log("Questions displayed. Proceeding with answer restoration.");

            // Restore saved answers and confirmation status (logic moved here)
            if (state.currentAnswers) {
                console.log("Restoring saved answers...");
                try {
                    // Restore answers
                    for (const answerName in state.currentAnswers) {
                        const formElement = examForm.elements[answerName];
                        // ADDED: Check if element is CodeMirror editor
                        if (formElement && formElement.classList.contains('code-editor') && codeEditors[answerName]) {
                             if (state.currentAnswers[answerName] !== 'FILE_SELECTED') {
                                codeEditors[answerName].setValue(state.currentAnswers[answerName] || '');
                             }
                        }
                        else if (formElement && state.currentAnswers[answerName] !== 'FILE_SELECTED') {
                            // Handle radio buttons specifically
                            if(formElement.type === 'radio' || (formElement.length > 0 && formElement[0]?.type === 'radio')) {
                                const valueToSelect = state.currentAnswers[answerName];
                                const radios = document.querySelectorAll(`input[name="${answerName}"]`);
                                radios.forEach(radio => {
                                    radio.checked = (radio.value === valueToSelect);
                                });
                            } else {
                                formElement.value = state.currentAnswers[answerName];
                            }
                        }
                    }

                    // Restore confirmation status AFTER restoring answers
                    if (state.confirmationStatus) {
                        // Reset count before re-confirming
                        confirmedQuestionsCount = document.querySelectorAll('.text-only-confirmed').length; // Start with text_only count
                        for (const questionId in state.confirmationStatus) {
                            const questionDiv = document.getElementById(questionId);
                            // Confirm only if it was confirmed in the saved state AND is NOT text_only (which is handled separately)
                            if (questionDiv && state.confirmationStatus[questionId] && !questionDiv.classList.contains('text-only-question')) {
                                // Use confirmAnswer to apply class and disable inputs correctly
                                confirmAnswer(questionId); // This increments confirmedQuestionsCount
                            }
                        }
                    }
                     console.log(`Restored ${confirmedQuestionsCount}/${totalQuestions} confirmed answers`);

                } catch (e) {
                    console.error("Error restoring saved answers:", e);
                }
            }
             // Check confirmation status AFTER restoring everything
            checkAllConfirmed();

        } else {
            console.error("Cannot restore questions display: Missing Questions or Order Map in saved state.");
            showImprovedNotification('error', 'Restore Failed', 'Could not restore exam questions. State might be corrupted.', 0);
            localStorage.removeItem(appStateKey);
            resetExamState();
            return;
        }
    } catch (displayError) {
        // Handle errors from displayQuestions if it rejects
         console.error("Error during question display in restoreAppState:", displayError);
         showImprovedNotification('error', 'Restore Failed', 'Could not display exam questions during restore.', 0);
         localStorage.removeItem(appStateKey);
         resetExamState();
         return;
    }

    // Restart the timer
    startTimer();
    console.log("Application state restoration process complete.");
}

    </script>

</body>
</html>