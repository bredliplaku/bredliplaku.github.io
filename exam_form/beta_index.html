<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"> <title>Exam Portal</title>
    <link rel="icon" type="image/png" href="https://bredliplaku.github.io/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/monokai.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/closebrackets.min.js"></script>
<style>
    /* --- CSS --- */
    :root {
        --primary-color: #3949ab;
        --primary-dark: #1a237e;
        --secondary-color: #ffa726;
        --background-color: #f4f4f4;
        --card-background: #ffffff;
        --text-color: #333333;
        --text-light: #ffffff;
        --success-color: #43a047;
        --warning-color: #fb8c00;
        --info-color: #2196F3;
        --danger-color: #f44336;
        --border-color: #e0e0e0; /* Added border color variable */
        --confirmed-bg-light: #e8f5e9; /* Light green for confirmed header/background */
        --confirmed-border-color: #7cb342; /* Darker green for border */
    }

    *, *::before, *::after {
        box-sizing: border-box;
    }

    body, html {
        margin: 0;
        padding: 0;
        font-family: 'Roboto', sans-serif;
        background: var(--background-color);
        color: var(--text-color);
        line-height: 1.6; /* Consistent line height */
    }

    .container {
        max-width: 1000px;
        margin: 20px auto; /* Centered margin */
        padding: 20px;
    }

    /* --- Loading Styles --- */
    .app-loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #f4f4f4; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; transition: opacity 0.5s ease-out; }
    .app-loading.hidden { opacity: 0; pointer-events: none; }
    .loading-spinner { border: 5px solid rgba(57, 73, 171, 0.2); border-top: 5px solid var(--primary-color); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* --- Content Visibility --- */
    .content-hidden { visibility: hidden; opacity: 0; }
    .content-visible { visibility: visible; opacity: 1; transition: opacity 0.5s ease-in; }

    /* --- App Header --- */
    .app-header {
        background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
        color: var(--text-light);
        padding: 25px 30px; /* Consistent padding */
        border-radius: 15px;
        margin-bottom: 30px; /* More space below header */
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        -webkit-user-select: none;
        -khtml-user-select: none;
    }
    .app-header h1 {
        margin: 0 0 10px 0;
        font-weight: 500; /* Slightly less bold */
        font-size: 2.0em;
        display: flex; align-items: center; gap: 10px;
    }
    .app-header h2 {
        margin: 0;
        font-weight: 400;
        font-size: 1.1em; /* Slightly larger */
        opacity: 0.9;
    }
    .app-info { display: flex; flex-wrap: wrap; margin-top: 15px; gap: 10px; }
    .info-item {
        background-color: rgba(255,255,255,0.15); /* Slightly more opaque */
        color: var(--text-light);
        padding: 8px 15px; /* Adjusted padding */
        border-radius: 20px; /* Pill shape */
        font-size: 0.9em;
        line-height: 1.5; /* Adjusted line-height */
        display: inline-flex; align-items: center; gap: 8px;
    }

    /* --- Base Module Styles --- */
    .module {
        background-color: var(--card-background);
        border-radius: 12px; /* Consistent radius */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        margin-bottom: 25px; /* Consistent margin */
        overflow: hidden; /* Needed for collapsing content */
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .module-header {
        background-color: var(--primary-color);
        color: var(--text-light);
        padding: 12px 20px; /* Adjusted padding */
        font-weight: 500;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap; /* Allow wrapping */
        gap: 10px; /* Space between items if they wrap */
        position: relative; /* For absolute positioned elements inside if needed */
        border-bottom: 1px solid rgba(0, 0, 0, 0.1); /* Subtle separator */
    }
    .module-title {
        font-size: 1.1em; display: flex; align-items: center; gap: 10px; flex-grow: 1; /* Allow title to take space */
    }
    .module-content {
        padding: 20px; /* Default padding for non-collapsing modules */
    }
    .not-signed-in-message { /* Style for sign-in prompt */
        text-align: center; padding: 30px 20px; color: #555;
    }
    .not-signed-in-message h3 { margin-top: 0; margin-bottom: 10px; color: var(--primary-dark); }
    .not-signed-in-message i { font-size: 2em; color: var(--primary-color); margin-bottom: 15px; display: block; }

    /* --- Buttons (Corrected Theming) --- */
    button {
        display: inline-flex; align-items: center; justify-content: center; gap: 8px;
        background-color: var(--primary-color); color: var(--text-light);
        padding: 10px 20px; border-radius: 20px; font-size: 0.9em; font-weight: 500; /* Added weight */
        transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s, opacity 0.2s; /* Added opacity */
        text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border: 0; cursor: pointer;
        -webkit-user-select: none; -khtml-user-select: none;
    }
    button:hover:not(:disabled) {
        background-color: var(--primary-dark); /* Default hover */
        transform: translateY(-1px); /* Subtle lift */
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    button:disabled {
        background-color: #ccc; color: #666; opacity: 0.7; cursor: not-allowed; transform: none; box-shadow: none;
    }
    /* -- Applying Correct Theme Colors to Button Classes -- */
    button.btn-green, .btn-green { /* Target both tag and class */
        background-color: var(--success-color); color: white;
    }
    button.btn-green:hover:not(:disabled), .btn-green:hover:not(:disabled) {
        background-color: #367c39; /* Darker green */
    }
    button.btn-blue, .btn-blue {
        background-color: var(--info-color); color: white;
    }
    button.btn-blue:hover:not(:disabled), .btn-blue:hover:not(:disabled) {
        background-color: #1976D2; /* Darker blue */
    }
    button.btn-orange, .btn-orange {
        background-color: var(--warning-color); color: white;
    }
    button.btn-orange:hover:not(:disabled), .btn-orange:hover:not(:disabled) {
        background-color: #e65100; /* Darker orange */
    }
    button.btn-grey, .btn-grey {
        background-color: #6c757d; color: white;
    }
    button.btn-grey:hover:not(:disabled), .btn-grey:hover:not(:disabled) {
        background-color: #5a6268; /* Darker grey */
    }
    /* Keep btn-sm as is */
    button.btn-sm, .btn-sm {
        padding: 6px 12px; font-size: 0.85em; border-radius: 15px;
    }

    /* --- Notifications (Keep as is) --- */
    .in-page-notifications { position: fixed; bottom: 20px; right: 20px; z-index: 10000; width: 350px; max-width: 90%; pointer-events: none; }
    .in-page-notification { background-color: white; border-radius: 10px; padding: 15px; margin-bottom: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); animation: slide-in 0.3s ease-out, glow 2s infinite alternate; overflow: hidden; display: flex; align-items: center; opacity: 1; transition: transform 0.3s ease-in, opacity 0.3s ease-in; pointer-events: auto; }
    .in-page-notification.removing { opacity: 0; transform: translateX(100%); }
    @keyframes slide-in { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    @keyframes glow { from { box-shadow: 0 0 5px rgba(0,0,0,0.1); } to { box-shadow: 0 0 15px rgba(0,0,0,0.2); } }
    .in-page-notification i.fa-icon { margin-right: 10px; font-size: 1.2em; flex-shrink: 0; }
    .notification-content { flex-grow: 1; }
    .notification-close { background: none; border: none; font-size: 20px; line-height: 1; color: inherit; opacity: 0.7; padding: 0 5px; margin-left: 10px; cursor: pointer; }
    .notification-close:hover { opacity: 1; }
    .in-page-notification-info { background-color: #e3f2fd; color: #0d47a1; }
    .in-page-notification-warning { background-color: #fff3e0; color: #e65100; }
    .in-page-notification-error { background-color: #ffebee; color: #b71c1c; }
    .in-page-notification-success { background-color: #e8f5e9; color: #1b5e20; }

    /* --- Forms (Keep as is) --- */
    .form-group { margin-bottom: 20px; }
    .form-group label { display: block; margin-bottom: 8px; font-weight: 500; }
    .form-control { width: 100%; padding: 12px; border: 1px solid var(--border-color, #ccc); border-radius: 8px; font-size: 1em; transition: opacity 0.3s, background-color 0.3s, color 0.3s, border-color 0.3s; background-color: #fff; color: #333; opacity: 1; }
    input:disabled, textarea:disabled { background-color: #eee; cursor: not-allowed; opacity: 0.7; }
    textarea.form-control { min-height: 100px; }
    #exam-details-display p { margin: 8px 0; }

    /* --- Footer (Keep as is) --- */
    .footer { max-width: 1000px; text-align: center; padding: 20px 0; color: var(--primary-dark); border-radius: 20px; margin: 30px auto 10px auto; font-size: 0.9em; }
    .social-links { margin-bottom: 10px; margin-top: 10px; }
    .social-links a { color: var(--primary-dark); font-size: 1.0em; margin: 0 10px; transition: color 0.3s; }
    .social-links a:hover { color: var(--secondary-color); }

    /* --- Auth/Sync (Keep as is) --- */
    .auth-container { display: flex; justify-content: flex-end; align-items: center; gap: 10px; }
    .user-info { display: flex; align-items: center; gap: 10px; }
    .user-avatar { width: 32px; height: 32px; border-radius: 50%; }
    .sync-auth-container { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; margin-bottom: 10px; border-bottom: 1px solid #eee; flex-wrap: wrap; gap: 10px; /* Allow wrap */}
    .sync-container { display: flex; align-items: center; gap: 10px; }
    .sync-status { display: flex; align-items: center; gap: 5px; font-size: 0.9em; }
    .sync-status.online i { color: var(--success-color); }
    .sync-status.offline i { color: var(--warning-color); }

    /* --- CodeMirror Styles (Keep as is) --- */
    .CodeMirror { height: auto ; min-height: 150px; border: 1px solid #ccc; border-radius: 6px; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 14px; line-height: 1.4; }
    .cm-s-monokai .cm-keyword {color: #f92672 !important;} /* !important likely needed */
    /* ... (keep all other .cm-s-monokai color overrides) ... */
	.cm-s-monokai .cm-operator {color: #f92672 !important;}
	.cm-s-monokai .cm-variable-2 {color: #9effff !important;}
	.cm-s-monokai .cm-variable-3, .cm-s-monokai .cm-type {color: #66d9ef !important;}
	.cm-s-monokai .cm-builtin {color: #a6e22e !important;}
	.cm-s-monokai .cm-atom {color: #ae81ff !important;}
	.cm-s-monokai .cm-number {color: #ae81ff !important;}
	.cm-s-monokai .cm-def {color: #fd971f !important;}
	.cm-s-monokai .cm-string {color: #e6db74 !important;}
	.cm-s-monokai .cm-comment {color: #75715e !important;}
	.cm-s-monokai .cm-variable {color: #f8f8f2 !important;}
	.cm-s-monokai .cm-tag {color: #f92672 !important;}
	.cm-s-monokai .cm-attribute {color: #a6e22e !important;}
	.cm-s-monokai .cm-property {color: #66d9ef !important;}
    .cm-confirmed { opacity: 0.7; }
    .cm-confirmed .CodeMirror-scroll { background-color: rgba(0,0,0,0.1); }
    .CodeMirror-cursor { border-left: 1px solid white !important; }
    .cm-s-monokai.CodeMirror { background: #272822 !important; color: #f8f8f2 !important; }
    .CodeMirror-linenumber { color: #75715e !important; }
    .cm-s-monokai .CodeMirror-selected { background: rgba(255,255,255,0.1) !important; }

    /* ==========================================================================
       NEW: Exam Questions as Modules (Collapsible on Confirm)
       ========================================================================== */
    #exam-questions-area {
        margin-top: 20px;
        /* Removed padding/background/border - handled by modules now */
    }

    .question-module {
        background-color: var(--card-background);
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        margin-bottom: 25px;
        overflow: hidden;
        border: 1px solid var(--border-color); /* Add subtle border */
        transition: background-color 0.3s ease, border-left 0.3s ease, border-color 0.3s ease; /* Smooth transitions */
    }

    .question-header {
        background-color: #f7f9fc; /* Lighter header for questions */
        padding: 10px 15px;
        font-weight: 500;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--border-color);
        position: relative; /* For absolute positioned badge */
        flex-wrap: wrap; /* Allow wrapping */
        gap: 10px;
        /* cursor: pointer; */ /* Remove cursor pointer - header doesn't toggle */
    }

    .question-title {
        font-size: 1.1em;
        color: var(--primary-dark);
        flex-grow: 1;
    }
    .question-title strong { font-weight: 700; }
    .points-badge {
        display: inline-block;
        background-color: var(--info-color);
        color: white;
        font-size: 0.8em;
        padding: 3px 10px;
        border-radius: 15px;
        margin-left: 8px;
        vertical-align: middle;
        font-weight: 600;
    }

    /* Content area within the question module */
    .question-content-area {
        padding: 20px; /* Default padding */
        max-height: 2500px; /* Start expanded - large max-height */
        overflow: hidden; /* Important for collapsing */
        transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out, opacity 0.4s ease-in-out;
        opacity: 1;
    }

    /* Collapsed state when .confirmed class is added */
    .question-module.confirmed .question-content-area {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        opacity: 0;
        /* overflow: hidden; */ /* Already set above */
    }

    /* Style confirmed header */
    .question-module.confirmed {
        background-color: var(--confirmed-bg-light);
        border-left: 5px solid var(--confirmed-border-color);
        border-color: var(--confirmed-border-color);
    }
     .question-module.confirmed .question-header {
        background-color: transparent; /* Or a slightly different shade */
        border-bottom-color: transparent; /* Hide border when collapsed */
     }

    /* Confirmed badge using ::after on the header */
    .question-header::after {
        content: "âœ“ CONFIRMED";
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.8em;
        background-color: var(--success-color);
        color: white;
        padding: 3px 10px;
        border-radius: 15px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        font-weight: 600;
        opacity: 0; /* Hidden by default */
        transition: opacity 0.3s ease;
        pointer-events: none;
    }
    .question-module.confirmed .question-header::after {
        opacity: 1; /* Show badge when confirmed */
    }


    .question-prompt-display {
        margin-bottom: 15px;
        line-height: 1.5;
        /* Style prompt text */
    }
     .question-prompt-display em.term {
        background-color: rgba(255, 167, 38, 0.15); padding: 2px 4px; border-radius: 3px; font-style: normal; font-weight: 500; color: #d84315;
     }
     .question-prompt-display strong { font-weight: bold; }


    .question-answer-area {
        margin-bottom: 15px; /* Space before actions */
    }

    /* --- Question Action Buttons --- */
    .question-actions {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px; /* Space above buttons */
        padding-top: 15px; /* Space */
        border-top: 1px solid var(--border-color); /* Separator */
    }
    /* Buttons use standard .btn-* classes now */
    /* Hide Edit button by default */
    .question-module:not(.confirmed) .btn-edit {
        display: none;
    }
    /* Hide Confirm button when confirmed */
    .question-module.confirmed .btn-confirm {
        display: none;
    }

    /* Keep checkbox styles */
     .checkbox-group { display: flex ; flex-wrap: wrap ; gap: 12px ; margin-top: 10px; }
     .checkbox-item { flex: 1 1 180px; margin-right: 0; margin-bottom: 8px; background-color: #f8f9fa; padding: 8px 12px; border-radius: 6px; transition: background-color 0.2s; border: 1px solid #dee2e6; display: flex; align-items: center; }
     .checkbox-item:hover { background-color: #e9ecef; border-color: #ced4da; }
     .checkbox-item input[type="radio"] { margin-right: 8px; cursor: pointer; width: 16px; height: 16px; }
     .checkbox-item input[type="radio"]:checked + label { font-weight: 500; color: var(--primary-dark); }
     .checkbox-item:has(input[type="radio"]:checked) { background-color: #e3f2fd; border-color: #90caf9; }
     .checkbox-item label { margin-bottom: 0; font-weight: normal; cursor: pointer; flex-grow: 1; transition: color 0.3s; }


    /* --- Sticky Timer (Keep as is) --- */
    .sticky-timer { position: fixed; top: 15px; left: 50%; transform: translateX(-50%); color: white; z-index: 1000; font-size: 1.1em; font-weight: 700; padding: 12px 24px; border-radius: 30px; box-shadow: 0 3px 15px rgba(0,0,0,0.15); background-color: var(--primary-color); transition: background-color 0.5s ease; }
    .sticky-timer i { font-size: 1.2em; margin-right: 8px; }
    .sticky-timer.warning { background: linear-gradient(to right, #ff9800, #f57c00); }
    .sticky-timer.danger { background: linear-gradient(to right, #f44336, #d32f2f); animation: pulse 0.8s infinite alternate; }
    .sticky-timer.expired { background: #6c757d; }
    @keyframes pulse { from { transform: translateX(-50%) scale(1); box-shadow: 0 4px 10px rgba(0,0,0,0.2); } to { transform: translateX(-50%) scale(1.03); box-shadow: 0 4px 15px rgba(211,47,47,0.4); } }

    /* --- Body Background Timer States (Keep as is) --- */
    body.time-warning { background-color: #fff8e1; transition: background-color 1s; }
    body.time-danger { background-color: #ffebee; transition: background-color 1s; }
    body.time-expired { background-color: #ffcdd2; } /* Fixed hex */

    /* --- Backup Modal (Keep as is) --- */
    .backup-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 2000; opacity: 0; visibility: hidden; transition: opacity 0.3s; }
    .backup-modal.visible { opacity: 1; visibility: visible; }
    .backup-modal-content { background-color: white; border-radius: 10px; width: 90%; max-width: 600px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); display: flex; flex-direction: column; max-height: 90vh; transform: scale(0.9); transition: transform 0.3s; }
    .backup-modal.visible .backup-modal-content { transform: scale(1); }
    .backup-modal-header { padding: 15px 20px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
    .backup-modal-header h3 { margin: 0; color: var(--primary-dark); }
    .backup-close-btn { background: none; border: none; font-size: 24px; cursor: pointer; color: #999; }
    .backup-modal-body { padding: 20px; overflow-y: auto; flex-grow: 1; }
    .backup-modal-footer { padding: 15px 20px; border-top: 1px solid #eee; display: flex; justify-content: flex-end; gap: 10px; }
    .backup-preview { margin-top: 15px; padding: 15px; background-color: #f5f5f5; border-radius: 5px; max-height: 200px; overflow-y: auto; }
    .backup-info p { margin: 5px 0; }
    .backup-error { color: var(--danger-color); }

    /* --- Misc Text Styles (Keep as is) --- */
    label.code-prompt { white-space: pre-wrap; font-family: monospace; display: block; background-color: #f8f9fa; padding: 10px; border: 1px solid #eee; border-radius: 4px; line-height: 1.4; margin-bottom: 10px; }
    label em.term, div em.term { font-style: italic; font-weight: bold; color: var(--primary-dark); }

    /* --- Submit Button (Keep as is) --- */
    #submit-exam-btn { margin-top: 30px; width: 100%; font-size: 1.1em; transition: all 0.3s ease; position: relative; overflow: hidden; background: linear-gradient(to right, var(--success-color), #2e7d32); font-weight: 500; padding: 15px 30px; border-radius: 30px; box-shadow: 0 4px 12px rgba(46, 125, 50, 0.3); color: white; /* Ensure text is visible */ }
    #submit-exam-btn:hover:not(:disabled) { box-shadow: 0 6px 16px rgba(46, 125, 50, 0.4); transform: translateY(-2px); }
    #submit-exam-btn::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to right, rgba(255,255,255,0.1), transparent); transform: translateX(-100%); transition: transform 0.6s ease; }
    #submit-exam-btn:hover::after { transform: translateX(100%); }

    /* --- Utility --- */
    .hidden { display: none !important; }
    #timer-display { font-weight: bold; }
    .confirmation-message { text-align: center; font-weight: bold; color: var(--success-color); padding: 30px; font-size: 1.2em; }
    .file-helper-text { display: block; margin-top: 5px; color: #666; font-size: 0.85em; }
    .length-limit-note { display: block; margin-top: 5px; color: #757575; font-size: 0.8em; font-style: italic; }

    /* --- Responsive --- */
    @media (max-width: 768px) {
        .sync-auth-container { flex-direction: row; flex-wrap: nowrap; gap: 10px; border-bottom: 1px solid #eee; /* Restore border */ } /* Revert to row */
        .auth-container { width: auto; justify-content: flex-end;}
        .sync-container { width: auto; justify-content: flex-start; /* Align sync left */ }
        .user-info span { max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .in-page-notifications { width: 90%; left: 50%; transform: translateX(-50%); bottom: 10px; right: auto;}
        #exam-questions-area .checkbox-group { flex-direction: column; }
        #exam-questions-area .checkbox-item { width: 100%; margin-right: 0 ; flex-basis: auto; }
        .app-info { flex-direction: column; }
        .info-item { width: 100%; margin-bottom: 5px; }
        .sticky-timer { padding: 8px 16px; font-size: 1em; }
        .question-header { padding: 8px 12px;}
        .question-title { font-size: 1em;}
        .points-badge { font-size: 0.75em; padding: 2px 8px;}
        .question-header::after { /* Adjust badge position on mobile */ right: 8px; font-size: 0.75em; padding: 2px 8px;}
    }

</style>
</head>
<body class="content-hidden">
    <div id="app-loading" class="app-loading">
        <img src="https://raw.githubusercontent.com/bredliplaku/bredliplaku.github.io/refs/heads/main/loading.gif" alt="Loading..." style="width: 150px; height: 150px;">
        <div style="margin-top: 10px; font-size: 14px; color: #666;">Loading Exam Portal...</div>
    </div>
    <div class="container" id="main-container">
        <div class="sync-auth-container">
            <div class="sync-container">
                 <div id="sync-status" class="sync-status offline">
                    <i class="fas fa-circle"></i>
                    <span id="sync-text">Offline</span>
                </div>
            </div>
            <div class="auth-container">
                 <div id="login-container">
                    <button id="login-btn" class="btn-blue"> <i class="fas fa-sign-in-alt"></i> Sign in
                    </button>
                </div>
                 <div id="user-container" style="display: none">
                    <div class="user-info">
                        <img id="user-avatar" class="user-avatar" src="" alt="Avatar">
                        <span id="user-name"></span>
                         <button id="logout-btn" class="btn-sm btn-grey"> <i class="fas fa-sign-out-alt"></i>
                        </button>
                    </div>
                 </div>
            </div>
        </div>
        <div class="app-header">
             <h1><i class="fa-solid fa-clipboard-question"></i> Exam Portal</h1>
             <div class="app-info">
                 <span class="info-item">
                       <i class="fa-solid fa-table-list"></i> Course:
                     <span id="exam-code-display">N/A</span>
                 </span>
                 <span class="info-item">
                     <i class="far fa-clock "></i> Duration: <span id="exam-duration-display">N/A</span>
                 </span>
                 <span class="info-item">
                     <i class="fas fa-calendar-alt"></i> Start Time:
                     <span id="exam-start-time-display">N/A</span>
                 </span>
             </div>
        </div>
        <h2 id="exam-name-header">Enter PIN to load exam</h2>

        <div id="in-page-notification-area" class="in-page-notifications"></div>

        <div id="signin-prompt-module" class="module">
            <div class="module-content not-signed-in-message">
                 <h3><i class="fas fa-info-circle"></i> Welcome</h3>
                 <p>Sign in with your University Google Account.</p>
            </div>
        </div>
        <div id="exam-start-module" class="module hidden">
            <div class="module-header">
                <span class="module-title"> <i class="fas fa-user-check"></i> Student Details </span>
            </div>
            <div class="module-content">
                 <div class="form-group">
                     <label for="student-name">Name:</label>
                     <input type="text" id="student-name" class="form-control" disabled>
                 </div>
                 <div class="form-group">
                     <label for="student-email">Email:</label>
                     <input type="email" id="student-email" class="form-control" disabled>
                 </div>
                 <div class="form-group">
                     <label for="exam-pin-input">Exam PIN:</label>
                     <input type="text" id="exam-pin-input" class="form-control" placeholder="The lecturer will provide you with the PIN">
                 </div>
                 <div id="student-exam-id-group" class="form-group hidden">
                     <label for="student-exam-id-input">Student Exam ID (Confidential - 5 characters):</label>
                     <input type="text" id="student-exam-id-input" class="form-control" placeholder="Enter your Exam ID from the attendance sheet" maxlength="5">
                 </div>
                 <button id="load-exam-btn" class="btn-info" disabled> <i class="fas fa-download"></i> Load Exam
                 </button>
                 <button id="start-exam-btn-alt" class="btn-success hidden" disabled> <i class="fas fa-play"></i> Start Exam
                 </button>
             </div>
        </div>
        <div id="exam-details-module" class="module hidden">
            <div class="module-header">
                <span class="module-title"> <i class="fas fa-info-circle"></i> Exam Information </span>
            </div>
            <div class="module-content" id="exam-details-display">
                 <p> <strong>Exam Name:</strong> <span id="exam-name-detail"></span> </p>
                  <p> <strong>Course Code:</strong> <span id="exam-course-code-detail"></span> </p>
                  <p> <strong>Mode:</strong> <span id="exam-mode-detail"></span> </p>
                  <p> <strong>Duration:</strong> <span id="exam-duration-detail"></span> </p>
                  <p> <strong>Start Time:</strong> <span id="exam-start-time-detail"></span> </p>
                  <button id="start-exam-btn" class="btn-success" disabled> <i class="fas fa-play"></i> Start Exam
                 </button>
            </div>
        </div>
        <form id="exam-form">
            <div id="exam-questions-area">
                <p>Loading questions...</p>
            </div>
            <button type="button" id="submit-exam-btn" class="btn-success" disabled> <i class="fas fa-check-circle"></i> Submit Exam
            </button>
        </form>

        <div id="submission-confirmation-module" class="module hidden">
             <div class="module-content confirmation-message">
                 <i class="fas fa-check-circle fa-3x" style="color: var(--success-color); margin-bottom: 15px;"></i><br>
                 Exam Submitted Successfully!
            </div>
        </div>
        <footer class="footer">
             <div class="social-links">
                 <a href="https://eis.epoka.edu.al/cv/fullcv/655" target="_blank" rel="noopener noreferrer"><i class="far fa-id-card"></i></a>
                 <a href="mailto:bplaku@epoka.edu.al" target="_blank" rel="noopener noreferrer"><i class="far fa-envelope"></i></a>
             </div>
              <p style="font-size:0.7em"><i class="far fa-copyright"></i> 2023-<span id="currentYear"></span> Bredli Plaku. All Rights Reserved.</p>
        </footer>
    </div> <script>
    // === Configuration ===
    const ADMIN_EMAILS = ['bplaku@epoka.edu.al'];
    const CLIENT_ID = '740588046540-npg0crodtcuinveu6bua9rd6c3hb2s1m.apps.googleusercontent.com';
    const SCOPES = "https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile";
    const BACKEND_URL = 'https://script.google.com/macros/s/AKfycbx-jSJ9gVzM6b975hEY6bEbM3JOTawq5Av8LE61-gJV8mi7cymPq9lj3k9OZJpxCrlD/exec';
    const appStateKey = 'examAppState';
    const TOKEN_REFRESH_INTERVAL = 20 * 60 * 1000;
    const INACTIVITY_WARNING_TIME = 15 * 60 * 1000;
    const AUTO_SAVE_INTERVAL = 3 * 60 * 1000;

    // === App State ===
    let isAdmin = false;
    let isSignedIn = false;
    let currentUser = null;
    let tokenClient = null;
    let isOnline = navigator.onLine;
    let isSyncing = false;
    let isInitializing = true;
    let examDetails = null;
    let studentPINEntered = '';
    let studentExamIdEntered = '';
    let examTimerInterval = null;
    let examEndTime = null;
    let totalQuestions = 0;
    let confirmedQuestionsCount = 0;
    let tokenRefreshTimer = null;
    let inactivityTimer = null;
    let lastActivityTime = Date.now();
    let autoSaveTimer = null;
    let codeEditors = {};

    // === DOM Elements Cache === (Simplified access)
    const loadingIndicator = document.getElementById('app-loading');
    const mainContainer = document.getElementById('main-container');
    const syncStatus = document.getElementById('sync-status');
    const syncText = document.getElementById('sync-text');
    const loginBtn = document.getElementById('login-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const loginContainer = document.getElementById('login-container');
    const userContainer = document.getElementById('user-container');
    const userName = document.getElementById('user-name');
    const userAvatar = document.getElementById('user-avatar');
    const notificationArea = document.getElementById('in-page-notification-area');
    const examNameHeader = document.getElementById('exam-name-header');
    const examCodeDisplay = document.getElementById('exam-code-display');
    const examDurationDisplay = document.getElementById('exam-duration-display');
    const examStartTimeDisplay = document.getElementById('exam-start-time-display');
    const signinPromptModule = document.getElementById('signin-prompt-module');
    const examStartModule = document.getElementById('exam-start-module');
    const studentNameInput = document.getElementById('student-name');
    const studentEmailInput = document.getElementById('student-email');
    const examPinInput = document.getElementById('exam-pin-input');
    const studentExamIdGroup = document.getElementById('student-exam-id-group');
    const studentExamIdInput = document.getElementById('student-exam-id-input');
    const loadExamBtn = document.getElementById('load-exam-btn');
    const examDetailsModule = document.getElementById('exam-details-module');
    // const examDetailsDisplay = document.getElementById('exam-details-display'); // Content within module
    const examNameDetail = document.getElementById('exam-name-detail');
    const examCourseCodeDetail = document.getElementById('exam-course-code-detail');
    const examModeDetail = document.getElementById('exam-mode-detail');
    const examDurationDetail = document.getElementById('exam-duration-detail');
    const examStartTimeDetail = document.getElementById('exam-start-time-detail');
    const startExamBtn = document.getElementById('start-exam-btn');
    const startExamBtnAlt = document.getElementById('start-exam-btn-alt');
    // const examQuestionsModule = document.getElementById('exam-questions-module'); // Removed this wrapper
    const examForm = document.getElementById('exam-form');
    const examQuestionsArea = document.getElementById('exam-questions-area'); // Target for rendering question modules
    const submitExamBtn = document.getElementById('submit-exam-btn');
    // const timerDisplay = document.getElementById('timer-display'); // Removed from header, integrated into sticky
    const submissionConfirmationModule = document.getElementById('submission-confirmation-module');


    // === Initialisation ===
    window.addEventListener('load', init);

    function init() {
        console.log("Initialising...");
        // Make sure elements exist before accessing properties
        if(document.body) document.body.classList.remove('content-hidden');
        if(mainContainer) mainContainer.classList.add('content-visible');
        updateYear();
        setupEventListeners();
        loadAppState();
        updateOnlineStatus();
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);
        setupBackupImportFeature();
        setupSessionManagement(); // Added call

        // Use polling for Google API init
        let checkGoogleApiInterval = setInterval(() => {
            if (typeof gapi !== 'undefined' && typeof google !== 'undefined' && typeof google.accounts !== 'undefined') {
                clearInterval(checkGoogleApiInterval);
                console.log("Google API objects detected.");
                initGoogleApi();
            } else {
                console.log("Waiting for Google API objects to load...");
            }
        }, 200);
        setTimeout(() => {
            if (checkGoogleApiInterval) {
                clearInterval(checkGoogleApiInterval);
                console.error("Google API objects failed to load within 10 seconds.");
                handleApiInitError(new Error("Google API objects did not load in time"));
            }
        }, 10000);
    }

    function setupEventListeners() {
        loginBtn?.addEventListener('click', handleAuthClick);
        logoutBtn?.addEventListener('click', handleSignoutClick);
        loadExamBtn?.addEventListener('click', handleLoadExam);
        startExamBtn?.addEventListener('click', handleStartExam);
        startExamBtnAlt?.addEventListener('click', handleStartExam);
        submitExamBtn?.addEventListener('click', () => handleSubmitExam(false));

        examPinInput?.addEventListener('input', () => {
            if (loadExamBtn) {
                loadExamBtn.disabled = examPinInput.value.trim() === '' || !isSignedIn || !isOnline;
            }
        });
        studentExamIdInput?.addEventListener('input', validateStudentExamIdInput);

        // Initial button states
        if (loadExamBtn) loadExamBtn.disabled = true;
        if (startExamBtn) startExamBtn.disabled = true;
        if (startExamBtnAlt) startExamBtnAlt.classList.add('hidden');
        if (submitExamBtn) submitExamBtn.disabled = true;
    }

    function setupSessionManagement() {
        document.addEventListener('mousemove', recordUserActivity);
        document.addEventListener('keydown', recordUserActivity);
        document.addEventListener('click', recordUserActivity);
        lastActivityTime = Date.now();
        startAutoSave();
    }

    function showAppContent() {
        loadingIndicator?.classList.add('hidden');
        mainContainer?.classList.add('content-visible');
        console.log("App content shown.");
    }

    function updateYear() {
        const el = document.getElementById('currentYear');
        if (el) el.textContent = new Date().getFullYear();
    }

    // --- Other helper functions (recordUserActivity, startInactivityDetection, showInactivityWarning, startTokenRefresh, etc.) remain largely the same ---
    // --- Paste the definitions for these functions here from the previous version ---
    function recordUserActivity() { const now = Date.now(); const timeSinceLastActivity = now - lastActivityTime; lastActivityTime = now; if (timeSinceLastActivity > 10 * 60 * 1000) { console.log(`Detected activity after ${timeSinceLastActivity/1000}s inactivity, refreshing token...`); refreshTokenIfNeeded(true); } if (inactivityTimer) { clearTimeout(inactivityTimer); inactivityTimer = null; } startInactivityDetection(); }
    function startInactivityDetection() { if (inactivityTimer) { clearTimeout(inactivityTimer); } inactivityTimer = setTimeout(() => { const inactiveTime = Date.now() - lastActivityTime; if (inactiveTime >= INACTIVITY_WARNING_TIME) { showInactivityWarning(); } }, INACTIVITY_WARNING_TIME); }
    function showInactivityWarning() { showImprovedNotification( 'warning', 'Session Expiring Soon', 'You appear to be inactive. Please click, type, or move your mouse to keep your session active.', 0 ); try { const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj2a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PruXI3DypsuO7Lfy4GFmS09tW0XigPRJXn8s13Hw0sbsfz4ZU+CxFVru/mtGYpDj6S5fPQgzMKFVyy9NeybCYQPZHk9dOIPAoTW7L11rVvKRE5j+P30oc9DBJZsvTYuXMqETiM4vfWjUIMEFew89e6disRNorm99SNQAwPVK/y2bt3LBE0i+X115FDDBBTrvPau3gtEDOJ5PfYk0ULDlCt8tu8ei4PMIjj+duXSAsMTarx3L56Lw8vhOP53JlKCwxKqfLdvXwwDi2C4/vem0sKCkmo8t/AfTANK3/i/OCdTQoJRqbx4MKAMgwqfeL84p9PCwhEpfDhw4IzCyl74fzjoVELCEKk8OLEgzQLKHnh/OWhUgsIPqPv5MWENComeOL96KNTCwc9oe/lxoY1CSV24v3ppVQMBzug7+bHiDYJJHTi/eulVQ0GN5/u58iJNwkic+P+66dXDQY2nu7oyos3CSBx4v7tqVkOBTWd7enLjDgJH3Di/+2rWw4FNJL9gsdlS0dlWID/q1sOBTOS/4LHZUtHZViA/6tcDgQx9f46vMG0g/iuXQ4EMfX+OrzBtIP4r14PBC/0/j+xwbKC+bBfDwMu9P8/scGygvmxYBADLvP/Q6/BsYL6s2IRBC3y/0Suwbrt+RSjqz3JkcgTKK3x/0WuwbnskRqeqT3EmcMXJ6vw/0etx8OUEhUilELQrtAeKKrv/0erycuiDQgLaTniyOUxLajt/0eqzNe2BwEEfjHxw+k8Nqbq/0qpztunAQEGkyz/uOVFP6nn/FvP3P5q/9oIC5s9nnMUNJDS/8G44zN4VxiPw/Ds/38uYvbzGI5TFhVwwO6dOnUGTUb/PYFWEQhwv/ChQIYL/Fk3/0WKPBAEb8ABqEyGA/lWMvxJlDERAHPBBaxSgAL9VCj7TJ0qEgFzwgmwWHoC/1Ij+0+kIhQDc8MNsV11Av9TIP1SmxkVA3LEELJhcAT/Uh37Vp8SFwZyxRSzZmkF/1Ia/LineRcIcsUYtGpiBf9TF/5fpHEXCXLGG7ZvWwb/VBb/ZKlpGApwxx26dFQH/1MV/2muYBkMb8cfvXlNCP9WFP9ttFgZDW3HIL98Rgj/Stb9Km2yUhsObMgiwIE/CP9F3P0bbr9KHBBqySPBhzcJ/0Di/RBvxUIdEmnKJcWMMAr/O+f+CW/KOh4UZ8wnx5EpC/8y7f8Bb88yHhVlzCrKliIM/0Tz/59w1CofFmTNLM2aGg3/Pe///HHZICAXYs4u0J8TDv8v9gDxcNwYIhlgzi/SoxMP/yf4Ad9v3xAkGl7PMdSoSxL/OvsCw27jCCQcXNAy1q5CFP8z8AOpcOYAJh1a0TTasD0V/yvxBJlv6fgnHljRNdy2ORb/JPMFiW7s9CgfVtI33bozF/8f9QZ4bO/qKSBV0zjfwCwY/xr3B2lr8uAqIVPUOuDGJhn/FPgIWWrz1SshUtU74MsgGf8S+gg4Z/TLLCJr1TzhziCJMpT+AiVA/Fxr988tI2rVN+HPQBozk/sCKFD9YW3/4C8jatU15tZlHF2P+wYygP+YdPMzLyRp1TOc42AgfIT5BiWY+/l9CDswKWnUMjr0Mg0qcPkArP4Bhh9GL0g31jF7/mz4sS5MKvxaWPg6Li3WL8F7+dDtCDe+Mx5NeA1SLSDKCJfzBJXw0jMQVY8WSS83xmBXvhSDVxdW0GceHnbfH4dTE1LjaSYZ2OQVlFcLWeRsJRHh7gqhXQBi33QcCP36BrhkljgLPgwjEP0E0SxLvzkLy3h80wxsxkfYbdUGOw0O/sMZq4yOqMfD5hQyDQr8yxyhjIyoyM7tGS0LCPvRHqCLiqnL2vIbKQgH+tghn4qJqM3h9R4lCAb42iOeiYmoz+j4IR8GA/fcJZ2JiKjP7vogHwYC9d0nnImIqM7s/CEfBgH03SiciIiozuz9Ih8I'); audio.play().catch(e => console.warn("Could not play alert sound:", e)); } catch(e) { console.warn("Could not create alert sound:", e); } }
    function startTokenRefresh() { stopTokenRefresh(); console.log("Starting token refresh timer"); tokenRefreshTimer = setInterval(() => { refreshTokenIfNeeded(false); }, TOKEN_REFRESH_INTERVAL); }
    function stopTokenRefresh() { if (tokenRefreshTimer) { clearInterval(tokenRefreshTimer); tokenRefreshTimer = null; } }
    async function refreshTokenIfNeeded(force = false) { if (!isSignedIn || !tokenClient) { console.log("Not refreshing token: not signed in or no tokenClient"); return false; } const savedTokenStr = localStorage.getItem('gapi_token'); if (!savedTokenStr) { console.log("No token to refresh"); return false; } try { const savedToken = JSON.parse(savedTokenStr); let tokenAgeMs = Infinity; if (typeof savedToken.issued_at === 'number') { tokenAgeMs = Date.now() - savedToken.issued_at; } else { console.warn("Token 'issued_at' timestamp missing or invalid. Assuming refresh is needed."); force = true; } const needsRefresh = force || tokenAgeMs > 40 * 60 * 1000; if (needsRefresh) { console.log(`Token age: ${tokenAgeMs / 1000}s - Refreshing token...`); tokenClient.requestAccessToken({ prompt: '' }); return true; } else { console.log(`Token age: ${tokenAgeMs / 1000}s - No refresh needed`); return false; } } catch (e) { console.error("Error refreshing token:", e); return false; } }
    function startAutoSave() { stopAutoSave(); console.log("Starting auto-save timer"); autoSaveTimer = setInterval(() => { if (examQuestionsArea && !examQuestionsArea.closest('.hidden')) { autoSaveAnswers(); } }, AUTO_SAVE_INTERVAL); } // Check area not hidden
    function stopAutoSave() { if (autoSaveTimer) { clearInterval(autoSaveTimer); autoSaveTimer = null; } }
    function autoSaveAnswers() { if (!examQuestionsArea || examQuestionsArea.closest('.hidden') || !examDetails) { return; } console.log("Auto-saving current answers..."); try { const currentAnswers = {}; const confirmationStatus = {}; const originalIndices = Object.keys(examDetails.OriginalOrderMap).map(Number).sort((a, b) => a - b); originalIndices.forEach(originalIndex => { const originalQNum = originalIndex + 1; const answerName = `ans-${originalQNum}`; const questionDivId = `q-${originalQNum}`; const questionDiv = document.getElementById(questionDivId); if (questionDiv) { confirmationStatus[questionDivId] = questionDiv.classList.contains('confirmed'); } const questionData = examDetails.OriginalOrderMap[originalIndex]; if (!questionData) return; const formElement = examForm.elements[answerName]; if (formElement) { switch (questionData.type) { case 'multiple_select': currentAnswers[answerName] = formElement.value || ''; break; case 'attachment': currentAnswers[answerName] = (formElement.files && formElement.files.length > 0) ? 'FILE_SELECTED' : ''; break; case 'code': if (codeEditors[answerName]) { currentAnswers[answerName] = codeEditors[answerName].getValue();} else { currentAnswers[answerName] = formElement.value || '';} break; default: currentAnswers[answerName] = formElement.value || ''; } } }); const currentState = JSON.parse(localStorage.getItem(appStateKey) || '{}'); currentState.currentAnswers = currentAnswers; currentState.confirmationStatus = confirmationStatus; localStorage.setItem(appStateKey, JSON.stringify(currentState)); console.log("Answers auto-saved successfully"); } catch (e) { console.error("Error auto-saving answers:", e); } }
    function initializeCodeEditor(textareaId, language = 'python') { const textarea = document.getElementById(textareaId); if (!textarea) { console.warn(`Cannot initialize code editor: textarea #${textareaId} not found`); return null; } if (typeof CodeMirror === 'undefined') { console.warn('CodeMirror library not loaded. Using regular textarea.'); return null; } console.log(`Initializing simple code editor for ${textareaId} with language ${language}`); try { const editor = CodeMirror.fromTextArea(textarea, { mode: language || "python", theme: "monokai", lineNumbers: true, indentUnit: 4, tabSize: 4, indentWithTabs: false, matchBrackets: true, autoCloseBrackets: true, lineWrapping: true, extraKeys: { "Tab": function(cm) { if (cm.somethingSelected()) { cm.indentSelection("add"); } else { cm.replaceSelection("    ", "end"); } } } }); editor.setSize(null, 150); codeEditors[textareaId] = editor; console.log(`Code editor initialized for ${textareaId}`); return editor; } catch (e) { console.error(`Error initializing CodeMirror for ${textareaId}:`, e); textarea.style.display = 'block'; return null; } }
    function enhancePointsDisplay() { /* Function body needed if used */ }
    function hashString(str) { let hash = 0; if (!str || str.length === 0) return Math.floor(Math.random() * 1000000); for (let i = 0; i < str.length; i++) { const char = str.charCodeAt(i); hash = ((hash << 5) - hash) + char; hash = hash & hash; } return Math.abs(hash); }
    function seededShuffle(array, seed) { let m = array.length, t, i; while (m > 0) { seed = (seed * 1664525 + 1013904223) >>> 0; i = seed % m; m--; t = array[m]; array[m] = array[i]; array[i] = t; } return array; }
    function escapeHtml(unsafe) { if (typeof unsafe !== 'string') return unsafe; return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
    function addAttachmentValidation(inputId) { /* Function body needed if used */ }
    function getFingerprintData() { const webglFp = getWebglFingerprint(); const data = { ua: navigator.userAgent || 'N/A', lang: navigator.language || 'N/A', vendor: navigator.vendor || 'N/A', cookieEnabled: navigator.cookieEnabled || false, doNotTrack: navigator.doNotTrack || 'unknown', plugins: Array.from(navigator.plugins || []).map(p => ({ name: p.name, filename: p.filename })).sort((a,b) => a.name.localeCompare(b.name)), mimeTypes: Array.from(navigator.mimeTypes || []).map(m => ({ type: m.type, description: m.description })).sort((a,b) => a.type.localeCompare(b.type)), platform: navigator.platform || 'N/A', cores: navigator.hardwareConcurrency || undefined, memory: navigator.deviceMemory || undefined, maxTouchPoints: navigator.maxTouchPoints || 0, screenRes: `${screen.width || 0}x${screen.height || 0}x${screen.colorDepth || 0}`, availScreenRes: `${screen.availWidth || 0}x${screen.availHeight || 0}`, windowInnerSize: `${window.innerWidth || 0}x${window.innerHeight || 0}`, timezoneOffset: new Date().getTimezoneOffset(), webglAvailable: webglFp.available, webglVendor: webglFp.vendor, webglRenderer: webglFp.renderer, ts: Date.now() }; console.log("Collected Fingerprint Data:", data); return data; }
    function getWebglFingerprint() { try { const canvas = document.createElement('canvas'); const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); if (!gl) { return { available: false, vendor: 'N/A', renderer: 'N/A' }; } const debugInfo = gl.getExtension('WEBGL_debug_renderer_info'); const vendor = gl.getParameter(debugInfo ? debugInfo.UNMASKED_VENDOR_WEBGL : gl.VENDOR); const renderer = gl.getParameter(debugInfo ? debugInfo.UNMASKED_RENDERER_WEBGL : gl.RENDERER); return { available: true, vendor: vendor || 'unknown', renderer: renderer || 'unknown' }; } catch (e) { console.warn("WebGL fingerprinting failed:", e); return { available: false, vendor: 'error', renderer: 'error', errorMsg: e.message }; } }
    function downloadJsonBackup(data, filename) { try { const jsonString = JSON.stringify(data, null, 2); const blob = new Blob([jsonString], { type: "application/json" }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); console.log("JSON backup download initiated:", filename); showImprovedNotification('info', 'Backup Saved', 'A JSON backup file of your submission has been downloaded.'); } catch (e) { console.error("Error creating or triggering JSON backup download:", e); showImprovedNotification('error', 'Backup Error', 'Could not create the backup file. Please manually copy your answers if needed.'); } }
    function setupBackupImportFeature() { /* Function body needed */ } function createBackupImportDialog() { /* Function body needed */ } function showBackupImportDialog() { /* Function body needed */ } function hideBackupImportDialog() { /* Function body needed */ } function handleBackupFileSelected() { /* Function body needed */ } function importBackupData() { /* Function body needed */ } function applyBackupToForm() { /* Function body needed */ }

    // === Google API & Auth ===
    // initGoogleApi, checkSavedTokenAndProceed, handleApiInitError, handleAuthClick,
    // handleTokenResponse, tokenObtained, fetchUserInfo, handleSignoutClick
    // -- Paste the definitions for these functions here from the previous version --
    function initGoogleApi() { console.log('Initialising Google Sign-In and GAPI client...'); try { tokenClient = google.accounts.oauth2.initTokenClient({ client_id: CLIENT_ID, scope: SCOPES, callback: handleTokenResponse }); gapi.load('client', async () => { console.log('GAPI client library loaded.'); checkSavedTokenAndProceed(); }); } catch (error) { handleApiInitError(error); } }
	async function checkSavedTokenAndProceed() { const savedToken = localStorage.getItem('gapi_token'); if (savedToken) { const token = JSON.parse(savedToken); if (token?.access_token) { try { gapi.client.setToken(token); console.log("Using saved token."); await tokenObtained(token); } catch (e) { console.warn("Error setting saved token even after gapi.load:", e); updateAuthUI(); showAppContent(); } } else { localStorage.removeItem('gapi_token'); console.log("Saved token invalid or expired."); updateAuthUI(); showAppContent(); } } else { console.log("No saved token found."); updateAuthUI(); showAppContent(); } }
    function handleApiInitError(error) { console.error('API Initialisation Error:', error); showImprovedNotification('error', 'API Load Error', `Failed to load Google services: ${error.message}`); updateAuthUI(); showAppContent(); }
    function isTokenExpired(token) { return false; } // Placeholder
    function handleAuthClick() { if (tokenClient) { showImprovedNotification('info', 'Signing In', 'Opening Google Sign-In...'); tokenClient.requestAccessToken({ prompt: 'select_account' }); } else { console.error('Token client not initialised.'); showImprovedNotification('error', 'Authentication Error', 'Authentication service is not ready. Please try again later.'); } }
    function handleTokenResponse(resp) { if (resp.error) { console.error('Token response error:', resp); let msg = `Authentication failed: ${resp.error}`; if (resp.error === 'popup_closed_by_user') msg = 'Sign-in cancelled by user.'; if (resp.error === 'access_denied') msg = 'Access denied. Please grant permission to proceed.'; showImprovedNotification('error', 'Authentication Error', msg); updateAuthUI(); showAppContent(); return; } console.log('Access token received.'); localStorage.setItem('gapi_token', JSON.stringify(resp)); if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined') { gapi.client.setToken(resp); tokenObtained(resp); } else { console.error("handleTokenResponse: gapi.client not ready when token received!"); showImprovedNotification('error', 'Authentication Problem', 'Could not process sign-in token properly. Please try signing out and signing back in, or reload the page.'); handleSignoutClick(); } }
    async function tokenObtained(token) { console.log("Token available, proceeding..."); isSignedIn = true; await fetchUserInfo(token); updateAuthUI(); showAppContent(); const loadedState = JSON.parse(localStorage.getItem(appStateKey) || '{}'); if (currentUser && loadedState.currentUserEmail === currentUser.email && loadedState.examEndTime && Date.now() < loadedState.examEndTime) { console.log("Attempting to restore active exam session."); restoreAppState(loadedState); } else if (loadedState.currentUserEmail) { console.log("Saved state is invalid or expired for the current user."); localStorage.removeItem(appStateKey); saveAppState(); } startTokenRefresh(); }
    async function fetchUserInfo(tokenObject) { const accessToken = tokenObject?.access_token; if (!accessToken) { console.warn("fetchUserInfo called without a valid access token in tokenObject."); showImprovedNotification('error', 'Auth Error', 'Missing access token. Signing out.'); handleSignoutClick(); return; } console.log('Fetching user information using provided token...'); try { const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', { headers: { 'Authorization': `Bearer ${accessToken}` } }); if (!response.ok) { if (response.status === 401) { console.warn("User Info fetch failed (401 - Unauthorized). Token might be invalid/expired. Signing out."); showImprovedNotification('error', 'Auth Expired', 'Your session has expired. Please sign in again.'); handleSignoutClick(); return; } throw new Error(`(${response.status}) ${await response.text()}`); } const userInfo = await response.json(); currentUser = { id: userInfo.sub, name: userInfo.name || 'N/A', email: userInfo.email || 'N/A', picture: userInfo.picture || '' }; console.log('User details fetched:', currentUser.email); isAdmin = ADMIN_EMAILS.includes(currentUser?.email); document.body.classList.toggle('is-admin', isAdmin); console.log(`User role: ${isAdmin ? 'ADMIN' : 'STUDENT'}`); if (studentNameInput) studentNameInput.value = currentUser.name; if (studentEmailInput) studentEmailInput.value = currentUser.email; if (userAvatar) userAvatar.src = currentUser.picture; if (userName) userName.textContent = currentUser.name; isAdmin = ADMIN_EMAILS.includes(currentUser.email); document.body.classList.toggle('is-admin', isAdmin); if (examPinInput) examPinInput.disabled = false; if (loadExamBtn) { loadExamBtn.disabled = examPinInput.value.trim() === '' || !isOnline; } } catch (e) { console.error('Fetch user info error:', e); showImprovedNotification('error', 'User Info Error', `Could not get user details: ${e.message}. Please try signing in again.`); currentUser = null; updateAuthUI(); } }
    function handleSignoutClick() { console.log("Signing out..."); const token = localStorage.getItem('gapi_token'); if (token) { const parsedToken = JSON.parse(token); if(parsedToken?.access_token && typeof google !== 'undefined' && google.accounts?.oauth2) { try { google.accounts.oauth2.revoke(parsedToken.access_token, () => console.log('Token revoked successfully.')); } catch (e) { console.warn("Error revoking token:", e); } } } if (typeof gapi !== 'undefined' && typeof gapi.client !== 'undefined') { try { gapi.client.setToken(''); } catch(e) { console.warn("Error clearing gapi token on signout", e);} } localStorage.removeItem('gapi_token'); localStorage.removeItem(appStateKey); isSignedIn = false; isAdmin = false; currentUser = null; examDetails = null; studentPINEntered = ''; studentExamIdEntered = ''; stopTimer(); resetExamState(); updateAuthUI(); showImprovedNotification('info', 'Signed Out', 'You have been signed out.'); stopTokenRefresh(); stopAutoSave(); if (inactivityTimer) { clearTimeout(inactivityTimer); inactivityTimer = null; } }


    // === UI State & Reset ===
    function resetExamState() { /* ... Paste definition from previous version ... */ console.log("Resetting UI to initial state."); examStartModule?.classList.add('hidden'); examDetailsModule?.classList.add('hidden'); examQuestionsArea?.parentElement.classList.add('hidden'); /* Hide form/area */ submissionConfirmationModule?.classList.add('hidden'); studentExamIdGroup?.classList.add('hidden'); signinPromptModule?.classList.remove('hidden'); if (examPinInput) { examPinInput.value = ''; examPinInput.disabled = true; } if (studentExamIdInput) studentExamIdInput.value = ''; if (studentNameInput) studentNameInput.value = ''; if (studentEmailInput) studentEmailInput.value = ''; if (loadExamBtn) { loadExamBtn.disabled = true; loadExamBtn.classList.remove('hidden'); loadExamBtn.innerHTML = '<i class="fas fa-download"></i> Load Exam'; } if (startExamBtn) startExamBtn.disabled = true; if (startExamBtnAlt) { startExamBtnAlt.classList.add('hidden'); startExamBtnAlt.disabled = true; } if (submitExamBtn) { submitExamBtn.disabled = true; submitExamBtn.innerHTML = '<i class="fas fa-lock"></i> Submit Exam (Confirm All First)'; } const na = 'N/A'; if (examCodeDisplay) examCodeDisplay.textContent = na; if (examDurationDisplay) examDurationDisplay.textContent = na; if (examStartTimeDisplay) examStartTimeDisplay.textContent = na; if (examNameHeader) examNameHeader.textContent = 'Please sign in to load the exam'; if (examNameDetail) examNameDetail.textContent = ''; if (examCourseCodeDetail) examCourseCodeDetail.textContent = ''; if (examModeDetail) examModeDetail.textContent = ''; if (examDurationDetail) examDurationDetail.textContent = ''; if (examStartTimeDetail) examStartTimeDetail.textContent = ''; if (examQuestionsArea) examQuestionsArea.innerHTML = '<p>Exam questions will appear here...</p>'; stopTimer(); const stickyTimer = document.querySelector('.sticky-timer'); if(stickyTimer) stickyTimer.remove(); totalQuestions = 0; confirmedQuestionsCount = 0; document.body.classList.remove('time-warning', 'time-danger', 'time-expired'); }
    function updateAuthUI() { /* ... Paste definition from previous version ... */ console.log('Updating Auth UI - SignedIn:', isSignedIn, 'CurrentUser:', !!currentUser); document.body.classList.toggle('is-admin', isAdmin); if (isSignedIn && currentUser) { console.log('Showing logged-in UI.'); loginContainer.style.display = 'none'; userContainer.style.display = 'flex'; signinPromptModule.classList.add('hidden'); if (examStartModule && !examDetails && examQuestionsArea?.parentElement.classList.contains('hidden') /* check form */) { examStartModule.classList.remove('hidden'); } if (examPinInput) examPinInput.disabled = false; if (loadExamBtn) { loadExamBtn.disabled = examPinInput.value.trim() === '' || !isOnline; } if (studentNameInput) studentNameInput.value = currentUser.name || 'N/A'; if (studentEmailInput) studentEmailInput.value = currentUser.email || 'N/A'; if (userName) userName.textContent = currentUser.name || ''; if (userAvatar) userAvatar.src = currentUser.picture || ''; } else { console.log('Showing logged-out UI.'); loginContainer.style.display = 'flex'; userContainer.style.display = 'none'; resetExamState(); signinPromptModule.classList.remove('hidden'); } }

    // === Exam Logic ===
    async function handleLoadExam() { /* ... Paste definition from previous version ... */ studentPINEntered = examPinInput.value.trim(); if (!studentPINEntered) { showImprovedNotification('warning', 'Missing PIN', 'Please enter the Exam PIN.'); return; } loadExamBtn.disabled = true; loadExamBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...'; await fetchExamDetails(studentPINEntered); loadExamBtn.disabled = false; loadExamBtn.innerHTML = '<i class="fas fa-download"></i> Load Exam'; if (startExamBtn) startExamBtn.disabled = !examDetails || !isOnline; if (startExamBtnAlt) startExamBtnAlt.disabled = !examDetails || !isOnline; }
    async function fetchExamDetails(pin) { /* ... Paste definition from previous version ... */ showImprovedNotification('info', 'Fetching Exam', `Loading details for PIN: ${pin}...`); setSyncing(true); examDetails = null; examEndTime = null; try { const fetchUrl = `${BACKEND_URL}?pin=${encodeURIComponent(pin)}&action=getDetails`; console.log(`Workspaceing exam details from backend: ${fetchUrl}`); const response = await fetch(fetchUrl); if (!response.ok) { throw new Error(`HTTP error! Status: ${response.status}`); } const result = await response.json(); console.log("Backend response (Exam Details):", result); if (result.success && result.examData) { const fetchedData = result.examData; const shuffleQuestions = String(fetchedData.ShuffleQuestions || 'yes').trim().toLowerCase(); const duration = parseInt(fetchedData.Duration, 10); const startTimestampUTC = fetchedData.StartTimestampUTC; const mode = String(fetchedData.Mode || 'Quiz').trim().toLowerCase(); const questionsJson = String(fetchedData.Questions || '[]').trim(); const startDateStr = String(fetchedData.StartDate || '').trim(); const startTimeStr = String(fetchedData.StartTime || '').trim(); if (isNaN(duration) || duration <= 0) throw new Error("Invalid exam duration received from backend."); if (typeof startTimestampUTC !== 'number' || isNaN(startTimestampUTC)) { throw new Error("Invalid StartTimestampUTC received from backend."); } try { JSON.parse(questionsJson); } catch (e) { throw new Error(`Invalid questions JSON received: ${e.message}`); } try { const startTimeFromSheet = startTimestampUTC; const durationMillis = duration * 60 * 1000; examEndTime = startTimeFromSheet + durationMillis; console.log(`[TIMER CALC] StartDate: ${startDateStr}, StartTime: ${startTimeStr}, Received Start TS (UTC ms): ${startTimeFromSheet}, Duration(ms): ${durationMillis}, Calculated End TS (UTC ms): ${examEndTime} (${new Date(examEndTime).toLocaleString()})`); } catch (e) { throw new Error(`Could not calculate exam end time: ${e.message}`); } examDetails = { PIN: fetchedData.PIN, Code: fetchedData.Code, Name: fetchedData.Name, Duration: duration, StartDate: startDateStr, StartTime: startTimeStr, Mode: mode, Questions: questionsJson, OriginalOrderMap: null, StartTimestampUTC: startTimestampUTC, shuffleQuestions: shuffleQuestions }; console.log("Exam details processed successfully:", examDetails); displayExamDetailsHeader(); showImprovedNotification('success', 'Exam Loaded', `Details for "${examDetails.Name}" loaded successfully.`); if (examDetails.Mode === 'exam') { console.log("Exam Mode detected: Showing Student Exam ID input."); examStartModule.classList.remove('hidden'); studentExamIdGroup.classList.remove('hidden'); studentExamIdInput.value = ''; examDetailsModule.classList.add('hidden'); startExamBtnAlt.classList.remove('hidden'); startExamBtn.classList.add('hidden'); startExamBtn.disabled = true; loadExamBtn.classList.add('hidden'); validateStudentExamIdInput(); } else { console.log("Quiz Mode detected: Showing Exam Information module."); studentExamIdGroup.classList.add('hidden'); studentExamIdInput.value = ''; studentExamIdEntered = ''; examStartModule.classList.add('hidden'); displayExamDetailsFull(); examDetailsModule.classList.remove('hidden'); startExamBtnAlt.classList.add('hidden'); startExamBtn.classList.remove('hidden'); startExamBtn.disabled = !isOnline; loadExamBtn.disabled = true; loadExamBtn.classList.remove('hidden'); } saveAppState(); } else { throw new Error(result.message || "Exam details not found or backend error."); } } catch (error) { console.error(`Error fetching/processing exam details for PIN ${pin}:`, error); showImprovedNotification('error', 'Exam Load Failed', `Could not load exam: ${error.message}`); examDetails = null; examDetailsModule.classList.add('hidden'); examStartModule.classList.remove('hidden'); if (loadExamBtn) loadExamBtn.disabled = !isOnline; resetExamState(); } finally { setSyncing(false); } }
    function validateStudentExamIdInput() { /* ... Paste definition from previous version ... */ const startButtonToUse = startExamBtnAlt; if (!startButtonToUse || !studentExamIdInput || !examDetails || examDetails.Mode !== 'exam') return; const idValue = studentExamIdInput.value.trim(); const isValid = idValue.length === 5; startButtonToUse.disabled = !isValid || !isOnline; studentExamIdInput.style.borderColor = (isValid || idValue === '') ? '#ccc' : 'red'; }
    function displayExamDetailsHeader() { /* ... Paste definition from previous version ... */ if (!examDetails) return; if (examCodeDisplay) examCodeDisplay.textContent = examDetails.Code || 'N/A'; if (examDurationDisplay) examDurationDisplay.textContent = `${examDetails.Duration} minutes`; const startTimeString = `${examDetails.StartDate || ''} ${examDetails.StartTime || ''}`.trim(); if (examStartTimeDisplay) examStartTimeDisplay.textContent = startTimeString || 'N/A'; if (examNameHeader) examNameHeader.textContent = examDetails.Name || 'Exam Loaded'; }
    function displayExamDetailsFull() { /* ... Paste definition from previous version ... */ if (!examDetails) return; if (examNameDetail) examNameDetail.textContent = examDetails.Name || 'N/A'; if (examCourseCodeDetail) examCourseCodeDetail.textContent = examDetails.Code || 'N/A'; const displayMode = examDetails.Mode ? (examDetails.Mode.charAt(0).toUpperCase() + examDetails.Mode.slice(1)) : 'N/A'; if (examModeDetail) examModeDetail.textContent = displayMode; if (examDurationDetail) examDurationDetail.textContent = `${examDetails.Duration} minutes`; const startTimeString = `${examDetails.StartDate || ''} ${examDetails.StartTime || ''}`.trim(); if (examStartTimeDetail) examStartTimeDetail.textContent = startTimeString || 'N/A'; }
    async function checkIfAttemptExists(email, pin, studentExamId, mode) { /* ... Paste definition from previous version ... */ console.log("Checking backend for existing 'submit' record..."); setSyncing(true); try { const params = new URLSearchParams({ action: 'checkExists', pin: pin, mode: mode }); if (mode === 'quiz') { params.append('email', email); } else if (mode === 'exam') { params.append('studentExamId', studentExamId); } const fetchUrl = `${BACKEND_URL}?${params.toString()}`; console.log(`Checking existence via backend: ${fetchUrl}`); const response = await fetch(fetchUrl, { method: 'GET', headers: { 'Accept': 'application/json' } }); if (!response.ok) { let errorMsg = `Backend check error! Status: ${response.status}`; try { const errorData = await response.json(); errorMsg = errorData.message || errorMsg; } catch (e) {} throw new Error(errorMsg); } const result = await response.json(); console.log("Backend check response:", result); if (result.success) { return result.exists; } else { throw new Error(result.message || "Backend error during existence check."); } } catch (error) { console.error('Error checking submission existence via backend:', error); showImprovedNotification('error', 'Check Failed', `Could not verify previous submissions: ${error.message}. Assuming none exist.`); return false; } finally { setSyncing(false); } }
    async function handleStartExam() { /* ... Paste definition from previous version ... */ if (!examDetails || !currentUser) { showImprovedNotification('error', 'Start Error', 'Cannot start the exam. User or exam details are missing.'); return; } const currentMode = examDetails.Mode.toLowerCase(); let identifierForCheck = null; if (currentMode === 'exam') { const currentStudentExamId = studentExamIdInput.value.trim(); if (currentStudentExamId.length !== 5) { showImprovedNotification('error', 'Invalid ID', 'Please enter the 5-character Student Exam ID.'); studentExamIdInput.focus(); return; } studentExamIdEntered = currentStudentExamId; identifierForCheck = studentExamIdEntered; console.log(`Exam Mode: Using StudentExamID '${identifierForCheck}' for existence check.`); } else { studentExamIdEntered = ''; identifierForCheck = currentUser.email; console.log(`Quiz Mode: Using Email '${identifierForCheck}' for existence check.`); } console.log("Performing pre-start checks..."); const alreadySubmitted = await checkIfAttemptExists( currentUser.email, examDetails.PIN, identifierForCheck, currentMode ); if (alreadySubmitted) { showImprovedNotification('error', 'Already Submitted', `This exam (${examDetails.PIN}) has already been submitted and cannot be retaken.`, 0); if (startExamBtn) startExamBtn.disabled = true; if (startExamBtnAlt) startExamBtnAlt.disabled = true; return; } try { const startTimestampUTC = examDetails.StartTimestampUTC; if (!startTimestampUTC || isNaN(startTimestampUTC)) { throw new Error("Start timestamp missing or invalid.");} const startTime = startTimestampUTC; if (Date.now() < startTime) { showImprovedNotification('error', 'Exam Not Yet Available', `This exam is scheduled to start at ${new Date(startTime).toLocaleString()}. Please wait.`); return; } if (!examEndTime || isNaN(examEndTime)) { throw new Error("Could not determine the exam end time."); } if (Date.now() >= examEndTime) { showImprovedNotification('error', 'Exam Deadline Passed', `The deadline (${new Date(examEndTime).toLocaleString()}) for starting or resuming this exam has passed.`, 0); return; } } catch (e) { console.error("Exam timing check error:", e); showImprovedNotification('warning', 'Timing Check Warning', `Could not fully verify exam timing: ${e.message}. Proceeding cautiously.`); } console.log(`Starting ${currentMode} mode. PIN: ${examDetails.PIN}` + (currentMode === 'exam' ? `, Student Exam ID: ${studentExamIdEntered}` : '')); confirmedQuestionsCount = 0; examStartModule.classList.add('hidden'); examDetailsModule.classList.add('hidden'); examQuestionsArea.parentElement.classList.remove('hidden'); /* Show form */ submissionConfirmationModule.classList.add('hidden'); displayQuestions(examDetails.Questions); startTimer(); saveAppState(); checkAllConfirmed(); stopAutoSave(); startAutoSave(); }

    // --- MODIFIED: displayQuestions to use module structure ---
    function displayQuestions(questionsJsonString) {
        return new Promise((resolve, reject) => {
            console.log("Parsing and displaying exam questions as modules...");
            examQuestionsArea.innerHTML = ''; // Clear previous questions
            totalQuestions = 0;
            confirmedQuestionsCount = 0;
            codeEditors = {};

            try {
                let questionsArray = [];
                try {
                    questionsArray = JSON.parse(questionsJsonString);
                    if (!Array.isArray(questionsArray)) throw new Error("Parsed data is not an array.");
                } catch (parseError) {
                    console.warn("Could not parse questions JSON.", parseError);
                    questionsArray = [{ type: "long_answer", prompt: "Exam Instructions / Questions", content: questionsJsonString }];
                }

                totalQuestions = questionsArray.length;
                console.log(`Total questions loaded: ${totalQuestions}`);

                // Shuffling logic
                const shuffleSetting = String(examDetails.shuffleQuestions).trim().toLowerCase();
                const shuffleDisabled = ['no', 'false', '0'].includes(shuffleSetting);
                const skipShuffle = Boolean(isAdmin) || shuffleDisabled;
                console.log(`Shuffling: ${!skipShuffle}`);
                const seed = hashString(currentUser?.email || Date.now().toString());
                const originalIndices = Array.from(questionsArray.keys());
                const displayIndices = skipShuffle ? originalIndices : seededShuffle(originalIndices.slice(), seed);
                console.log("Display order:", displayIndices);

                examDetails.OriginalOrderMap = {};
                questionsArray.forEach((q, index) => { examDetails.OriginalOrderMap[index] = q; });

                let codeEditorInitPromises = [];

                displayIndices.forEach((originalIndex, displayIndex) => {
                    const q = questionsArray[originalIndex];
                    const displayQNum = displayIndex + 1;
                    const originalQNum = originalIndex + 1;
                    const questionId = `q-${originalQNum}`; // ID for the outer module div
                    const answerId = `ans-${originalQNum}`;
                    const answerName = `ans-${originalQNum}`;

                    // --- Create Module Structure ---
                    const questionModuleDiv = document.createElement('div');
                    questionModuleDiv.className = 'module question-module'; // Add specific class
                    if (q.type === 'text_only') {
                        questionModuleDiv.classList.add('text-only-question');
                    }
                    questionModuleDiv.id = questionId;
                    questionModuleDiv.dataset.originalIndex = originalIndex;
                    questionModuleDiv.dataset.displayIndex = displayIndex;

                    // --- Create Header ---
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'module-header question-header';

                    let pointsBadgeHtml = '';
                    if (q.points && q.type !== 'text_only') {
                        pointsBadgeHtml = ` <span class="points-badge">${q.points} ${q.points == 1 ? 'pt' : 'pts'}</span>`;
                    }
                    const titleSpan = document.createElement('span');
                    titleSpan.className = 'module-title question-title';
                    // Display original number for admin, display number otherwise
                    const questionNumberLabel = isAdmin ? `Q${originalQNum} (Display #${displayQNum})` : `Question ${displayQNum}`;
                    titleSpan.innerHTML = `<strong>${questionNumberLabel}${pointsBadgeHtml}:</strong>`;
                    headerDiv.appendChild(titleSpan);
                    // Add header to module
                    questionModuleDiv.appendChild(headerDiv);

                    // --- Create Content Area ---
                    const contentAreaDiv = document.createElement('div');
                    contentAreaDiv.className = 'module-content question-content-area'; // Specific class

                    // Add Prompt Display Area
                    const promptDiv = document.createElement('div');
                    promptDiv.className = 'question-prompt-display';
                    let promptText = q.prompt || '';
                    promptText = escapeHtml(promptText);
                    // Apply formatting (bold, italics, terms)
                    promptText = promptText.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>'); // Bold italic
                    promptText = promptText.replace(/(?<!\*)\*\*(?!\*)(.*?)\*\*(?!\*)/g, '<strong>$1</strong>'); // Bold
                    promptText = promptText.replace(/(?<![*\\])\*(?![*\\])(.*?)\*(?![*\\])/g, '<em>$1</em>');       // Italic
                    const termsToEmphasise = ['sep', 'end', 'print()', 'input()', 'range\\(5\\)', 'range\\(2, 8, 2\\)', 'TypeError', 'IDE'];
                     termsToEmphasise.forEach(term => { /* ... term highlighting ... */ const termForRegex = (term.includes('\\(')) ? term : term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); const regex = new RegExp(`(?<![=\\"'>])(\\b${termForRegex}\\b)(?![<\\(\\"'])`, 'g'); promptText = promptText.replace(regex, (match) => `<em class="term">${match}</em>`); });
                    promptText = promptText.replace(/print'Hello World'/g, () => '<em class="term">print\'Hello World\'</em>'); promptText = promptText.replace(/x = 5 \+ '3'/g, () => '<em class="term">x = 5 + \'3\'</em>'); promptText = promptText.replace(/print\("Value:", value, sep = ':'\)/g, () => '<em class="term">print("Value:", value, sep = \':\')</em>'); promptText = promptText.replace(/print\(My variable is, x\)/g, () => '<em class="term">print(My variable is, x)</em>'); promptText = promptText.replace(/"My variable is"/g, () => '<em class="term">"My variable is"</em>');
                    promptDiv.innerHTML = promptText.replace(/\n/g, '<br>');
                    contentAreaDiv.appendChild(promptDiv);

                    // Add Answer Input Area
                    const answerAreaDiv = document.createElement('div');
                    answerAreaDiv.className = 'question-answer-area form-group'; // Add form-group for spacing if needed
                    let inputHtml = '';
                    switch (q.type) {
                        case 'text_only': break; // No input needed
                        case 'short_answer': inputHtml = `<input type="text" id="${answerId}" name="${answerName}" class="form-control" placeholder="Enter your answer">`; break;
                        case 'long_answer': inputHtml = `<textarea id="${answerId}" name="${answerName}" class="form-control" rows="5" placeholder="Enter your detailed answer">${escapeHtml(q.content || '')}</textarea>`; break;
                        case 'code':
                            inputHtml = `<textarea id="${answerId}" name="${answerName}" class="form-control code-editor" rows="8" placeholder="Enter your code">${escapeHtml(q.content || '')}</textarea>`;
                            codeEditorInitPromises.push(new Promise(resolveEditor => { setTimeout(() => { initializeCodeEditor(answerId, q.language || 'python'); resolveEditor(); }, 100); })); // Shorter delay ok?
                            break;
                        case 'attachment': inputHtml = `<input type="file" id="${answerId}" name="${answerName}" class="form-control"><span class="file-helper-text">Max size: ... Allowed types: ...</span>`; break; // Add constraints later
                        case 'multiple_select':
                            inputHtml += `<div class="checkbox-group" id="${answerId}">`;
                            if (Array.isArray(q.options) && q.options.length > 0) {
                                const optionIndices = [...Array(q.options.length).keys()];
                                const shuffledOptionIndices = skipShuffle ? optionIndices : seededShuffle(optionIndices.slice(), seed + originalIndex); // Use slice()
                                q.shuffledOptionIndices = shuffledOptionIndices; // Store for potential grading reference
                                shuffledOptionIndices.forEach((originalOptIndex) => {
                                    const option = q.options[originalOptIndex];
                                    const optionId = `${answerId}-opt${originalOptIndex}`;
                                    const escapedOption = escapeHtml(option);
                                    inputHtml += `<div class="checkbox-item"><input type="radio" id="${optionId}" name="${answerName}" value="${escapedOption}" class="form-control-checkbox" data-original-index="${originalOptIndex}"><label for="${optionId}">${escapedOption}</label></div>`;
                                });
                            } else { inputHtml += `<p style="color:red;">Error: Options missing.</p>`; }
                            inputHtml += `</div>`;
                            break;
                        default: inputHtml = `<p>${escapeHtml(q.content || '')}</p>`; break;
                    }
                    answerAreaDiv.innerHTML = inputHtml;
                    contentAreaDiv.appendChild(answerAreaDiv);

                    // Add Actions Area (Confirm/Edit Buttons)
                    if (q.type !== 'text_only') {
                        const actionsDiv = document.createElement('div');
                        actionsDiv.className = 'question-actions';
                        actionsDiv.innerHTML = `
                            <button type="button" class="btn-sm btn-success btn-confirm" onclick="confirmAnswer('${questionId}')">
                                <i class="fas fa-check"></i> Confirm
                            </button>
                            <button type="button" class="btn-sm btn-info btn-edit" onclick="editAnswer('${questionId}')">
                                <i class="fas fa-pencil-alt"></i> Edit
                            </button>
                        `;
                        contentAreaDiv.appendChild(actionsDiv);
                    }

                    // Add content area to module
                    questionModuleDiv.appendChild(contentAreaDiv);

                    // Append the whole module to the main questions area
                    examQuestionsArea.appendChild(questionModuleDiv);

                    // Auto-confirm text_only (no visual change needed, just count)
                    if (q.type === 'text_only') {
                        confirmedQuestionsCount++;
                        questionModuleDiv.classList.add('confirmed', 'text-only-confirmed'); // Mark it internally
                    }
                }); // End displayIndices.forEach

                // Wait for CodeMirror initializations
                Promise.all(codeEditorInitPromises).then(() => {
                    console.log("CodeMirror editors initialized.");
                    // enhancePointsDisplay(); // Call this if needed
                    checkAllConfirmed(); // Update submit button state
                    resolve(); // Resolve outer promise
                }).catch(reject);

            } catch (e) {
                console.error("Error displaying questions:", e);
                examQuestionsArea.innerHTML = '<p>Error loading questions.</p>';
                reject(e);
            }
        });
    }

    // --- MODIFIED: confirmAnswer to add .confirmed class and collapse ---
    function confirmAnswer(questionId) {
        const questionModuleDiv = document.getElementById(questionId);
        if (!questionModuleDiv || questionModuleDiv.classList.contains('confirmed')) return;

        // Add confirmed class (triggers collapse via CSS)
        questionModuleDiv.classList.add('confirmed');
        if (!questionModuleDiv.classList.contains('text-only-question')) { // Don't double-count
             confirmedQuestionsCount++;
        }


        // Disable inputs within this question's content area
        const contentArea = questionModuleDiv.querySelector('.question-content-area');
        if(contentArea){
            const inputs = contentArea.querySelectorAll('.form-control, .form-control-checkbox');
            inputs.forEach(input => { input.disabled = true; });

            // Handle CodeMirror editor if present
            const cmTextarea = contentArea.querySelector('.code-editor');
            if (cmTextarea && cmTextarea.id && codeEditors[cmTextarea.id]) {
                codeEditors[cmTextarea.id].setOption('readOnly', true);
                const cmElement = codeEditors[cmTextarea.id].getWrapperElement();
                if (cmElement) {
                    cmElement.classList.add('cm-confirmed');
                }
            }
        }

        console.log(`Confirmed answer for question: ${questionId}`);
        checkAllConfirmed(); // Update submit button state
    }

    // --- MODIFIED: editAnswer to remove .confirmed class and expand ---
    function editAnswer(questionId) {
        const questionModuleDiv = document.getElementById(questionId);
        if (!questionModuleDiv || !questionModuleDiv.classList.contains('confirmed')) return;

        // Remove confirmed class (triggers expansion via CSS)
        questionModuleDiv.classList.remove('confirmed');
         if (!questionModuleDiv.classList.contains('text-only-question')) { // Only decrement if it was a counted one
             confirmedQuestionsCount--;
         }


        // Re-enable inputs within this question's content area
         const contentArea = questionModuleDiv.querySelector('.question-content-area');
         if(contentArea){
            const inputs = contentArea.querySelectorAll('.form-control, .form-control-checkbox');
            inputs.forEach(input => { input.disabled = false; });

            // Handle CodeMirror editor if present
            const cmTextarea = contentArea.querySelector('.code-editor');
            if (cmTextarea && cmTextarea.id && codeEditors[cmTextarea.id]) {
                codeEditors[cmTextarea.id].setOption('readOnly', false);
                const cmElement = codeEditors[cmTextarea.id].getWrapperElement();
                if (cmElement) {
                    cmElement.classList.remove('cm-confirmed');
                }
            }
        }

        console.log(`Enabled editing for question: ${questionId}`);
        checkAllConfirmed(); // Update submit button state
    }

    // --- Timer Functions (startTimer, updateTimerDisplay, updateTimeVisualCues, stopTimer, createStickyTimer) ---
    // --- Paste definitions from previous version ---
    function startTimer() { if (examTimerInterval) { console.warn("Timer is already running."); return; } if (!examEndTime || isNaN(examEndTime) || examEndTime <= Date.now()) { console.error("Cannot start timer: Invalid or past exam end time.", examEndTime); const stickyDisplay = document.getElementById('sticky-timer-display'); if(stickyDisplay) stickyDisplay.textContent = "Error"; if (examEndTime && examEndTime <= Date.now()) { showImprovedNotification('error', 'Deadline Passed', 'The time for this exam has already expired.', 0); handleSubmitExam(true); } return; } createStickyTimer(); console.log(`Timer starting. Target end time: ${new Date(examEndTime).toLocaleString()}`); updateTimerDisplay(); examTimerInterval = setInterval(updateTimerDisplay, 1000); }
    function updateTimerDisplay() { if (!examEndTime) { console.warn("Timer update called without a valid end time."); stopTimer(); const stickyDisplay = document.getElementById('sticky-timer-display'); if (stickyDisplay) stickyDisplay.textContent = "--:--"; return; } const now = Date.now(); const timeLeft = Math.max(0, examEndTime - now); const minutesLeft = Math.floor(timeLeft / (1000 * 60)); const seconds = Math.floor((timeLeft / 1000) % 60); const timeString = `${String(minutesLeft).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; const stickyDisplay = document.getElementById('sticky-timer-display'); if (stickyDisplay) stickyDisplay.textContent = timeString; updateTimeVisualCues(minutesLeft, seconds, timeLeft); if (timeLeft <= 0) { console.log("Exam time has expired!"); stopTimer(); showImprovedNotification('warning', "Time's Up!", 'The exam time has expired. Submitting automatically.', 0); handleSubmitExam(true); } }
    function updateTimeVisualCues(minutesLeft, seconds, timeLeft) { const stickyTimer = document.querySelector('.sticky-timer'); const timerIcon = stickyTimer ? stickyTimer.querySelector('i') : null; if (!stickyTimer || !timerIcon) return; if (timeLeft <= 0) { document.body.classList.remove('time-warning', 'time-danger'); document.body.classList.add('time-expired'); stickyTimer.classList.remove('warning', 'danger'); stickyTimer.classList.add('expired'); timerIcon.className = 'fas fa-hourglass-end'; } else if (minutesLeft <= 5) { document.body.classList.remove('time-warning'); document.body.classList.add('time-danger'); stickyTimer.classList.remove('warning'); stickyTimer.classList.add('danger'); timerIcon.className = 'fas fa-exclamation-triangle'; } else if (minutesLeft <= 10) { document.body.classList.add('time-warning'); document.body.classList.remove('time-danger'); stickyTimer.classList.add('warning'); stickyTimer.classList.remove('danger'); timerIcon.className = 'fas fa-stopwatch'; } else { document.body.classList.remove('time-warning', 'time-danger'); stickyTimer.classList.remove('warning', 'danger'); timerIcon.className = 'fas fa-stopwatch'; } }
    function stopTimer() { if (examTimerInterval) { clearInterval(examTimerInterval); examTimerInterval = null; console.log("Timer stopped."); } }
    function createStickyTimer() { const existingTimer = document.querySelector('.sticky-timer'); if (existingTimer) existingTimer.remove(); const stickyTimer = document.createElement('div'); stickyTimer.className = 'sticky-timer'; stickyTimer.innerHTML = `<i class="fas fa-stopwatch"></i> <span id="sticky-timer-display">--:--</span>`; document.body.appendChild(stickyTimer); return stickyTimer; }


    // --- Submission Functions (handleSubmitExam, sendSubmissionToBackend) ---
    // --- Paste definitions from previous version ---
    async function handleSubmitExam(isAutoSubmit = false) { const timeIsUp = examEndTime && Date.now() >= examEndTime; if (timeIsUp && !isAutoSubmit) { console.warn("Manual submit clicked after deadline. Treating as auto-submit."); showImprovedNotification('warning', 'Deadline Passed', 'Time expired. Submitting automatically.'); isAutoSubmit = true; } stopTimer(); submitExamBtn.disabled = true; submitExamBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...'; if (!isAutoSubmit) { if (confirmedQuestionsCount !== totalQuestions) { showImprovedNotification('error', 'Not All Confirmed', `Please confirm all ${totalQuestions} questions before submitting. You have confirmed ${confirmedQuestionsCount}.`, 5000); checkAllConfirmed(); return; } if (!confirm("You have confirmed all answers. Are you absolutely sure you want to submit your exam?\nThis action cannot be undone.")) { checkAllConfirmed(); if (examEndTime && Date.now() < examEndTime) { startTimer(); } return; } } console.log("Processing submission..." + (isAutoSubmit ? " (Auto)" : " (Manual - All Confirmed)")); const answers = {}; const fingerprintObject = getFingerprintData(); if (!examDetails || !examDetails.OriginalOrderMap || totalQuestions <= 0) { showImprovedNotification('error', 'Submission Error', 'Cannot collect answers. Exam data or question count is invalid.', 0); checkAllConfirmed(); return; } const originalIndices = Object.keys(examDetails.OriginalOrderMap).map(Number).sort((a, b) => a - b); originalIndices.forEach(originalIndex => { const originalQNum = originalIndex + 1; const questionData = examDetails.OriginalOrderMap[originalIndex]; const answerName = `ans-${originalQNum}`; const questionDivId = `q-${originalQNum}`; const questionDiv = document.getElementById(questionId); if (questionData.type === 'text_only') { answers[answerName] = "[TEXT_ONLY_NO_ANSWER_REQUIRED]"; return; } const isConfirmed = questionDiv ? questionDiv.classList.contains('confirmed') : false; if (isAutoSubmit && !isConfirmed) { answers[answerName] = "[NOT CONFIRMED]"; console.log(`Auto-submit: Answer for ${answerName} was not confirmed.`); } else { const formElementsWithName = examForm.elements[answerName]; if (formElementsWithName) { switch (questionData.type) { case 'attachment': const fileInput = formElementsWithName; answers[answerName] = (fileInput.files && fileInput.files.length > 0) ? `FILE_UPLOADED:${fileInput.files[0].name}` : ''; console.log(`Collected answer for ${answerName} (attachment):`, answers[answerName]); break; case 'multiple_select': const radioGroup = formElementsWithName; let selectedValue = null; if (radioGroup && typeof radioGroup.value !== 'undefined') { if (radioGroup.value !== "") { selectedValue = radioGroup.value; if (!isAdmin && questionData.shuffledOptionIndices) { const selectedOptionEl = document.querySelector(`input[name="${answerName}"]:checked`); if (selectedOptionEl && selectedOptionEl.dataset.originalIndex) { answers[`${answerName}_metadata`] = { originalIndex: selectedOptionEl.dataset.originalIndex }; } } } } else { console.warn(`Could not find radio button group or its value property for name: "${answerName}"`); } answers[answerName] = selectedValue; console.log(`Collected answer for ${answerName} (radio):`, selectedValue); break; default: if (questionData.type === 'code' && codeEditors[answerName]) { answers[answerName] = codeEditors[answerName].getValue(); console.log(`Collected answer for ${answerName} (code editor): "${answers[answerName].substring(0,50)}..."`); } else if (typeof formElementsWithName.value !== 'undefined') { answers[answerName] = formElementsWithName.value; console.log(`Collected answer for ${answerName} (default): "${answers[answerName].substring(0,50)}..."`); } else { console.warn(`Element "${answerName}" found but has no 'value' property.`); answers[answerName] = 'ERROR_NO_VALUE_PROP'; } break; } } else { console.warn(`Could not find form element for answer name: "${answerName}"`); answers[answerName] = 'ERROR_ELEMENT_NOT_FOUND'; } } }); const backupData = { submissionTimestamp: new Date().toISOString(), examDetails: { PIN: examDetails?.PIN, Name: examDetails?.Name, Mode: examDetails?.Mode, Code: examDetails?.Code }, studentInfo: { pinEntered: studentPINEntered, studentExamId: examDetails?.Mode === 'exam' ? studentExamIdEntered : undefined, name: currentUser?.name, email: currentUser?.email }, answers: answers, fingerprint: fingerprintObject, submittedLate: timeIsUp, autoSubmitted: isAutoSubmit, confirmedCountOnSubmit: confirmedQuestionsCount, totalQuestionsOnSubmit: totalQuestions }; const backupFilename = `exam_backup_${examDetails?.PIN || 'unknown'}_${(currentUser?.email || studentExamIdEntered || 'anon').replace(/@.*/, '')}_${Date.now()}.json`; downloadJsonBackup(backupData, backupFilename); const submissionData = { timestamp: backupData.submissionTimestamp, pin: examDetails?.PIN, courseCode: examDetails?.Code, mode: examDetails?.Mode, studentEmail: (examDetails?.Mode === 'quiz' ? currentUser?.email : undefined), studentName: (examDetails?.Mode === 'quiz' ? currentUser?.name : undefined), studentExamId: (examDetails?.Mode === 'exam' ? studentExamIdEntered : undefined), answers: answers, fingerprint: fingerprintObject, isAutoSubmit: isAutoSubmit, timeIsUp: timeIsUp }; let submissionSuccess = await sendSubmissionToBackend(submissionData); if (submissionSuccess) { showImprovedNotification('success', 'Exam Submitted Successfully!', `Your submission has been sent.`, 0); examQuestionsArea.parentElement.classList.add('hidden'); submissionConfirmationModule.classList.remove('hidden'); localStorage.removeItem(appStateKey); examDetails = null; studentPINEntered = ''; studentExamIdEntered = ''; examEndTime = null; totalQuestions = 0; confirmedQuestionsCount = 0; } else { console.error("Online submission failed after backup."); if (!isAutoSubmit) { checkAllConfirmed(); } else { showImprovedNotification('error', 'Auto-Submit Failed', 'Could not automatically send submission online. Backup downloaded.', 0); } } }
    async function sendSubmissionToBackend(submissionData) { try { console.log(`Sending data to backend: ${BACKEND_URL}`); const response = await fetch(BACKEND_URL, { method: 'POST', mode: 'no-cors', headers: { 'Content-Type': 'text/plain;charset=utf-8', }, body: JSON.stringify({ submission: submissionData }) }); console.log("Fetch request sent to backend (response status hidden due to no-cors)."); return true; } catch (error) { console.error('Error submitting data to backend:', error); showImprovedNotification('error', 'Submission Error', `Could not send submission: ${error.message}. A backup file was downloaded.`, 0); return false; } }


    // --- State Persistence (loadAppState, saveAppState, restoreAppState) ---
    // --- Paste definitions from previous version ---
     function saveAppState() { if (!examDetails || (examQuestionsArea?.parentElement.classList.contains('hidden') && !submissionConfirmationModule.classList.contains('hidden'))) { if (examQuestionsArea?.parentElement.classList.contains('hidden') && submissionConfirmationModule.classList.contains('hidden')) { /* Save setup state */ } else { console.log("Not saving state: Exam not active or already submitted."); return; } } try { const state = { isSignedIn: isSignedIn, currentUserEmail: currentUser?.email, examDetails: examDetails, studentPINEntered: studentPINEntered, studentExamIdEntered: studentExamIdEntered, examEndTime: examEndTime, currentAnswers: /* collect answers if needed */ {}, confirmationStatus: /* collect status if needed */ {} }; localStorage.setItem(appStateKey, JSON.stringify(state)); console.log("Application state saved to localStorage."); } catch (e) { console.error("Error saving application state to localStorage:", e); } }
     function loadAppState() { const savedStateString = localStorage.getItem(appStateKey); if (!savedStateString) { console.log("No saved application state found in localStorage."); return; } try { const state = JSON.parse(savedStateString); console.log("Found saved application state:", state); } catch (e) { console.error("Error parsing saved application state from localStorage:", e); localStorage.removeItem(appStateKey); } }
     async function restoreAppState(state) { console.log("Restoring application state..."); examDetails = state.examDetails; studentPINEntered = state.studentPINEntered; studentExamIdEntered = state.studentExamIdEntered; examEndTime = state.examEndTime; if (!examEndTime || isNaN(examEndTime) || Date.now() >= examEndTime) { console.warn("Restored exam state has expired or end time is invalid. Clearing state."); localStorage.removeItem(appStateKey); resetExamState(); showImprovedNotification('warning', 'Session Expired', 'Your previous exam session has expired.', 0); return; } showImprovedNotification('info', 'Exam Session Restored', 'Resuming your previous exam session.', 5000); signinPromptModule.classList.add('hidden'); examStartModule.classList.add('hidden'); examDetailsModule.classList.add('hidden'); submissionConfirmationModule.classList.add('hidden'); examQuestionsArea.parentElement.classList.remove('hidden'); displayExamDetailsHeader(); try { if (examDetails && examDetails.Questions && examDetails.OriginalOrderMap) { console.log("Waiting for questions to display before restoring answers..."); await displayQuestions(examDetails.Questions); console.log("Questions displayed. Proceeding with answer restoration."); if (state.currentAnswers) { console.log("Restoring saved answers..."); try { for (const answerName in state.currentAnswers) { const formElement = examForm.elements[answerName]; if (formElement && formElement.classList.contains('code-editor') && codeEditors[answerName]) { if (state.currentAnswers[answerName] !== 'FILE_SELECTED') { codeEditors[answerName].setValue(state.currentAnswers[answerName] || ''); } } else if (formElement && state.currentAnswers[answerName] !== 'FILE_SELECTED') { if(formElement.type === 'radio' || (formElement.length > 0 && formElement[0]?.type === 'radio')) { const valueToSelect = state.currentAnswers[answerName]; const radios = document.querySelectorAll(`input[name="${answerName}"]`); radios.forEach(radio => { radio.checked = (radio.value === valueToSelect); }); } else { formElement.value = state.currentAnswers[answerName]; } } } if (state.confirmationStatus) { confirmedQuestionsCount = document.querySelectorAll('.text-only-confirmed').length; for (const questionId in state.confirmationStatus) { const questionDiv = document.getElementById(questionId); if (questionDiv && state.confirmationStatus[questionId] && !questionDiv.classList.contains('text-only-question')) { confirmAnswer(questionId); } } } console.log(`Restored ${confirmedQuestionsCount}/${totalQuestions} confirmed answers`); } catch (e) { console.error("Error restoring saved answers:", e); } } checkAllConfirmed(); } else { console.error("Cannot restore questions display: Missing Questions or Order Map in saved state."); showImprovedNotification('error', 'Restore Failed', 'Could not restore exam questions. State might be corrupted.', 0); localStorage.removeItem(appStateKey); resetExamState(); return; } } catch (displayError) { console.error("Error during question display in restoreAppState:", displayError); showImprovedNotification('error', 'Restore Failed', 'Could not display exam questions during restore.', 0); localStorage.removeItem(appStateKey); resetExamState(); return; } startTimer(); console.log("Application state restoration process complete."); }

    // --- Utility Functions (showImprovedNotification, escapeHtml) ---
    // --- Paste definitions from previous version ---
     function showImprovedNotification(type, title, message, duration = 5000) { const container = notificationArea; if (!container) { console.error("Notification container element not found in the DOM."); return; } const notification = document.createElement('div'); notification.className = `in-page-notification in-page-notification-${type}`; let iconClass; switch (type) { case 'success': iconClass = 'fa-check-circle'; break; case 'error':   iconClass = 'fa-times-circle'; break; case 'warning': iconClass = 'fa-exclamation-triangle'; break; default:      iconClass = 'fa-info-circle'; } notification.innerHTML = `<i class="fas ${iconClass} fa-icon"></i><div class="notification-content"><strong>${title}</strong><br>${message.replace(/\n/g, '<br>')}</div><button type="button" class="notification-close" aria-label="Close">&times;</button>`; container.appendChild(notification); const closeBtn = notification.querySelector('.notification-close'); const removeNotification = () => { notification.classList.add('removing'); setTimeout(() => { if (notification.parentNode) { notification.parentNode.removeChild(notification); } }, 300); }; closeBtn?.addEventListener('click', (e) => { e.stopPropagation(); removeNotification(); }); if (duration > 0) { setTimeout(removeNotification, duration); } }


    // Make key functions globally available if needed by inline handlers
    window.confirmAnswer = confirmAnswer;
    window.editAnswer = editAnswer;
    // window.runPythonCode = runPythonCode; // If using mock execution buttons
    // window.formatPythonCode = formatPythonCode; // If using mock format buttons

</script>

</body>
</html>